
FREERTOS_V9.0.0_atmega32_Z_SecondShoot.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000013a8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000008  00800060  000013a8  0000143c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002a4  00800068  00800068  00001444  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001444  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001474  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000290  00000000  00000000  000014b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003616  00000000  00000000  00001740  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000f2a  00000000  00000000  00004d56  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001c7f  00000000  00000000  00005c80  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000007ec  00000000  00000000  00007900  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000115b  00000000  00000000  000080ec  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000033d8  00000000  00000000  00009247  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000002d8  00000000  00000000  0000c61f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 78 03 	jmp	0x6f0	; 0x6f0 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 ea       	ldi	r30, 0xA8	; 168
      68:	f3 e1       	ldi	r31, 0x13	; 19
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a8 36       	cpi	r26, 0x68	; 104
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	23 e0       	ldi	r18, 0x03	; 3
      78:	a8 e6       	ldi	r26, 0x68	; 104
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ac 30       	cpi	r26, 0x0C	; 12
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 e1 01 	call	0x3c2	; 0x3c2 <main>
      8a:	0c 94 d2 09 	jmp	0x13a4	; 0x13a4 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
      92:	0f 93       	push	r16
      94:	1f 93       	push	r17
      96:	cf 93       	push	r28
      98:	df 93       	push	r29
      9a:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
      9c:	0e 94 74 07 	call	0xee8	; 0xee8 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
      a0:	80 91 68 00 	lds	r24, 0x0068	; 0x800068 <__data_end>
      a4:	81 11       	cpse	r24, r1
      a6:	1d c0       	rjmp	.+58     	; 0xe2 <pvPortMalloc+0x50>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
      a8:	ed e6       	ldi	r30, 0x6D	; 109
      aa:	f0 e0       	ldi	r31, 0x00	; 0
      ac:	82 e7       	ldi	r24, 0x72	; 114
      ae:	90 e0       	ldi	r25, 0x00	; 0
      b0:	91 83       	std	Z+1, r25	; 0x01
      b2:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
      b4:	13 82       	std	Z+3, r1	; 0x03
      b6:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
      b8:	e9 e6       	ldi	r30, 0x69	; 105
      ba:	f0 e0       	ldi	r31, 0x00	; 0
      bc:	87 e5       	ldi	r24, 0x57	; 87
      be:	92 e0       	ldi	r25, 0x02	; 2
      c0:	93 83       	std	Z+3, r25	; 0x03
      c2:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
      c4:	11 82       	std	Z+1, r1	; 0x01
      c6:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
      c8:	a1 e7       	ldi	r26, 0x71	; 113
      ca:	b0 e0       	ldi	r27, 0x00	; 0
      cc:	14 96       	adiw	r26, 0x04	; 4
      ce:	9c 93       	st	X, r25
      d0:	8e 93       	st	-X, r24
      d2:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
      d4:	12 96       	adiw	r26, 0x02	; 2
      d6:	fc 93       	st	X, r31
      d8:	ee 93       	st	-X, r30
      da:	11 97       	sbiw	r26, 0x01	; 1
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
      dc:	81 e0       	ldi	r24, 0x01	; 1
      de:	80 93 68 00 	sts	0x0068, r24	; 0x800068 <__data_end>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
      e2:	20 97       	sbiw	r28, 0x00	; 0
      e4:	09 f4       	brne	.+2      	; 0xe8 <pvPortMalloc+0x56>
      e6:	5f c0       	rjmp	.+190    	; 0x1a6 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
      e8:	9e 01       	movw	r18, r28
      ea:	2c 5f       	subi	r18, 0xFC	; 252
      ec:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
      ee:	23 96       	adiw	r28, 0x03	; 3
      f0:	c6 35       	cpi	r28, 0x56	; 86
      f2:	d2 40       	sbci	r29, 0x02	; 2
      f4:	08 f0       	brcs	.+2      	; 0xf8 <pvPortMalloc+0x66>
      f6:	5a c0       	rjmp	.+180    	; 0x1ac <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
      f8:	e0 91 6d 00 	lds	r30, 0x006D	; 0x80006d <xStart>
      fc:	f0 91 6e 00 	lds	r31, 0x006E	; 0x80006e <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     100:	ad e6       	ldi	r26, 0x6D	; 109
     102:	b0 e0       	ldi	r27, 0x00	; 0
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     104:	02 c0       	rjmp	.+4      	; 0x10a <pvPortMalloc+0x78>
     106:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     108:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     10a:	82 81       	ldd	r24, Z+2	; 0x02
     10c:	93 81       	ldd	r25, Z+3	; 0x03
     10e:	82 17       	cp	r24, r18
     110:	93 07       	cpc	r25, r19
     112:	20 f4       	brcc	.+8      	; 0x11c <pvPortMalloc+0x8a>
     114:	80 81       	ld	r24, Z
     116:	91 81       	ldd	r25, Z+1	; 0x01
     118:	00 97       	sbiw	r24, 0x00	; 0
     11a:	a9 f7       	brne	.-22     	; 0x106 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     11c:	c0 e0       	ldi	r28, 0x00	; 0
     11e:	e9 36       	cpi	r30, 0x69	; 105
     120:	fc 07       	cpc	r31, r28
     122:	09 f4       	brne	.+2      	; 0x126 <pvPortMalloc+0x94>
     124:	46 c0       	rjmp	.+140    	; 0x1b2 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     126:	cd 91       	ld	r28, X+
     128:	dc 91       	ld	r29, X
     12a:	11 97       	sbiw	r26, 0x01	; 1
     12c:	8e 01       	movw	r16, r28
     12e:	0c 5f       	subi	r16, 0xFC	; 252
     130:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     132:	80 81       	ld	r24, Z
     134:	91 81       	ldd	r25, Z+1	; 0x01
     136:	8d 93       	st	X+, r24
     138:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     13a:	82 81       	ldd	r24, Z+2	; 0x02
     13c:	93 81       	ldd	r25, Z+3	; 0x03
     13e:	82 1b       	sub	r24, r18
     140:	93 0b       	sbc	r25, r19
     142:	89 30       	cpi	r24, 0x09	; 9
     144:	91 05       	cpc	r25, r1
     146:	10 f1       	brcs	.+68     	; 0x18c <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     148:	bf 01       	movw	r22, r30
     14a:	62 0f       	add	r22, r18
     14c:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     14e:	db 01       	movw	r26, r22
     150:	13 96       	adiw	r26, 0x03	; 3
     152:	9c 93       	st	X, r25
     154:	8e 93       	st	-X, r24
     156:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     158:	33 83       	std	Z+3, r19	; 0x03
     15a:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     15c:	12 96       	adiw	r26, 0x02	; 2
     15e:	4d 91       	ld	r20, X+
     160:	5c 91       	ld	r21, X
     162:	13 97       	sbiw	r26, 0x03	; 3
     164:	8d e6       	ldi	r24, 0x6D	; 109
     166:	90 e0       	ldi	r25, 0x00	; 0
     168:	01 c0       	rjmp	.+2      	; 0x16c <pvPortMalloc+0xda>
     16a:	cd 01       	movw	r24, r26
     16c:	ec 01       	movw	r28, r24
     16e:	a8 81       	ld	r26, Y
     170:	b9 81       	ldd	r27, Y+1	; 0x01
     172:	12 96       	adiw	r26, 0x02	; 2
     174:	2d 91       	ld	r18, X+
     176:	3c 91       	ld	r19, X
     178:	13 97       	sbiw	r26, 0x03	; 3
     17a:	24 17       	cp	r18, r20
     17c:	35 07       	cpc	r19, r21
     17e:	a8 f3       	brcs	.-22     	; 0x16a <pvPortMalloc+0xd8>
     180:	eb 01       	movw	r28, r22
     182:	b9 83       	std	Y+1, r27	; 0x01
     184:	a8 83       	st	Y, r26
     186:	dc 01       	movw	r26, r24
     188:	6d 93       	st	X+, r22
     18a:	7c 93       	st	X, r23
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     18c:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
     190:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__data_start+0x1>
     194:	22 81       	ldd	r18, Z+2	; 0x02
     196:	33 81       	ldd	r19, Z+3	; 0x03
     198:	82 1b       	sub	r24, r18
     19a:	93 0b       	sbc	r25, r19
     19c:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
     1a0:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
     1a4:	08 c0       	rjmp	.+16     	; 0x1b6 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     1a6:	00 e0       	ldi	r16, 0x00	; 0
     1a8:	10 e0       	ldi	r17, 0x00	; 0
     1aa:	05 c0       	rjmp	.+10     	; 0x1b6 <pvPortMalloc+0x124>
     1ac:	00 e0       	ldi	r16, 0x00	; 0
     1ae:	10 e0       	ldi	r17, 0x00	; 0
     1b0:	02 c0       	rjmp	.+4      	; 0x1b6 <pvPortMalloc+0x124>
     1b2:	00 e0       	ldi	r16, 0x00	; 0
     1b4:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     1b6:	0e 94 35 08 	call	0x106a	; 0x106a <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     1ba:	c8 01       	movw	r24, r16
     1bc:	df 91       	pop	r29
     1be:	cf 91       	pop	r28
     1c0:	1f 91       	pop	r17
     1c2:	0f 91       	pop	r16
     1c4:	08 95       	ret

000001c6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     1c6:	0f 93       	push	r16
     1c8:	1f 93       	push	r17
     1ca:	cf 93       	push	r28
     1cc:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     1ce:	00 97       	sbiw	r24, 0x00	; 0
     1d0:	41 f1       	breq	.+80     	; 0x222 <vPortFree+0x5c>
     1d2:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     1d4:	8c 01       	movw	r16, r24
     1d6:	04 50       	subi	r16, 0x04	; 4
     1d8:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     1da:	0e 94 74 07 	call	0xee8	; 0xee8 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     1de:	f8 01       	movw	r30, r16
     1e0:	42 81       	ldd	r20, Z+2	; 0x02
     1e2:	53 81       	ldd	r21, Z+3	; 0x03
     1e4:	ad e6       	ldi	r26, 0x6D	; 109
     1e6:	b0 e0       	ldi	r27, 0x00	; 0
     1e8:	01 c0       	rjmp	.+2      	; 0x1ec <vPortFree+0x26>
     1ea:	df 01       	movw	r26, r30
     1ec:	ed 91       	ld	r30, X+
     1ee:	fc 91       	ld	r31, X
     1f0:	11 97       	sbiw	r26, 0x01	; 1
     1f2:	22 81       	ldd	r18, Z+2	; 0x02
     1f4:	33 81       	ldd	r19, Z+3	; 0x03
     1f6:	24 17       	cp	r18, r20
     1f8:	35 07       	cpc	r19, r21
     1fa:	b8 f3       	brcs	.-18     	; 0x1ea <vPortFree+0x24>
     1fc:	24 97       	sbiw	r28, 0x04	; 4
     1fe:	f9 83       	std	Y+1, r31	; 0x01
     200:	e8 83       	st	Y, r30
     202:	0d 93       	st	X+, r16
     204:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     206:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <__data_start>
     20a:	30 91 61 00 	lds	r19, 0x0061	; 0x800061 <__data_start+0x1>
     20e:	8a 81       	ldd	r24, Y+2	; 0x02
     210:	9b 81       	ldd	r25, Y+3	; 0x03
     212:	82 0f       	add	r24, r18
     214:	93 1f       	adc	r25, r19
     216:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
     21a:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     21e:	0e 94 35 08 	call	0x106a	; 0x106a <xTaskResumeAll>
	}
}
     222:	df 91       	pop	r29
     224:	cf 91       	pop	r28
     226:	1f 91       	pop	r17
     228:	0f 91       	pop	r16
     22a:	08 95       	ret

0000022c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     22c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     22e:	03 96       	adiw	r24, 0x03	; 3
     230:	92 83       	std	Z+2, r25	; 0x02
     232:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     234:	2f ef       	ldi	r18, 0xFF	; 255
     236:	3f ef       	ldi	r19, 0xFF	; 255
     238:	34 83       	std	Z+4, r19	; 0x04
     23a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     23c:	96 83       	std	Z+6, r25	; 0x06
     23e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     240:	90 87       	std	Z+8, r25	; 0x08
     242:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     244:	10 82       	st	Z, r1
     246:	08 95       	ret

00000248 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     248:	fc 01       	movw	r30, r24
     24a:	11 86       	std	Z+9, r1	; 0x09
     24c:	10 86       	std	Z+8, r1	; 0x08
     24e:	08 95       	ret

00000250 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     250:	cf 93       	push	r28
     252:	df 93       	push	r29
     254:	9c 01       	movw	r18, r24
     256:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     258:	dc 01       	movw	r26, r24
     25a:	11 96       	adiw	r26, 0x01	; 1
     25c:	cd 91       	ld	r28, X+
     25e:	dc 91       	ld	r29, X
     260:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     262:	d3 83       	std	Z+3, r29	; 0x03
     264:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     266:	8c 81       	ldd	r24, Y+4	; 0x04
     268:	9d 81       	ldd	r25, Y+5	; 0x05
     26a:	95 83       	std	Z+5, r25	; 0x05
     26c:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     26e:	8c 81       	ldd	r24, Y+4	; 0x04
     270:	9d 81       	ldd	r25, Y+5	; 0x05
     272:	dc 01       	movw	r26, r24
     274:	13 96       	adiw	r26, 0x03	; 3
     276:	7c 93       	st	X, r23
     278:	6e 93       	st	-X, r22
     27a:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     27c:	7d 83       	std	Y+5, r23	; 0x05
     27e:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     280:	31 87       	std	Z+9, r19	; 0x09
     282:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     284:	f9 01       	movw	r30, r18
     286:	80 81       	ld	r24, Z
     288:	8f 5f       	subi	r24, 0xFF	; 255
     28a:	80 83       	st	Z, r24
}
     28c:	df 91       	pop	r29
     28e:	cf 91       	pop	r28
     290:	08 95       	ret

00000292 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     292:	cf 93       	push	r28
     294:	df 93       	push	r29
     296:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     298:	48 81       	ld	r20, Y
     29a:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     29c:	4f 3f       	cpi	r20, 0xFF	; 255
     29e:	2f ef       	ldi	r18, 0xFF	; 255
     2a0:	52 07       	cpc	r21, r18
     2a2:	21 f4       	brne	.+8      	; 0x2ac <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     2a4:	fc 01       	movw	r30, r24
     2a6:	a7 81       	ldd	r26, Z+7	; 0x07
     2a8:	b0 85       	ldd	r27, Z+8	; 0x08
     2aa:	0d c0       	rjmp	.+26     	; 0x2c6 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     2ac:	dc 01       	movw	r26, r24
     2ae:	13 96       	adiw	r26, 0x03	; 3
     2b0:	01 c0       	rjmp	.+2      	; 0x2b4 <vListInsert+0x22>
     2b2:	df 01       	movw	r26, r30
     2b4:	12 96       	adiw	r26, 0x02	; 2
     2b6:	ed 91       	ld	r30, X+
     2b8:	fc 91       	ld	r31, X
     2ba:	13 97       	sbiw	r26, 0x03	; 3
     2bc:	20 81       	ld	r18, Z
     2be:	31 81       	ldd	r19, Z+1	; 0x01
     2c0:	42 17       	cp	r20, r18
     2c2:	53 07       	cpc	r21, r19
     2c4:	b0 f7       	brcc	.-20     	; 0x2b2 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     2c6:	12 96       	adiw	r26, 0x02	; 2
     2c8:	ed 91       	ld	r30, X+
     2ca:	fc 91       	ld	r31, X
     2cc:	13 97       	sbiw	r26, 0x03	; 3
     2ce:	fb 83       	std	Y+3, r31	; 0x03
     2d0:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     2d2:	d5 83       	std	Z+5, r29	; 0x05
     2d4:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     2d6:	bd 83       	std	Y+5, r27	; 0x05
     2d8:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     2da:	13 96       	adiw	r26, 0x03	; 3
     2dc:	dc 93       	st	X, r29
     2de:	ce 93       	st	-X, r28
     2e0:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     2e2:	99 87       	std	Y+9, r25	; 0x09
     2e4:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     2e6:	fc 01       	movw	r30, r24
     2e8:	20 81       	ld	r18, Z
     2ea:	2f 5f       	subi	r18, 0xFF	; 255
     2ec:	20 83       	st	Z, r18
}
     2ee:	df 91       	pop	r29
     2f0:	cf 91       	pop	r28
     2f2:	08 95       	ret

000002f4 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     2f4:	cf 93       	push	r28
     2f6:	df 93       	push	r29
     2f8:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     2fa:	a0 85       	ldd	r26, Z+8	; 0x08
     2fc:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     2fe:	c2 81       	ldd	r28, Z+2	; 0x02
     300:	d3 81       	ldd	r29, Z+3	; 0x03
     302:	84 81       	ldd	r24, Z+4	; 0x04
     304:	95 81       	ldd	r25, Z+5	; 0x05
     306:	9d 83       	std	Y+5, r25	; 0x05
     308:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     30a:	c4 81       	ldd	r28, Z+4	; 0x04
     30c:	d5 81       	ldd	r29, Z+5	; 0x05
     30e:	82 81       	ldd	r24, Z+2	; 0x02
     310:	93 81       	ldd	r25, Z+3	; 0x03
     312:	9b 83       	std	Y+3, r25	; 0x03
     314:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     316:	11 96       	adiw	r26, 0x01	; 1
     318:	8d 91       	ld	r24, X+
     31a:	9c 91       	ld	r25, X
     31c:	12 97       	sbiw	r26, 0x02	; 2
     31e:	e8 17       	cp	r30, r24
     320:	f9 07       	cpc	r31, r25
     322:	31 f4       	brne	.+12     	; 0x330 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     324:	84 81       	ldd	r24, Z+4	; 0x04
     326:	95 81       	ldd	r25, Z+5	; 0x05
     328:	12 96       	adiw	r26, 0x02	; 2
     32a:	9c 93       	st	X, r25
     32c:	8e 93       	st	-X, r24
     32e:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     330:	11 86       	std	Z+9, r1	; 0x09
     332:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     334:	8c 91       	ld	r24, X
     336:	81 50       	subi	r24, 0x01	; 1
     338:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     33a:	df 91       	pop	r29
     33c:	cf 91       	pop	r28
     33e:	08 95       	ret

00000340 <task1>:
		PORTA=PORTB=PORTC=PORTD=0x55;
	}
	
}
void task1(void * pv)
{
     340:	cf 93       	push	r28
     342:	df 93       	push	r29
     344:	1f 92       	push	r1
     346:	cd b7       	in	r28, 0x3d	; 61
     348:	de b7       	in	r29, 0x3e	; 62
	char loc_val=(char)pv;
     34a:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		PORTC ^=(1<<1);
     34c:	12 e0       	ldi	r17, 0x02	; 2
		PORTA=loc_val;
		portBASE_TYPE stat= xQueueSendToBack(queue_1_handle,&loc_val,10);
		loc_val++;
		if (stat==pdFAIL)
		{
			PORTA=0xff;
     34e:	0f ef       	ldi	r16, 0xFF	; 255
void task1(void * pv)
{
	char loc_val=(char)pv;
	while(1)
	{
		PORTC ^=(1<<1);
     350:	85 b3       	in	r24, 0x15	; 21
     352:	81 27       	eor	r24, r17
     354:	85 bb       	out	0x15, r24	; 21
		PORTA=loc_val;
     356:	89 81       	ldd	r24, Y+1	; 0x01
     358:	8b bb       	out	0x1b, r24	; 27
		portBASE_TYPE stat= xQueueSendToBack(queue_1_handle,&loc_val,10);
     35a:	20 e0       	ldi	r18, 0x00	; 0
     35c:	4a e0       	ldi	r20, 0x0A	; 10
     35e:	50 e0       	ldi	r21, 0x00	; 0
     360:	be 01       	movw	r22, r28
     362:	6f 5f       	subi	r22, 0xFF	; 255
     364:	7f 4f       	sbci	r23, 0xFF	; 255
     366:	80 91 0a 03 	lds	r24, 0x030A	; 0x80030a <queue_1_handle>
     36a:	90 91 0b 03 	lds	r25, 0x030B	; 0x80030b <queue_1_handle+0x1>
     36e:	0e 94 95 04 	call	0x92a	; 0x92a <xQueueGenericSend>
		loc_val++;
     372:	99 81       	ldd	r25, Y+1	; 0x01
     374:	9f 5f       	subi	r25, 0xFF	; 255
     376:	99 83       	std	Y+1, r25	; 0x01
		if (stat==pdFAIL)
     378:	81 11       	cpse	r24, r1
     37a:	01 c0       	rjmp	.+2      	; 0x37e <task1+0x3e>
		{
			PORTA=0xff;
     37c:	0b bb       	out	0x1b, r16	; 27
		}
		vTaskDelay(100);
     37e:	84 e6       	ldi	r24, 0x64	; 100
     380:	90 e0       	ldi	r25, 0x00	; 0
     382:	0e 94 b4 08 	call	0x1168	; 0x1168 <vTaskDelay>
	}
     386:	e4 cf       	rjmp	.-56     	; 0x350 <task1+0x10>

00000388 <task2>:
}

void task2(void * pv)
{
     388:	cf 93       	push	r28
     38a:	df 93       	push	r29
     38c:	1f 92       	push	r1
     38e:	cd b7       	in	r28, 0x3d	; 61
     390:	de b7       	in	r29, 0x3e	; 62
	portBASE_TYPE rx_buff=0;
     392:	19 82       	std	Y+1, r1	; 0x01
	while(1)
	{
		PORTC ^=(1<<2);
     394:	14 e0       	ldi	r17, 0x04	; 4
     396:	85 b3       	in	r24, 0x15	; 21
     398:	81 27       	eor	r24, r17
     39a:	85 bb       	out	0x15, r24	; 21
		xQueueReceive(queue_1_handle,&rx_buff,10);
     39c:	20 e0       	ldi	r18, 0x00	; 0
     39e:	4a e0       	ldi	r20, 0x0A	; 10
     3a0:	50 e0       	ldi	r21, 0x00	; 0
     3a2:	be 01       	movw	r22, r28
     3a4:	6f 5f       	subi	r22, 0xFF	; 255
     3a6:	7f 4f       	sbci	r23, 0xFF	; 255
     3a8:	80 91 0a 03 	lds	r24, 0x030A	; 0x80030a <queue_1_handle>
     3ac:	90 91 0b 03 	lds	r25, 0x030B	; 0x80030b <queue_1_handle+0x1>
     3b0:	0e 94 36 05 	call	0xa6c	; 0xa6c <xQueueGenericReceive>
		PORTB= rx_buff;
     3b4:	89 81       	ldd	r24, Y+1	; 0x01
     3b6:	88 bb       	out	0x18, r24	; 24
		vTaskDelay(100);
     3b8:	84 e6       	ldi	r24, 0x64	; 100
     3ba:	90 e0       	ldi	r25, 0x00	; 0
     3bc:	0e 94 b4 08 	call	0x1168	; 0x1168 <vTaskDelay>
     3c0:	ea cf       	rjmp	.-44     	; 0x396 <task2+0xe>

000003c2 <main>:

void task1(void * pv);
void task2(void * pv);
xQueueHandle queue_1_handle;
void main(void)
{
     3c2:	ef 92       	push	r14
     3c4:	ff 92       	push	r15
     3c6:	0f 93       	push	r16
     3c8:	cf 93       	push	r28
     3ca:	df 93       	push	r29
     3cc:	1f 92       	push	r1
     3ce:	cd b7       	in	r28, 0x3d	; 61
     3d0:	de b7       	in	r29, 0x3e	; 62
	DDRA=0xff;		DDRB=0xff;		DDRC=0xff;		DDRD=0xff;
     3d2:	8f ef       	ldi	r24, 0xFF	; 255
     3d4:	8a bb       	out	0x1a, r24	; 26
     3d6:	87 bb       	out	0x17, r24	; 23
     3d8:	84 bb       	out	0x14, r24	; 20
     3da:	81 bb       	out	0x11, r24	; 17
	char msa=0xff;
     3dc:	89 83       	std	Y+1, r24	; 0x01
	queue_1_handle=xQueueCreate( 2,sizeof(int));
     3de:	40 e0       	ldi	r20, 0x00	; 0
     3e0:	62 e0       	ldi	r22, 0x02	; 2
     3e2:	82 e0       	ldi	r24, 0x02	; 2
     3e4:	0e 94 68 04 	call	0x8d0	; 0x8d0 <xQueueGenericCreate>
     3e8:	90 93 0b 03 	sts	0x030B, r25	; 0x80030b <queue_1_handle+0x1>
     3ec:	80 93 0a 03 	sts	0x030A, r24	; 0x80030a <queue_1_handle>
	if (queue_1_handle != NULL)
     3f0:	89 2b       	or	r24, r25
     3f2:	e1 f0       	breq	.+56     	; 0x42c <__LOCK_REGION_LENGTH__+0x2c>
	{
	
	xTaskCreate(task1,NULL,configMINIMAL_STACK_SIZE,(void *)&msa,1,NULL);
     3f4:	e1 2c       	mov	r14, r1
     3f6:	f1 2c       	mov	r15, r1
     3f8:	01 e0       	ldi	r16, 0x01	; 1
     3fa:	9e 01       	movw	r18, r28
     3fc:	2f 5f       	subi	r18, 0xFF	; 255
     3fe:	3f 4f       	sbci	r19, 0xFF	; 255
     400:	44 e6       	ldi	r20, 0x64	; 100
     402:	50 e0       	ldi	r21, 0x00	; 0
     404:	60 e0       	ldi	r22, 0x00	; 0
     406:	70 e0       	ldi	r23, 0x00	; 0
     408:	80 ea       	ldi	r24, 0xA0	; 160
     40a:	91 e0       	ldi	r25, 0x01	; 1
     40c:	0e 94 4f 06 	call	0xc9e	; 0xc9e <xTaskCreate>
	xTaskCreate(task2,NULL,configMINIMAL_STACK_SIZE,(void *)&msa,1,NULL);
     410:	9e 01       	movw	r18, r28
     412:	2f 5f       	subi	r18, 0xFF	; 255
     414:	3f 4f       	sbci	r19, 0xFF	; 255
     416:	44 e6       	ldi	r20, 0x64	; 100
     418:	50 e0       	ldi	r21, 0x00	; 0
     41a:	60 e0       	ldi	r22, 0x00	; 0
     41c:	70 e0       	ldi	r23, 0x00	; 0
     41e:	84 ec       	ldi	r24, 0xC4	; 196
     420:	91 e0       	ldi	r25, 0x01	; 1
     422:	0e 94 4f 06 	call	0xc9e	; 0xc9e <xTaskCreate>
	
	vTaskStartScheduler();
     426:	0e 94 4a 07 	call	0xe94	; 0xe94 <vTaskStartScheduler>
     42a:	05 c0       	rjmp	.+10     	; 0x436 <__LOCK_REGION_LENGTH__+0x36>
	}
	else //couldn't create a queue
	{
		PORTA=PORTB=PORTC=PORTD=0x55;
     42c:	85 e5       	ldi	r24, 0x55	; 85
     42e:	82 bb       	out	0x12, r24	; 18
     430:	85 bb       	out	0x15, r24	; 21
     432:	88 bb       	out	0x18, r24	; 24
     434:	8b bb       	out	0x1b, r24	; 27
	}
	
}
     436:	0f 90       	pop	r0
     438:	df 91       	pop	r29
     43a:	cf 91       	pop	r28
     43c:	0f 91       	pop	r16
     43e:	ff 90       	pop	r15
     440:	ef 90       	pop	r14
     442:	08 95       	ret

00000444 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     444:	31 e1       	ldi	r19, 0x11	; 17
     446:	fc 01       	movw	r30, r24
     448:	30 83       	st	Z, r19
     44a:	31 97       	sbiw	r30, 0x01	; 1
     44c:	22 e2       	ldi	r18, 0x22	; 34
     44e:	20 83       	st	Z, r18
     450:	31 97       	sbiw	r30, 0x01	; 1
     452:	a3 e3       	ldi	r26, 0x33	; 51
     454:	a0 83       	st	Z, r26
     456:	31 97       	sbiw	r30, 0x01	; 1
     458:	60 83       	st	Z, r22
     45a:	31 97       	sbiw	r30, 0x01	; 1
     45c:	70 83       	st	Z, r23
     45e:	31 97       	sbiw	r30, 0x01	; 1
     460:	10 82       	st	Z, r1
     462:	31 97       	sbiw	r30, 0x01	; 1
     464:	60 e8       	ldi	r22, 0x80	; 128
     466:	60 83       	st	Z, r22
     468:	31 97       	sbiw	r30, 0x01	; 1
     46a:	10 82       	st	Z, r1
     46c:	31 97       	sbiw	r30, 0x01	; 1
     46e:	62 e0       	ldi	r22, 0x02	; 2
     470:	60 83       	st	Z, r22
     472:	31 97       	sbiw	r30, 0x01	; 1
     474:	63 e0       	ldi	r22, 0x03	; 3
     476:	60 83       	st	Z, r22
     478:	31 97       	sbiw	r30, 0x01	; 1
     47a:	64 e0       	ldi	r22, 0x04	; 4
     47c:	60 83       	st	Z, r22
     47e:	31 97       	sbiw	r30, 0x01	; 1
     480:	65 e0       	ldi	r22, 0x05	; 5
     482:	60 83       	st	Z, r22
     484:	31 97       	sbiw	r30, 0x01	; 1
     486:	66 e0       	ldi	r22, 0x06	; 6
     488:	60 83       	st	Z, r22
     48a:	31 97       	sbiw	r30, 0x01	; 1
     48c:	67 e0       	ldi	r22, 0x07	; 7
     48e:	60 83       	st	Z, r22
     490:	31 97       	sbiw	r30, 0x01	; 1
     492:	68 e0       	ldi	r22, 0x08	; 8
     494:	60 83       	st	Z, r22
     496:	31 97       	sbiw	r30, 0x01	; 1
     498:	69 e0       	ldi	r22, 0x09	; 9
     49a:	60 83       	st	Z, r22
     49c:	31 97       	sbiw	r30, 0x01	; 1
     49e:	60 e1       	ldi	r22, 0x10	; 16
     4a0:	60 83       	st	Z, r22
     4a2:	31 97       	sbiw	r30, 0x01	; 1
     4a4:	30 83       	st	Z, r19
     4a6:	31 97       	sbiw	r30, 0x01	; 1
     4a8:	32 e1       	ldi	r19, 0x12	; 18
     4aa:	30 83       	st	Z, r19
     4ac:	31 97       	sbiw	r30, 0x01	; 1
     4ae:	33 e1       	ldi	r19, 0x13	; 19
     4b0:	30 83       	st	Z, r19
     4b2:	31 97       	sbiw	r30, 0x01	; 1
     4b4:	34 e1       	ldi	r19, 0x14	; 20
     4b6:	30 83       	st	Z, r19
     4b8:	31 97       	sbiw	r30, 0x01	; 1
     4ba:	35 e1       	ldi	r19, 0x15	; 21
     4bc:	30 83       	st	Z, r19
     4be:	31 97       	sbiw	r30, 0x01	; 1
     4c0:	36 e1       	ldi	r19, 0x16	; 22
     4c2:	30 83       	st	Z, r19
     4c4:	31 97       	sbiw	r30, 0x01	; 1
     4c6:	37 e1       	ldi	r19, 0x17	; 23
     4c8:	30 83       	st	Z, r19
     4ca:	31 97       	sbiw	r30, 0x01	; 1
     4cc:	38 e1       	ldi	r19, 0x18	; 24
     4ce:	30 83       	st	Z, r19
     4d0:	31 97       	sbiw	r30, 0x01	; 1
     4d2:	39 e1       	ldi	r19, 0x19	; 25
     4d4:	30 83       	st	Z, r19
     4d6:	31 97       	sbiw	r30, 0x01	; 1
     4d8:	30 e2       	ldi	r19, 0x20	; 32
     4da:	30 83       	st	Z, r19
     4dc:	31 97       	sbiw	r30, 0x01	; 1
     4de:	31 e2       	ldi	r19, 0x21	; 33
     4e0:	30 83       	st	Z, r19
     4e2:	31 97       	sbiw	r30, 0x01	; 1
     4e4:	20 83       	st	Z, r18
     4e6:	31 97       	sbiw	r30, 0x01	; 1
     4e8:	23 e2       	ldi	r18, 0x23	; 35
     4ea:	20 83       	st	Z, r18
     4ec:	31 97       	sbiw	r30, 0x01	; 1
     4ee:	40 83       	st	Z, r20
     4f0:	31 97       	sbiw	r30, 0x01	; 1
     4f2:	50 83       	st	Z, r21
     4f4:	31 97       	sbiw	r30, 0x01	; 1
     4f6:	26 e2       	ldi	r18, 0x26	; 38
     4f8:	20 83       	st	Z, r18
     4fa:	31 97       	sbiw	r30, 0x01	; 1
     4fc:	27 e2       	ldi	r18, 0x27	; 39
     4fe:	20 83       	st	Z, r18
     500:	31 97       	sbiw	r30, 0x01	; 1
     502:	28 e2       	ldi	r18, 0x28	; 40
     504:	20 83       	st	Z, r18
     506:	31 97       	sbiw	r30, 0x01	; 1
     508:	29 e2       	ldi	r18, 0x29	; 41
     50a:	20 83       	st	Z, r18
     50c:	31 97       	sbiw	r30, 0x01	; 1
     50e:	20 e3       	ldi	r18, 0x30	; 48
     510:	20 83       	st	Z, r18
     512:	31 97       	sbiw	r30, 0x01	; 1
     514:	21 e3       	ldi	r18, 0x31	; 49
     516:	20 83       	st	Z, r18
     518:	86 97       	sbiw	r24, 0x26	; 38
     51a:	08 95       	ret

0000051c <xPortStartScheduler>:
     51c:	1b bc       	out	0x2b, r1	; 43
     51e:	8c e7       	ldi	r24, 0x7C	; 124
     520:	8a bd       	out	0x2a, r24	; 42
     522:	8b e0       	ldi	r24, 0x0B	; 11
     524:	8e bd       	out	0x2e, r24	; 46
     526:	89 b7       	in	r24, 0x39	; 57
     528:	80 61       	ori	r24, 0x10	; 16
     52a:	89 bf       	out	0x39, r24	; 57
     52c:	a0 91 08 03 	lds	r26, 0x0308	; 0x800308 <pxCurrentTCB>
     530:	b0 91 09 03 	lds	r27, 0x0309	; 0x800309 <pxCurrentTCB+0x1>
     534:	cd 91       	ld	r28, X+
     536:	cd bf       	out	0x3d, r28	; 61
     538:	dd 91       	ld	r29, X+
     53a:	de bf       	out	0x3e, r29	; 62
     53c:	ff 91       	pop	r31
     53e:	ef 91       	pop	r30
     540:	df 91       	pop	r29
     542:	cf 91       	pop	r28
     544:	bf 91       	pop	r27
     546:	af 91       	pop	r26
     548:	9f 91       	pop	r25
     54a:	8f 91       	pop	r24
     54c:	7f 91       	pop	r23
     54e:	6f 91       	pop	r22
     550:	5f 91       	pop	r21
     552:	4f 91       	pop	r20
     554:	3f 91       	pop	r19
     556:	2f 91       	pop	r18
     558:	1f 91       	pop	r17
     55a:	0f 91       	pop	r16
     55c:	ff 90       	pop	r15
     55e:	ef 90       	pop	r14
     560:	df 90       	pop	r13
     562:	cf 90       	pop	r12
     564:	bf 90       	pop	r11
     566:	af 90       	pop	r10
     568:	9f 90       	pop	r9
     56a:	8f 90       	pop	r8
     56c:	7f 90       	pop	r7
     56e:	6f 90       	pop	r6
     570:	5f 90       	pop	r5
     572:	4f 90       	pop	r4
     574:	3f 90       	pop	r3
     576:	2f 90       	pop	r2
     578:	1f 90       	pop	r1
     57a:	0f 90       	pop	r0
     57c:	0f be       	out	0x3f, r0	; 63
     57e:	0f 90       	pop	r0
     580:	08 95       	ret
     582:	81 e0       	ldi	r24, 0x01	; 1
     584:	08 95       	ret

00000586 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     586:	0f 92       	push	r0
     588:	0f b6       	in	r0, 0x3f	; 63
     58a:	f8 94       	cli
     58c:	0f 92       	push	r0
     58e:	1f 92       	push	r1
     590:	11 24       	eor	r1, r1
     592:	2f 92       	push	r2
     594:	3f 92       	push	r3
     596:	4f 92       	push	r4
     598:	5f 92       	push	r5
     59a:	6f 92       	push	r6
     59c:	7f 92       	push	r7
     59e:	8f 92       	push	r8
     5a0:	9f 92       	push	r9
     5a2:	af 92       	push	r10
     5a4:	bf 92       	push	r11
     5a6:	cf 92       	push	r12
     5a8:	df 92       	push	r13
     5aa:	ef 92       	push	r14
     5ac:	ff 92       	push	r15
     5ae:	0f 93       	push	r16
     5b0:	1f 93       	push	r17
     5b2:	2f 93       	push	r18
     5b4:	3f 93       	push	r19
     5b6:	4f 93       	push	r20
     5b8:	5f 93       	push	r21
     5ba:	6f 93       	push	r22
     5bc:	7f 93       	push	r23
     5be:	8f 93       	push	r24
     5c0:	9f 93       	push	r25
     5c2:	af 93       	push	r26
     5c4:	bf 93       	push	r27
     5c6:	cf 93       	push	r28
     5c8:	df 93       	push	r29
     5ca:	ef 93       	push	r30
     5cc:	ff 93       	push	r31
     5ce:	a0 91 08 03 	lds	r26, 0x0308	; 0x800308 <pxCurrentTCB>
     5d2:	b0 91 09 03 	lds	r27, 0x0309	; 0x800309 <pxCurrentTCB+0x1>
     5d6:	0d b6       	in	r0, 0x3d	; 61
     5d8:	0d 92       	st	X+, r0
     5da:	0e b6       	in	r0, 0x3e	; 62
     5dc:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     5de:	0e 94 c8 08 	call	0x1190	; 0x1190 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     5e2:	a0 91 08 03 	lds	r26, 0x0308	; 0x800308 <pxCurrentTCB>
     5e6:	b0 91 09 03 	lds	r27, 0x0309	; 0x800309 <pxCurrentTCB+0x1>
     5ea:	cd 91       	ld	r28, X+
     5ec:	cd bf       	out	0x3d, r28	; 61
     5ee:	dd 91       	ld	r29, X+
     5f0:	de bf       	out	0x3e, r29	; 62
     5f2:	ff 91       	pop	r31
     5f4:	ef 91       	pop	r30
     5f6:	df 91       	pop	r29
     5f8:	cf 91       	pop	r28
     5fa:	bf 91       	pop	r27
     5fc:	af 91       	pop	r26
     5fe:	9f 91       	pop	r25
     600:	8f 91       	pop	r24
     602:	7f 91       	pop	r23
     604:	6f 91       	pop	r22
     606:	5f 91       	pop	r21
     608:	4f 91       	pop	r20
     60a:	3f 91       	pop	r19
     60c:	2f 91       	pop	r18
     60e:	1f 91       	pop	r17
     610:	0f 91       	pop	r16
     612:	ff 90       	pop	r15
     614:	ef 90       	pop	r14
     616:	df 90       	pop	r13
     618:	cf 90       	pop	r12
     61a:	bf 90       	pop	r11
     61c:	af 90       	pop	r10
     61e:	9f 90       	pop	r9
     620:	8f 90       	pop	r8
     622:	7f 90       	pop	r7
     624:	6f 90       	pop	r6
     626:	5f 90       	pop	r5
     628:	4f 90       	pop	r4
     62a:	3f 90       	pop	r3
     62c:	2f 90       	pop	r2
     62e:	1f 90       	pop	r1
     630:	0f 90       	pop	r0
     632:	0f be       	out	0x3f, r0	; 63
     634:	0f 90       	pop	r0

	asm volatile ( "ret" );
     636:	08 95       	ret

00000638 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     638:	0f 92       	push	r0
     63a:	0f b6       	in	r0, 0x3f	; 63
     63c:	f8 94       	cli
     63e:	0f 92       	push	r0
     640:	1f 92       	push	r1
     642:	11 24       	eor	r1, r1
     644:	2f 92       	push	r2
     646:	3f 92       	push	r3
     648:	4f 92       	push	r4
     64a:	5f 92       	push	r5
     64c:	6f 92       	push	r6
     64e:	7f 92       	push	r7
     650:	8f 92       	push	r8
     652:	9f 92       	push	r9
     654:	af 92       	push	r10
     656:	bf 92       	push	r11
     658:	cf 92       	push	r12
     65a:	df 92       	push	r13
     65c:	ef 92       	push	r14
     65e:	ff 92       	push	r15
     660:	0f 93       	push	r16
     662:	1f 93       	push	r17
     664:	2f 93       	push	r18
     666:	3f 93       	push	r19
     668:	4f 93       	push	r20
     66a:	5f 93       	push	r21
     66c:	6f 93       	push	r22
     66e:	7f 93       	push	r23
     670:	8f 93       	push	r24
     672:	9f 93       	push	r25
     674:	af 93       	push	r26
     676:	bf 93       	push	r27
     678:	cf 93       	push	r28
     67a:	df 93       	push	r29
     67c:	ef 93       	push	r30
     67e:	ff 93       	push	r31
     680:	a0 91 08 03 	lds	r26, 0x0308	; 0x800308 <pxCurrentTCB>
     684:	b0 91 09 03 	lds	r27, 0x0309	; 0x800309 <pxCurrentTCB+0x1>
     688:	0d b6       	in	r0, 0x3d	; 61
     68a:	0d 92       	st	X+, r0
     68c:	0e b6       	in	r0, 0x3e	; 62
     68e:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     690:	0e 94 7a 07 	call	0xef4	; 0xef4 <xTaskIncrementTick>
     694:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     696:	0e 94 c8 08 	call	0x1190	; 0x1190 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     69a:	a0 91 08 03 	lds	r26, 0x0308	; 0x800308 <pxCurrentTCB>
     69e:	b0 91 09 03 	lds	r27, 0x0309	; 0x800309 <pxCurrentTCB+0x1>
     6a2:	cd 91       	ld	r28, X+
     6a4:	cd bf       	out	0x3d, r28	; 61
     6a6:	dd 91       	ld	r29, X+
     6a8:	de bf       	out	0x3e, r29	; 62
     6aa:	ff 91       	pop	r31
     6ac:	ef 91       	pop	r30
     6ae:	df 91       	pop	r29
     6b0:	cf 91       	pop	r28
     6b2:	bf 91       	pop	r27
     6b4:	af 91       	pop	r26
     6b6:	9f 91       	pop	r25
     6b8:	8f 91       	pop	r24
     6ba:	7f 91       	pop	r23
     6bc:	6f 91       	pop	r22
     6be:	5f 91       	pop	r21
     6c0:	4f 91       	pop	r20
     6c2:	3f 91       	pop	r19
     6c4:	2f 91       	pop	r18
     6c6:	1f 91       	pop	r17
     6c8:	0f 91       	pop	r16
     6ca:	ff 90       	pop	r15
     6cc:	ef 90       	pop	r14
     6ce:	df 90       	pop	r13
     6d0:	cf 90       	pop	r12
     6d2:	bf 90       	pop	r11
     6d4:	af 90       	pop	r10
     6d6:	9f 90       	pop	r9
     6d8:	8f 90       	pop	r8
     6da:	7f 90       	pop	r7
     6dc:	6f 90       	pop	r6
     6de:	5f 90       	pop	r5
     6e0:	4f 90       	pop	r4
     6e2:	3f 90       	pop	r3
     6e4:	2f 90       	pop	r2
     6e6:	1f 90       	pop	r1
     6e8:	0f 90       	pop	r0
     6ea:	0f be       	out	0x3f, r0	; 63
     6ec:	0f 90       	pop	r0

	asm volatile ( "ret" );
     6ee:	08 95       	ret

000006f0 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     6f0:	0e 94 1c 03 	call	0x638	; 0x638 <vPortYieldFromTick>
		asm volatile ( "reti" );
     6f4:	18 95       	reti

000006f6 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     6f6:	0f 93       	push	r16
     6f8:	1f 93       	push	r17
     6fa:	cf 93       	push	r28
     6fc:	df 93       	push	r29
     6fe:	ec 01       	movw	r28, r24
     700:	04 2f       	mov	r16, r20
     702:	1a 8d       	ldd	r17, Y+26	; 0x1a
     704:	4c 8d       	ldd	r20, Y+28	; 0x1c
     706:	44 23       	and	r20, r20
     708:	b9 f1       	breq	.+110    	; 0x778 <prvCopyDataToQueue+0x82>
     70a:	01 11       	cpse	r16, r1
     70c:	16 c0       	rjmp	.+44     	; 0x73a <prvCopyDataToQueue+0x44>
     70e:	50 e0       	ldi	r21, 0x00	; 0
     710:	8c 81       	ldd	r24, Y+4	; 0x04
     712:	9d 81       	ldd	r25, Y+5	; 0x05
     714:	0e 94 c9 09 	call	0x1392	; 0x1392 <memcpy>
     718:	2c 8d       	ldd	r18, Y+28	; 0x1c
     71a:	8c 81       	ldd	r24, Y+4	; 0x04
     71c:	9d 81       	ldd	r25, Y+5	; 0x05
     71e:	82 0f       	add	r24, r18
     720:	91 1d       	adc	r25, r1
     722:	9d 83       	std	Y+5, r25	; 0x05
     724:	8c 83       	std	Y+4, r24	; 0x04
     726:	2a 81       	ldd	r18, Y+2	; 0x02
     728:	3b 81       	ldd	r19, Y+3	; 0x03
     72a:	82 17       	cp	r24, r18
     72c:	93 07       	cpc	r25, r19
     72e:	20 f1       	brcs	.+72     	; 0x778 <prvCopyDataToQueue+0x82>
     730:	88 81       	ld	r24, Y
     732:	99 81       	ldd	r25, Y+1	; 0x01
     734:	9d 83       	std	Y+5, r25	; 0x05
     736:	8c 83       	std	Y+4, r24	; 0x04
     738:	1f c0       	rjmp	.+62     	; 0x778 <prvCopyDataToQueue+0x82>
     73a:	50 e0       	ldi	r21, 0x00	; 0
     73c:	8e 81       	ldd	r24, Y+6	; 0x06
     73e:	9f 81       	ldd	r25, Y+7	; 0x07
     740:	0e 94 c9 09 	call	0x1392	; 0x1392 <memcpy>
     744:	8c 8d       	ldd	r24, Y+28	; 0x1c
     746:	90 e0       	ldi	r25, 0x00	; 0
     748:	91 95       	neg	r25
     74a:	81 95       	neg	r24
     74c:	91 09       	sbc	r25, r1
     74e:	2e 81       	ldd	r18, Y+6	; 0x06
     750:	3f 81       	ldd	r19, Y+7	; 0x07
     752:	28 0f       	add	r18, r24
     754:	39 1f       	adc	r19, r25
     756:	3f 83       	std	Y+7, r19	; 0x07
     758:	2e 83       	std	Y+6, r18	; 0x06
     75a:	48 81       	ld	r20, Y
     75c:	59 81       	ldd	r21, Y+1	; 0x01
     75e:	24 17       	cp	r18, r20
     760:	35 07       	cpc	r19, r21
     762:	30 f4       	brcc	.+12     	; 0x770 <prvCopyDataToQueue+0x7a>
     764:	2a 81       	ldd	r18, Y+2	; 0x02
     766:	3b 81       	ldd	r19, Y+3	; 0x03
     768:	82 0f       	add	r24, r18
     76a:	93 1f       	adc	r25, r19
     76c:	9f 83       	std	Y+7, r25	; 0x07
     76e:	8e 83       	std	Y+6, r24	; 0x06
     770:	02 30       	cpi	r16, 0x02	; 2
     772:	11 f4       	brne	.+4      	; 0x778 <prvCopyDataToQueue+0x82>
     774:	11 11       	cpse	r17, r1
     776:	11 50       	subi	r17, 0x01	; 1
     778:	1f 5f       	subi	r17, 0xFF	; 255
     77a:	1a 8f       	std	Y+26, r17	; 0x1a
     77c:	80 e0       	ldi	r24, 0x00	; 0
     77e:	df 91       	pop	r29
     780:	cf 91       	pop	r28
     782:	1f 91       	pop	r17
     784:	0f 91       	pop	r16
     786:	08 95       	ret

00000788 <prvCopyDataFromQueue>:
     788:	fc 01       	movw	r30, r24
     78a:	44 8d       	ldd	r20, Z+28	; 0x1c
     78c:	44 23       	and	r20, r20
     78e:	a9 f0       	breq	.+42     	; 0x7ba <prvCopyDataFromQueue+0x32>
     790:	50 e0       	ldi	r21, 0x00	; 0
     792:	26 81       	ldd	r18, Z+6	; 0x06
     794:	37 81       	ldd	r19, Z+7	; 0x07
     796:	24 0f       	add	r18, r20
     798:	35 1f       	adc	r19, r21
     79a:	37 83       	std	Z+7, r19	; 0x07
     79c:	26 83       	std	Z+6, r18	; 0x06
     79e:	82 81       	ldd	r24, Z+2	; 0x02
     7a0:	93 81       	ldd	r25, Z+3	; 0x03
     7a2:	28 17       	cp	r18, r24
     7a4:	39 07       	cpc	r19, r25
     7a6:	20 f0       	brcs	.+8      	; 0x7b0 <prvCopyDataFromQueue+0x28>
     7a8:	80 81       	ld	r24, Z
     7aa:	91 81       	ldd	r25, Z+1	; 0x01
     7ac:	97 83       	std	Z+7, r25	; 0x07
     7ae:	86 83       	std	Z+6, r24	; 0x06
     7b0:	cb 01       	movw	r24, r22
     7b2:	66 81       	ldd	r22, Z+6	; 0x06
     7b4:	77 81       	ldd	r23, Z+7	; 0x07
     7b6:	0e 94 c9 09 	call	0x1392	; 0x1392 <memcpy>
     7ba:	08 95       	ret

000007bc <prvUnlockQueue>:
     7bc:	ef 92       	push	r14
     7be:	ff 92       	push	r15
     7c0:	0f 93       	push	r16
     7c2:	1f 93       	push	r17
     7c4:	cf 93       	push	r28
     7c6:	8c 01       	movw	r16, r24
     7c8:	0f b6       	in	r0, 0x3f	; 63
     7ca:	f8 94       	cli
     7cc:	0f 92       	push	r0
     7ce:	fc 01       	movw	r30, r24
     7d0:	c6 8d       	ldd	r28, Z+30	; 0x1e
     7d2:	1c 16       	cp	r1, r28
     7d4:	ac f4       	brge	.+42     	; 0x800 <prvUnlockQueue+0x44>
     7d6:	81 89       	ldd	r24, Z+17	; 0x11
     7d8:	81 11       	cpse	r24, r1
     7da:	06 c0       	rjmp	.+12     	; 0x7e8 <prvUnlockQueue+0x2c>
     7dc:	11 c0       	rjmp	.+34     	; 0x800 <prvUnlockQueue+0x44>
     7de:	f8 01       	movw	r30, r16
     7e0:	81 89       	ldd	r24, Z+17	; 0x11
     7e2:	81 11       	cpse	r24, r1
     7e4:	05 c0       	rjmp	.+10     	; 0x7f0 <prvUnlockQueue+0x34>
     7e6:	0c c0       	rjmp	.+24     	; 0x800 <prvUnlockQueue+0x44>
     7e8:	78 01       	movw	r14, r16
     7ea:	f1 e1       	ldi	r31, 0x11	; 17
     7ec:	ef 0e       	add	r14, r31
     7ee:	f1 1c       	adc	r15, r1
     7f0:	c7 01       	movw	r24, r14
     7f2:	0e 94 40 09 	call	0x1280	; 0x1280 <xTaskRemoveFromEventList>
     7f6:	81 11       	cpse	r24, r1
     7f8:	0e 94 c5 09 	call	0x138a	; 0x138a <vTaskMissedYield>
     7fc:	c1 50       	subi	r28, 0x01	; 1
     7fe:	79 f7       	brne	.-34     	; 0x7de <prvUnlockQueue+0x22>
     800:	8f ef       	ldi	r24, 0xFF	; 255
     802:	f8 01       	movw	r30, r16
     804:	86 8f       	std	Z+30, r24	; 0x1e
     806:	0f 90       	pop	r0
     808:	0f be       	out	0x3f, r0	; 63
     80a:	0f b6       	in	r0, 0x3f	; 63
     80c:	f8 94       	cli
     80e:	0f 92       	push	r0
     810:	c5 8d       	ldd	r28, Z+29	; 0x1d
     812:	1c 16       	cp	r1, r28
     814:	ac f4       	brge	.+42     	; 0x840 <prvUnlockQueue+0x84>
     816:	80 85       	ldd	r24, Z+8	; 0x08
     818:	81 11       	cpse	r24, r1
     81a:	06 c0       	rjmp	.+12     	; 0x828 <prvUnlockQueue+0x6c>
     81c:	11 c0       	rjmp	.+34     	; 0x840 <prvUnlockQueue+0x84>
     81e:	f8 01       	movw	r30, r16
     820:	80 85       	ldd	r24, Z+8	; 0x08
     822:	81 11       	cpse	r24, r1
     824:	05 c0       	rjmp	.+10     	; 0x830 <prvUnlockQueue+0x74>
     826:	0c c0       	rjmp	.+24     	; 0x840 <prvUnlockQueue+0x84>
     828:	78 01       	movw	r14, r16
     82a:	f8 e0       	ldi	r31, 0x08	; 8
     82c:	ef 0e       	add	r14, r31
     82e:	f1 1c       	adc	r15, r1
     830:	c7 01       	movw	r24, r14
     832:	0e 94 40 09 	call	0x1280	; 0x1280 <xTaskRemoveFromEventList>
     836:	81 11       	cpse	r24, r1
     838:	0e 94 c5 09 	call	0x138a	; 0x138a <vTaskMissedYield>
     83c:	c1 50       	subi	r28, 0x01	; 1
     83e:	79 f7       	brne	.-34     	; 0x81e <prvUnlockQueue+0x62>
     840:	8f ef       	ldi	r24, 0xFF	; 255
     842:	f8 01       	movw	r30, r16
     844:	85 8f       	std	Z+29, r24	; 0x1d
     846:	0f 90       	pop	r0
     848:	0f be       	out	0x3f, r0	; 63
     84a:	cf 91       	pop	r28
     84c:	1f 91       	pop	r17
     84e:	0f 91       	pop	r16
     850:	ff 90       	pop	r15
     852:	ef 90       	pop	r14
     854:	08 95       	ret

00000856 <xQueueGenericReset>:
     856:	cf 93       	push	r28
     858:	df 93       	push	r29
     85a:	ec 01       	movw	r28, r24
     85c:	0f b6       	in	r0, 0x3f	; 63
     85e:	f8 94       	cli
     860:	0f 92       	push	r0
     862:	48 81       	ld	r20, Y
     864:	59 81       	ldd	r21, Y+1	; 0x01
     866:	2c 8d       	ldd	r18, Y+28	; 0x1c
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	7b 8d       	ldd	r23, Y+27	; 0x1b
     86c:	72 9f       	mul	r23, r18
     86e:	c0 01       	movw	r24, r0
     870:	73 9f       	mul	r23, r19
     872:	90 0d       	add	r25, r0
     874:	11 24       	eor	r1, r1
     876:	fa 01       	movw	r30, r20
     878:	e8 0f       	add	r30, r24
     87a:	f9 1f       	adc	r31, r25
     87c:	fb 83       	std	Y+3, r31	; 0x03
     87e:	ea 83       	std	Y+2, r30	; 0x02
     880:	1a 8e       	std	Y+26, r1	; 0x1a
     882:	5d 83       	std	Y+5, r21	; 0x05
     884:	4c 83       	std	Y+4, r20	; 0x04
     886:	82 1b       	sub	r24, r18
     888:	93 0b       	sbc	r25, r19
     88a:	84 0f       	add	r24, r20
     88c:	95 1f       	adc	r25, r21
     88e:	9f 83       	std	Y+7, r25	; 0x07
     890:	8e 83       	std	Y+6, r24	; 0x06
     892:	8f ef       	ldi	r24, 0xFF	; 255
     894:	8d 8f       	std	Y+29, r24	; 0x1d
     896:	8e 8f       	std	Y+30, r24	; 0x1e
     898:	61 11       	cpse	r22, r1
     89a:	0c c0       	rjmp	.+24     	; 0x8b4 <__stack+0x55>
     89c:	88 85       	ldd	r24, Y+8	; 0x08
     89e:	88 23       	and	r24, r24
     8a0:	89 f0       	breq	.+34     	; 0x8c4 <__stack+0x65>
     8a2:	ce 01       	movw	r24, r28
     8a4:	08 96       	adiw	r24, 0x08	; 8
     8a6:	0e 94 40 09 	call	0x1280	; 0x1280 <xTaskRemoveFromEventList>
     8aa:	88 23       	and	r24, r24
     8ac:	59 f0       	breq	.+22     	; 0x8c4 <__stack+0x65>
     8ae:	0e 94 c3 02 	call	0x586	; 0x586 <vPortYield>
     8b2:	08 c0       	rjmp	.+16     	; 0x8c4 <__stack+0x65>
     8b4:	ce 01       	movw	r24, r28
     8b6:	08 96       	adiw	r24, 0x08	; 8
     8b8:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     8bc:	ce 01       	movw	r24, r28
     8be:	41 96       	adiw	r24, 0x11	; 17
     8c0:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     8c4:	0f 90       	pop	r0
     8c6:	0f be       	out	0x3f, r0	; 63
     8c8:	81 e0       	ldi	r24, 0x01	; 1
     8ca:	df 91       	pop	r29
     8cc:	cf 91       	pop	r28
     8ce:	08 95       	ret

000008d0 <xQueueGenericCreate>:
     8d0:	0f 93       	push	r16
     8d2:	1f 93       	push	r17
     8d4:	cf 93       	push	r28
     8d6:	df 93       	push	r29
     8d8:	08 2f       	mov	r16, r24
     8da:	16 2f       	mov	r17, r22
     8dc:	66 23       	and	r22, r22
     8de:	c1 f0       	breq	.+48     	; 0x910 <xQueueGenericCreate+0x40>
     8e0:	86 9f       	mul	r24, r22
     8e2:	c0 01       	movw	r24, r0
     8e4:	11 24       	eor	r1, r1
     8e6:	4f 96       	adiw	r24, 0x1f	; 31
     8e8:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     8ec:	ec 01       	movw	r28, r24
     8ee:	00 97       	sbiw	r24, 0x00	; 0
     8f0:	41 f4       	brne	.+16     	; 0x902 <xQueueGenericCreate+0x32>
     8f2:	15 c0       	rjmp	.+42     	; 0x91e <xQueueGenericCreate+0x4e>
     8f4:	0b 8f       	std	Y+27, r16	; 0x1b
     8f6:	1c 8f       	std	Y+28, r17	; 0x1c
     8f8:	61 e0       	ldi	r22, 0x01	; 1
     8fa:	ce 01       	movw	r24, r28
     8fc:	0e 94 2b 04 	call	0x856	; 0x856 <xQueueGenericReset>
     900:	0e c0       	rjmp	.+28     	; 0x91e <xQueueGenericCreate+0x4e>
     902:	4f 96       	adiw	r24, 0x1f	; 31
     904:	99 83       	std	Y+1, r25	; 0x01
     906:	88 83       	st	Y, r24
     908:	f5 cf       	rjmp	.-22     	; 0x8f4 <xQueueGenericCreate+0x24>
     90a:	d9 83       	std	Y+1, r29	; 0x01
     90c:	c8 83       	st	Y, r28
     90e:	f2 cf       	rjmp	.-28     	; 0x8f4 <xQueueGenericCreate+0x24>
     910:	8f e1       	ldi	r24, 0x1F	; 31
     912:	90 e0       	ldi	r25, 0x00	; 0
     914:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     918:	ec 01       	movw	r28, r24
     91a:	89 2b       	or	r24, r25
     91c:	b1 f7       	brne	.-20     	; 0x90a <xQueueGenericCreate+0x3a>
     91e:	ce 01       	movw	r24, r28
     920:	df 91       	pop	r29
     922:	cf 91       	pop	r28
     924:	1f 91       	pop	r17
     926:	0f 91       	pop	r16
     928:	08 95       	ret

0000092a <xQueueGenericSend>:
     92a:	9f 92       	push	r9
     92c:	af 92       	push	r10
     92e:	bf 92       	push	r11
     930:	cf 92       	push	r12
     932:	df 92       	push	r13
     934:	ef 92       	push	r14
     936:	ff 92       	push	r15
     938:	0f 93       	push	r16
     93a:	1f 93       	push	r17
     93c:	cf 93       	push	r28
     93e:	df 93       	push	r29
     940:	00 d0       	rcall	.+0      	; 0x942 <xQueueGenericSend+0x18>
     942:	00 d0       	rcall	.+0      	; 0x944 <xQueueGenericSend+0x1a>
     944:	1f 92       	push	r1
     946:	cd b7       	in	r28, 0x3d	; 61
     948:	de b7       	in	r29, 0x3e	; 62
     94a:	8c 01       	movw	r16, r24
     94c:	6b 01       	movw	r12, r22
     94e:	5d 83       	std	Y+5, r21	; 0x05
     950:	4c 83       	std	Y+4, r20	; 0x04
     952:	a2 2e       	mov	r10, r18
     954:	b1 2c       	mov	r11, r1
     956:	99 24       	eor	r9, r9
     958:	93 94       	inc	r9
     95a:	7c 01       	movw	r14, r24
     95c:	88 e0       	ldi	r24, 0x08	; 8
     95e:	e8 0e       	add	r14, r24
     960:	f1 1c       	adc	r15, r1
     962:	0f b6       	in	r0, 0x3f	; 63
     964:	f8 94       	cli
     966:	0f 92       	push	r0
     968:	f8 01       	movw	r30, r16
     96a:	92 8d       	ldd	r25, Z+26	; 0x1a
     96c:	83 8d       	ldd	r24, Z+27	; 0x1b
     96e:	98 17       	cp	r25, r24
     970:	18 f0       	brcs	.+6      	; 0x978 <xQueueGenericSend+0x4e>
     972:	f2 e0       	ldi	r31, 0x02	; 2
     974:	af 12       	cpse	r10, r31
     976:	19 c0       	rjmp	.+50     	; 0x9aa <xQueueGenericSend+0x80>
     978:	4a 2d       	mov	r20, r10
     97a:	b6 01       	movw	r22, r12
     97c:	c8 01       	movw	r24, r16
     97e:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <prvCopyDataToQueue>
     982:	f8 01       	movw	r30, r16
     984:	91 89       	ldd	r25, Z+17	; 0x11
     986:	99 23       	and	r25, r25
     988:	49 f0       	breq	.+18     	; 0x99c <xQueueGenericSend+0x72>
     98a:	c8 01       	movw	r24, r16
     98c:	41 96       	adiw	r24, 0x11	; 17
     98e:	0e 94 40 09 	call	0x1280	; 0x1280 <xTaskRemoveFromEventList>
     992:	88 23       	and	r24, r24
     994:	31 f0       	breq	.+12     	; 0x9a2 <xQueueGenericSend+0x78>
     996:	0e 94 c3 02 	call	0x586	; 0x586 <vPortYield>
     99a:	03 c0       	rjmp	.+6      	; 0x9a2 <xQueueGenericSend+0x78>
     99c:	81 11       	cpse	r24, r1
     99e:	0e 94 c3 02 	call	0x586	; 0x586 <vPortYield>
     9a2:	0f 90       	pop	r0
     9a4:	0f be       	out	0x3f, r0	; 63
     9a6:	81 e0       	ldi	r24, 0x01	; 1
     9a8:	50 c0       	rjmp	.+160    	; 0xa4a <xQueueGenericSend+0x120>
     9aa:	8c 81       	ldd	r24, Y+4	; 0x04
     9ac:	9d 81       	ldd	r25, Y+5	; 0x05
     9ae:	89 2b       	or	r24, r25
     9b0:	21 f4       	brne	.+8      	; 0x9ba <xQueueGenericSend+0x90>
     9b2:	0f 90       	pop	r0
     9b4:	0f be       	out	0x3f, r0	; 63
     9b6:	80 e0       	ldi	r24, 0x00	; 0
     9b8:	48 c0       	rjmp	.+144    	; 0xa4a <xQueueGenericSend+0x120>
     9ba:	b1 10       	cpse	r11, r1
     9bc:	05 c0       	rjmp	.+10     	; 0x9c8 <xQueueGenericSend+0x9e>
     9be:	ce 01       	movw	r24, r28
     9c0:	01 96       	adiw	r24, 0x01	; 1
     9c2:	0e 94 88 09 	call	0x1310	; 0x1310 <vTaskSetTimeOutState>
     9c6:	b9 2c       	mov	r11, r9
     9c8:	0f 90       	pop	r0
     9ca:	0f be       	out	0x3f, r0	; 63
     9cc:	0e 94 74 07 	call	0xee8	; 0xee8 <vTaskSuspendAll>
     9d0:	0f b6       	in	r0, 0x3f	; 63
     9d2:	f8 94       	cli
     9d4:	0f 92       	push	r0
     9d6:	f8 01       	movw	r30, r16
     9d8:	85 8d       	ldd	r24, Z+29	; 0x1d
     9da:	8f 3f       	cpi	r24, 0xFF	; 255
     9dc:	09 f4       	brne	.+2      	; 0x9e0 <xQueueGenericSend+0xb6>
     9de:	15 8e       	std	Z+29, r1	; 0x1d
     9e0:	f8 01       	movw	r30, r16
     9e2:	86 8d       	ldd	r24, Z+30	; 0x1e
     9e4:	8f 3f       	cpi	r24, 0xFF	; 255
     9e6:	09 f4       	brne	.+2      	; 0x9ea <xQueueGenericSend+0xc0>
     9e8:	16 8e       	std	Z+30, r1	; 0x1e
     9ea:	0f 90       	pop	r0
     9ec:	0f be       	out	0x3f, r0	; 63
     9ee:	be 01       	movw	r22, r28
     9f0:	6c 5f       	subi	r22, 0xFC	; 252
     9f2:	7f 4f       	sbci	r23, 0xFF	; 255
     9f4:	ce 01       	movw	r24, r28
     9f6:	01 96       	adiw	r24, 0x01	; 1
     9f8:	0e 94 93 09 	call	0x1326	; 0x1326 <xTaskCheckForTimeOut>
     9fc:	81 11       	cpse	r24, r1
     9fe:	1f c0       	rjmp	.+62     	; 0xa3e <xQueueGenericSend+0x114>
     a00:	0f b6       	in	r0, 0x3f	; 63
     a02:	f8 94       	cli
     a04:	0f 92       	push	r0
     a06:	f8 01       	movw	r30, r16
     a08:	92 8d       	ldd	r25, Z+26	; 0x1a
     a0a:	0f 90       	pop	r0
     a0c:	0f be       	out	0x3f, r0	; 63
     a0e:	83 8d       	ldd	r24, Z+27	; 0x1b
     a10:	98 13       	cpse	r25, r24
     a12:	0f c0       	rjmp	.+30     	; 0xa32 <xQueueGenericSend+0x108>
     a14:	6c 81       	ldd	r22, Y+4	; 0x04
     a16:	7d 81       	ldd	r23, Y+5	; 0x05
     a18:	c7 01       	movw	r24, r14
     a1a:	0e 94 2e 09 	call	0x125c	; 0x125c <vTaskPlaceOnEventList>
     a1e:	c8 01       	movw	r24, r16
     a20:	0e 94 de 03 	call	0x7bc	; 0x7bc <prvUnlockQueue>
     a24:	0e 94 35 08 	call	0x106a	; 0x106a <xTaskResumeAll>
     a28:	81 11       	cpse	r24, r1
     a2a:	9b cf       	rjmp	.-202    	; 0x962 <xQueueGenericSend+0x38>
     a2c:	0e 94 c3 02 	call	0x586	; 0x586 <vPortYield>
     a30:	98 cf       	rjmp	.-208    	; 0x962 <xQueueGenericSend+0x38>
     a32:	c8 01       	movw	r24, r16
     a34:	0e 94 de 03 	call	0x7bc	; 0x7bc <prvUnlockQueue>
     a38:	0e 94 35 08 	call	0x106a	; 0x106a <xTaskResumeAll>
     a3c:	92 cf       	rjmp	.-220    	; 0x962 <xQueueGenericSend+0x38>
     a3e:	c8 01       	movw	r24, r16
     a40:	0e 94 de 03 	call	0x7bc	; 0x7bc <prvUnlockQueue>
     a44:	0e 94 35 08 	call	0x106a	; 0x106a <xTaskResumeAll>
     a48:	80 e0       	ldi	r24, 0x00	; 0
     a4a:	0f 90       	pop	r0
     a4c:	0f 90       	pop	r0
     a4e:	0f 90       	pop	r0
     a50:	0f 90       	pop	r0
     a52:	0f 90       	pop	r0
     a54:	df 91       	pop	r29
     a56:	cf 91       	pop	r28
     a58:	1f 91       	pop	r17
     a5a:	0f 91       	pop	r16
     a5c:	ff 90       	pop	r15
     a5e:	ef 90       	pop	r14
     a60:	df 90       	pop	r13
     a62:	cf 90       	pop	r12
     a64:	bf 90       	pop	r11
     a66:	af 90       	pop	r10
     a68:	9f 90       	pop	r9
     a6a:	08 95       	ret

00000a6c <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     a6c:	8f 92       	push	r8
     a6e:	9f 92       	push	r9
     a70:	af 92       	push	r10
     a72:	bf 92       	push	r11
     a74:	cf 92       	push	r12
     a76:	df 92       	push	r13
     a78:	ef 92       	push	r14
     a7a:	ff 92       	push	r15
     a7c:	0f 93       	push	r16
     a7e:	1f 93       	push	r17
     a80:	cf 93       	push	r28
     a82:	df 93       	push	r29
     a84:	00 d0       	rcall	.+0      	; 0xa86 <xQueueGenericReceive+0x1a>
     a86:	00 d0       	rcall	.+0      	; 0xa88 <xQueueGenericReceive+0x1c>
     a88:	1f 92       	push	r1
     a8a:	cd b7       	in	r28, 0x3d	; 61
     a8c:	de b7       	in	r29, 0x3e	; 62
     a8e:	8c 01       	movw	r16, r24
     a90:	5b 01       	movw	r10, r22
     a92:	5d 83       	std	Y+5, r21	; 0x05
     a94:	4c 83       	std	Y+4, r20	; 0x04
     a96:	82 2e       	mov	r8, r18
BaseType_t xEntryTimeSet = pdFALSE;
     a98:	e1 2c       	mov	r14, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     a9a:	99 24       	eor	r9, r9
     a9c:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     a9e:	6c 01       	movw	r12, r24
     aa0:	81 e1       	ldi	r24, 0x11	; 17
     aa2:	c8 0e       	add	r12, r24
     aa4:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     aa6:	0f b6       	in	r0, 0x3f	; 63
     aa8:	f8 94       	cli
     aaa:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     aac:	f8 01       	movw	r30, r16
     aae:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     ab0:	ff 20       	and	r15, r15
     ab2:	41 f1       	breq	.+80     	; 0xb04 <xQueueGenericReceive+0x98>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     ab4:	c6 80       	ldd	r12, Z+6	; 0x06
     ab6:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     ab8:	b5 01       	movw	r22, r10
     aba:	c8 01       	movw	r24, r16
     abc:	0e 94 c4 03 	call	0x788	; 0x788 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     ac0:	81 10       	cpse	r8, r1
     ac2:	0f c0       	rjmp	.+30     	; 0xae2 <xQueueGenericReceive+0x76>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
     ac4:	fa 94       	dec	r15
     ac6:	f8 01       	movw	r30, r16
     ac8:	f2 8e       	std	Z+26, r15	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     aca:	80 85       	ldd	r24, Z+8	; 0x08
     acc:	88 23       	and	r24, r24
     ace:	b1 f0       	breq	.+44     	; 0xafc <xQueueGenericReceive+0x90>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     ad0:	c8 01       	movw	r24, r16
     ad2:	08 96       	adiw	r24, 0x08	; 8
     ad4:	0e 94 40 09 	call	0x1280	; 0x1280 <xTaskRemoveFromEventList>
     ad8:	88 23       	and	r24, r24
     ada:	81 f0       	breq	.+32     	; 0xafc <xQueueGenericReceive+0x90>
						{
							queueYIELD_IF_USING_PREEMPTION();
     adc:	0e 94 c3 02 	call	0x586	; 0x586 <vPortYield>
     ae0:	0d c0       	rjmp	.+26     	; 0xafc <xQueueGenericReceive+0x90>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     ae2:	f8 01       	movw	r30, r16
     ae4:	d7 82       	std	Z+7, r13	; 0x07
     ae6:	c6 82       	std	Z+6, r12	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     ae8:	81 89       	ldd	r24, Z+17	; 0x11
     aea:	88 23       	and	r24, r24
     aec:	39 f0       	breq	.+14     	; 0xafc <xQueueGenericReceive+0x90>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     aee:	c8 01       	movw	r24, r16
     af0:	41 96       	adiw	r24, 0x11	; 17
     af2:	0e 94 40 09 	call	0x1280	; 0x1280 <xTaskRemoveFromEventList>
     af6:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     af8:	0e 94 c3 02 	call	0x586	; 0x586 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     afc:	0f 90       	pop	r0
     afe:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     b00:	81 e0       	ldi	r24, 0x01	; 1
     b02:	57 c0       	rjmp	.+174    	; 0xbb2 <xQueueGenericReceive+0x146>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     b04:	8c 81       	ldd	r24, Y+4	; 0x04
     b06:	9d 81       	ldd	r25, Y+5	; 0x05
     b08:	89 2b       	or	r24, r25
     b0a:	21 f4       	brne	.+8      	; 0xb14 <xQueueGenericReceive+0xa8>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     b0c:	0f 90       	pop	r0
     b0e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     b10:	80 e0       	ldi	r24, 0x00	; 0
     b12:	4f c0       	rjmp	.+158    	; 0xbb2 <xQueueGenericReceive+0x146>
				}
				else if( xEntryTimeSet == pdFALSE )
     b14:	e1 10       	cpse	r14, r1
     b16:	05 c0       	rjmp	.+10     	; 0xb22 <xQueueGenericReceive+0xb6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     b18:	ce 01       	movw	r24, r28
     b1a:	01 96       	adiw	r24, 0x01	; 1
     b1c:	0e 94 88 09 	call	0x1310	; 0x1310 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     b20:	e9 2c       	mov	r14, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     b22:	0f 90       	pop	r0
     b24:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     b26:	0e 94 74 07 	call	0xee8	; 0xee8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     b2a:	0f b6       	in	r0, 0x3f	; 63
     b2c:	f8 94       	cli
     b2e:	0f 92       	push	r0
     b30:	f8 01       	movw	r30, r16
     b32:	85 8d       	ldd	r24, Z+29	; 0x1d
     b34:	8f 3f       	cpi	r24, 0xFF	; 255
     b36:	09 f4       	brne	.+2      	; 0xb3a <xQueueGenericReceive+0xce>
     b38:	15 8e       	std	Z+29, r1	; 0x1d
     b3a:	f8 01       	movw	r30, r16
     b3c:	86 8d       	ldd	r24, Z+30	; 0x1e
     b3e:	8f 3f       	cpi	r24, 0xFF	; 255
     b40:	09 f4       	brne	.+2      	; 0xb44 <xQueueGenericReceive+0xd8>
     b42:	16 8e       	std	Z+30, r1	; 0x1e
     b44:	0f 90       	pop	r0
     b46:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     b48:	be 01       	movw	r22, r28
     b4a:	6c 5f       	subi	r22, 0xFC	; 252
     b4c:	7f 4f       	sbci	r23, 0xFF	; 255
     b4e:	ce 01       	movw	r24, r28
     b50:	01 96       	adiw	r24, 0x01	; 1
     b52:	0e 94 93 09 	call	0x1326	; 0x1326 <xTaskCheckForTimeOut>
     b56:	81 11       	cpse	r24, r1
     b58:	1e c0       	rjmp	.+60     	; 0xb96 <xQueueGenericReceive+0x12a>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     b5a:	0f b6       	in	r0, 0x3f	; 63
     b5c:	f8 94       	cli
     b5e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     b60:	f8 01       	movw	r30, r16
     b62:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     b64:	0f 90       	pop	r0
     b66:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     b68:	81 11       	cpse	r24, r1
     b6a:	0f c0       	rjmp	.+30     	; 0xb8a <xQueueGenericReceive+0x11e>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     b6c:	6c 81       	ldd	r22, Y+4	; 0x04
     b6e:	7d 81       	ldd	r23, Y+5	; 0x05
     b70:	c6 01       	movw	r24, r12
     b72:	0e 94 2e 09 	call	0x125c	; 0x125c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     b76:	c8 01       	movw	r24, r16
     b78:	0e 94 de 03 	call	0x7bc	; 0x7bc <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     b7c:	0e 94 35 08 	call	0x106a	; 0x106a <xTaskResumeAll>
     b80:	81 11       	cpse	r24, r1
     b82:	91 cf       	rjmp	.-222    	; 0xaa6 <xQueueGenericReceive+0x3a>
				{
					portYIELD_WITHIN_API();
     b84:	0e 94 c3 02 	call	0x586	; 0x586 <vPortYield>
     b88:	8e cf       	rjmp	.-228    	; 0xaa6 <xQueueGenericReceive+0x3a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     b8a:	c8 01       	movw	r24, r16
     b8c:	0e 94 de 03 	call	0x7bc	; 0x7bc <prvUnlockQueue>
				( void ) xTaskResumeAll();
     b90:	0e 94 35 08 	call	0x106a	; 0x106a <xTaskResumeAll>
     b94:	88 cf       	rjmp	.-240    	; 0xaa6 <xQueueGenericReceive+0x3a>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     b96:	c8 01       	movw	r24, r16
     b98:	0e 94 de 03 	call	0x7bc	; 0x7bc <prvUnlockQueue>
			( void ) xTaskResumeAll();
     b9c:	0e 94 35 08 	call	0x106a	; 0x106a <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     ba0:	0f b6       	in	r0, 0x3f	; 63
     ba2:	f8 94       	cli
     ba4:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     ba6:	f8 01       	movw	r30, r16
     ba8:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     baa:	0f 90       	pop	r0
     bac:	0f be       	out	0x3f, r0	; 63
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     bae:	81 11       	cpse	r24, r1
     bb0:	7a cf       	rjmp	.-268    	; 0xaa6 <xQueueGenericReceive+0x3a>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
     bb2:	0f 90       	pop	r0
     bb4:	0f 90       	pop	r0
     bb6:	0f 90       	pop	r0
     bb8:	0f 90       	pop	r0
     bba:	0f 90       	pop	r0
     bbc:	df 91       	pop	r29
     bbe:	cf 91       	pop	r28
     bc0:	1f 91       	pop	r17
     bc2:	0f 91       	pop	r16
     bc4:	ff 90       	pop	r15
     bc6:	ef 90       	pop	r14
     bc8:	df 90       	pop	r13
     bca:	cf 90       	pop	r12
     bcc:	bf 90       	pop	r11
     bce:	af 90       	pop	r10
     bd0:	9f 90       	pop	r9
     bd2:	8f 90       	pop	r8
     bd4:	08 95       	ret

00000bd6 <prvIdleTask>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     bd6:	ff cf       	rjmp	.-2      	; 0xbd6 <prvIdleTask>

00000bd8 <prvResetNextTaskUnblockTime>:
     bd8:	e0 91 e2 02 	lds	r30, 0x02E2	; 0x8002e2 <pxDelayedTaskList>
     bdc:	f0 91 e3 02 	lds	r31, 0x02E3	; 0x8002e3 <pxDelayedTaskList+0x1>
     be0:	80 81       	ld	r24, Z
     be2:	81 11       	cpse	r24, r1
     be4:	07 c0       	rjmp	.+14     	; 0xbf4 <prvResetNextTaskUnblockTime+0x1c>
     be6:	8f ef       	ldi	r24, 0xFF	; 255
     be8:	9f ef       	ldi	r25, 0xFF	; 255
     bea:	90 93 cd 02 	sts	0x02CD, r25	; 0x8002cd <xNextTaskUnblockTime+0x1>
     bee:	80 93 cc 02 	sts	0x02CC, r24	; 0x8002cc <xNextTaskUnblockTime>
     bf2:	08 95       	ret
     bf4:	e0 91 e2 02 	lds	r30, 0x02E2	; 0x8002e2 <pxDelayedTaskList>
     bf8:	f0 91 e3 02 	lds	r31, 0x02E3	; 0x8002e3 <pxDelayedTaskList+0x1>
     bfc:	05 80       	ldd	r0, Z+5	; 0x05
     bfe:	f6 81       	ldd	r31, Z+6	; 0x06
     c00:	e0 2d       	mov	r30, r0
     c02:	06 80       	ldd	r0, Z+6	; 0x06
     c04:	f7 81       	ldd	r31, Z+7	; 0x07
     c06:	e0 2d       	mov	r30, r0
     c08:	82 81       	ldd	r24, Z+2	; 0x02
     c0a:	93 81       	ldd	r25, Z+3	; 0x03
     c0c:	90 93 cd 02 	sts	0x02CD, r25	; 0x8002cd <xNextTaskUnblockTime+0x1>
     c10:	80 93 cc 02 	sts	0x02CC, r24	; 0x8002cc <xNextTaskUnblockTime>
     c14:	08 95       	ret

00000c16 <prvAddCurrentTaskToDelayedList>:
     c16:	0f 93       	push	r16
     c18:	1f 93       	push	r17
     c1a:	cf 93       	push	r28
     c1c:	df 93       	push	r29
     c1e:	ec 01       	movw	r28, r24
     c20:	00 91 d4 02 	lds	r16, 0x02D4	; 0x8002d4 <xTickCount>
     c24:	10 91 d5 02 	lds	r17, 0x02D5	; 0x8002d5 <xTickCount+0x1>
     c28:	80 91 08 03 	lds	r24, 0x0308	; 0x800308 <pxCurrentTCB>
     c2c:	90 91 09 03 	lds	r25, 0x0309	; 0x800309 <pxCurrentTCB+0x1>
     c30:	02 96       	adiw	r24, 0x02	; 2
     c32:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
     c36:	c0 0f       	add	r28, r16
     c38:	d1 1f       	adc	r29, r17
     c3a:	e0 91 08 03 	lds	r30, 0x0308	; 0x800308 <pxCurrentTCB>
     c3e:	f0 91 09 03 	lds	r31, 0x0309	; 0x800309 <pxCurrentTCB+0x1>
     c42:	d3 83       	std	Z+3, r29	; 0x03
     c44:	c2 83       	std	Z+2, r28	; 0x02
     c46:	c0 17       	cp	r28, r16
     c48:	d1 07       	cpc	r29, r17
     c4a:	68 f4       	brcc	.+26     	; 0xc66 <prvAddCurrentTaskToDelayedList+0x50>
     c4c:	60 91 08 03 	lds	r22, 0x0308	; 0x800308 <pxCurrentTCB>
     c50:	70 91 09 03 	lds	r23, 0x0309	; 0x800309 <pxCurrentTCB+0x1>
     c54:	80 91 e0 02 	lds	r24, 0x02E0	; 0x8002e0 <pxOverflowDelayedTaskList>
     c58:	90 91 e1 02 	lds	r25, 0x02E1	; 0x8002e1 <pxOverflowDelayedTaskList+0x1>
     c5c:	6e 5f       	subi	r22, 0xFE	; 254
     c5e:	7f 4f       	sbci	r23, 0xFF	; 255
     c60:	0e 94 49 01 	call	0x292	; 0x292 <vListInsert>
     c64:	17 c0       	rjmp	.+46     	; 0xc94 <prvAddCurrentTaskToDelayedList+0x7e>
     c66:	60 91 08 03 	lds	r22, 0x0308	; 0x800308 <pxCurrentTCB>
     c6a:	70 91 09 03 	lds	r23, 0x0309	; 0x800309 <pxCurrentTCB+0x1>
     c6e:	80 91 e2 02 	lds	r24, 0x02E2	; 0x8002e2 <pxDelayedTaskList>
     c72:	90 91 e3 02 	lds	r25, 0x02E3	; 0x8002e3 <pxDelayedTaskList+0x1>
     c76:	6e 5f       	subi	r22, 0xFE	; 254
     c78:	7f 4f       	sbci	r23, 0xFF	; 255
     c7a:	0e 94 49 01 	call	0x292	; 0x292 <vListInsert>
     c7e:	80 91 cc 02 	lds	r24, 0x02CC	; 0x8002cc <xNextTaskUnblockTime>
     c82:	90 91 cd 02 	lds	r25, 0x02CD	; 0x8002cd <xNextTaskUnblockTime+0x1>
     c86:	c8 17       	cp	r28, r24
     c88:	d9 07       	cpc	r29, r25
     c8a:	20 f4       	brcc	.+8      	; 0xc94 <prvAddCurrentTaskToDelayedList+0x7e>
     c8c:	d0 93 cd 02 	sts	0x02CD, r29	; 0x8002cd <xNextTaskUnblockTime+0x1>
     c90:	c0 93 cc 02 	sts	0x02CC, r28	; 0x8002cc <xNextTaskUnblockTime>
     c94:	df 91       	pop	r29
     c96:	cf 91       	pop	r28
     c98:	1f 91       	pop	r17
     c9a:	0f 91       	pop	r16
     c9c:	08 95       	ret

00000c9e <xTaskCreate>:
     c9e:	4f 92       	push	r4
     ca0:	5f 92       	push	r5
     ca2:	6f 92       	push	r6
     ca4:	7f 92       	push	r7
     ca6:	8f 92       	push	r8
     ca8:	9f 92       	push	r9
     caa:	af 92       	push	r10
     cac:	bf 92       	push	r11
     cae:	cf 92       	push	r12
     cb0:	df 92       	push	r13
     cb2:	ef 92       	push	r14
     cb4:	ff 92       	push	r15
     cb6:	0f 93       	push	r16
     cb8:	cf 93       	push	r28
     cba:	df 93       	push	r29
     cbc:	4c 01       	movw	r8, r24
     cbe:	6b 01       	movw	r12, r22
     cc0:	5a 01       	movw	r10, r20
     cc2:	29 01       	movw	r4, r18
     cc4:	ca 01       	movw	r24, r20
     cc6:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     cca:	3c 01       	movw	r6, r24
     ccc:	89 2b       	or	r24, r25
     cce:	09 f4       	brne	.+2      	; 0xcd2 <xTaskCreate+0x34>
     cd0:	d0 c0       	rjmp	.+416    	; 0xe72 <xTaskCreate+0x1d4>
     cd2:	86 e2       	ldi	r24, 0x26	; 38
     cd4:	90 e0       	ldi	r25, 0x00	; 0
     cd6:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     cda:	ec 01       	movw	r28, r24
     cdc:	89 2b       	or	r24, r25
     cde:	71 f0       	breq	.+28     	; 0xcfc <xTaskCreate+0x5e>
     ce0:	78 8e       	std	Y+24, r7	; 0x18
     ce2:	6f 8a       	std	Y+23, r6	; 0x17
     ce4:	81 e0       	ldi	r24, 0x01	; 1
     ce6:	a8 1a       	sub	r10, r24
     ce8:	b1 08       	sbc	r11, r1
     cea:	a6 0c       	add	r10, r6
     cec:	b7 1c       	adc	r11, r7
     cee:	d6 01       	movw	r26, r12
     cf0:	8c 91       	ld	r24, X
     cf2:	89 8f       	std	Y+25, r24	; 0x19
     cf4:	8c 91       	ld	r24, X
     cf6:	81 11       	cpse	r24, r1
     cf8:	05 c0       	rjmp	.+10     	; 0xd04 <xTaskCreate+0x66>
     cfa:	18 c0       	rjmp	.+48     	; 0xd2c <xTaskCreate+0x8e>
     cfc:	c3 01       	movw	r24, r6
     cfe:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <vPortFree>
     d02:	b7 c0       	rjmp	.+366    	; 0xe72 <xTaskCreate+0x1d4>
     d04:	ae 01       	movw	r20, r28
     d06:	46 5e       	subi	r20, 0xE6	; 230
     d08:	5f 4f       	sbci	r21, 0xFF	; 255
     d0a:	f6 01       	movw	r30, r12
     d0c:	31 96       	adiw	r30, 0x01	; 1
     d0e:	b8 e0       	ldi	r27, 0x08	; 8
     d10:	cb 0e       	add	r12, r27
     d12:	d1 1c       	adc	r13, r1
     d14:	cf 01       	movw	r24, r30
     d16:	21 91       	ld	r18, Z+
     d18:	da 01       	movw	r26, r20
     d1a:	2d 93       	st	X+, r18
     d1c:	ad 01       	movw	r20, r26
     d1e:	dc 01       	movw	r26, r24
     d20:	8c 91       	ld	r24, X
     d22:	88 23       	and	r24, r24
     d24:	19 f0       	breq	.+6      	; 0xd2c <xTaskCreate+0x8e>
     d26:	ec 15       	cp	r30, r12
     d28:	fd 05       	cpc	r31, r13
     d2a:	a1 f7       	brne	.-24     	; 0xd14 <xTaskCreate+0x76>
     d2c:	18 a2       	std	Y+32, r1	; 0x20
     d2e:	01 11       	cpse	r16, r1
     d30:	01 e0       	ldi	r16, 0x01	; 1
     d32:	0e 8b       	std	Y+22, r16	; 0x16
     d34:	6e 01       	movw	r12, r28
     d36:	b2 e0       	ldi	r27, 0x02	; 2
     d38:	cb 0e       	add	r12, r27
     d3a:	d1 1c       	adc	r13, r1
     d3c:	c6 01       	movw	r24, r12
     d3e:	0e 94 24 01 	call	0x248	; 0x248 <vListInitialiseItem>
     d42:	ce 01       	movw	r24, r28
     d44:	0c 96       	adiw	r24, 0x0c	; 12
     d46:	0e 94 24 01 	call	0x248	; 0x248 <vListInitialiseItem>
     d4a:	d9 87       	std	Y+9, r29	; 0x09
     d4c:	c8 87       	std	Y+8, r28	; 0x08
     d4e:	82 e0       	ldi	r24, 0x02	; 2
     d50:	90 e0       	ldi	r25, 0x00	; 0
     d52:	80 1b       	sub	r24, r16
     d54:	91 09       	sbc	r25, r1
     d56:	9d 87       	std	Y+13, r25	; 0x0d
     d58:	8c 87       	std	Y+12, r24	; 0x0c
     d5a:	db 8b       	std	Y+19, r29	; 0x13
     d5c:	ca 8b       	std	Y+18, r28	; 0x12
     d5e:	19 a2       	std	Y+33, r1	; 0x21
     d60:	1a a2       	std	Y+34, r1	; 0x22
     d62:	1b a2       	std	Y+35, r1	; 0x23
     d64:	1c a2       	std	Y+36, r1	; 0x24
     d66:	1d a2       	std	Y+37, r1	; 0x25
     d68:	a2 01       	movw	r20, r4
     d6a:	b4 01       	movw	r22, r8
     d6c:	c5 01       	movw	r24, r10
     d6e:	0e 94 22 02 	call	0x444	; 0x444 <pxPortInitialiseStack>
     d72:	99 83       	std	Y+1, r25	; 0x01
     d74:	88 83       	st	Y, r24
     d76:	e1 14       	cp	r14, r1
     d78:	f1 04       	cpc	r15, r1
     d7a:	19 f0       	breq	.+6      	; 0xd82 <xTaskCreate+0xe4>
     d7c:	f7 01       	movw	r30, r14
     d7e:	d1 83       	std	Z+1, r29	; 0x01
     d80:	c0 83       	st	Z, r28
     d82:	0f b6       	in	r0, 0x3f	; 63
     d84:	f8 94       	cli
     d86:	0f 92       	push	r0
     d88:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <uxCurrentNumberOfTasks>
     d8c:	8f 5f       	subi	r24, 0xFF	; 255
     d8e:	80 93 d6 02 	sts	0x02D6, r24	; 0x8002d6 <uxCurrentNumberOfTasks>
     d92:	80 91 08 03 	lds	r24, 0x0308	; 0x800308 <pxCurrentTCB>
     d96:	90 91 09 03 	lds	r25, 0x0309	; 0x800309 <pxCurrentTCB+0x1>
     d9a:	89 2b       	or	r24, r25
     d9c:	49 f5       	brne	.+82     	; 0xdf0 <xTaskCreate+0x152>
     d9e:	d0 93 09 03 	sts	0x0309, r29	; 0x800309 <pxCurrentTCB+0x1>
     da2:	c0 93 08 03 	sts	0x0308, r28	; 0x800308 <pxCurrentTCB>
     da6:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <uxCurrentNumberOfTasks>
     daa:	81 30       	cpi	r24, 0x01	; 1
     dac:	89 f5       	brne	.+98     	; 0xe10 <xTaskCreate+0x172>
     dae:	86 ef       	ldi	r24, 0xF6	; 246
     db0:	92 e0       	ldi	r25, 0x02	; 2
     db2:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     db6:	8f ef       	ldi	r24, 0xFF	; 255
     db8:	92 e0       	ldi	r25, 0x02	; 2
     dba:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     dbe:	8d ee       	ldi	r24, 0xED	; 237
     dc0:	92 e0       	ldi	r25, 0x02	; 2
     dc2:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     dc6:	84 ee       	ldi	r24, 0xE4	; 228
     dc8:	92 e0       	ldi	r25, 0x02	; 2
     dca:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     dce:	87 ed       	ldi	r24, 0xD7	; 215
     dd0:	92 e0       	ldi	r25, 0x02	; 2
     dd2:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     dd6:	8d ee       	ldi	r24, 0xED	; 237
     dd8:	92 e0       	ldi	r25, 0x02	; 2
     dda:	90 93 e3 02 	sts	0x02E3, r25	; 0x8002e3 <pxDelayedTaskList+0x1>
     dde:	80 93 e2 02 	sts	0x02E2, r24	; 0x8002e2 <pxDelayedTaskList>
     de2:	84 ee       	ldi	r24, 0xE4	; 228
     de4:	92 e0       	ldi	r25, 0x02	; 2
     de6:	90 93 e1 02 	sts	0x02E1, r25	; 0x8002e1 <pxOverflowDelayedTaskList+0x1>
     dea:	80 93 e0 02 	sts	0x02E0, r24	; 0x8002e0 <pxOverflowDelayedTaskList>
     dee:	10 c0       	rjmp	.+32     	; 0xe10 <xTaskCreate+0x172>
     df0:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <xSchedulerRunning>
     df4:	81 11       	cpse	r24, r1
     df6:	0c c0       	rjmp	.+24     	; 0xe10 <xTaskCreate+0x172>
     df8:	e0 91 08 03 	lds	r30, 0x0308	; 0x800308 <pxCurrentTCB>
     dfc:	f0 91 09 03 	lds	r31, 0x0309	; 0x800309 <pxCurrentTCB+0x1>
     e00:	96 89       	ldd	r25, Z+22	; 0x16
     e02:	8e 89       	ldd	r24, Y+22	; 0x16
     e04:	89 17       	cp	r24, r25
     e06:	20 f0       	brcs	.+8      	; 0xe10 <xTaskCreate+0x172>
     e08:	d0 93 09 03 	sts	0x0309, r29	; 0x800309 <pxCurrentTCB+0x1>
     e0c:	c0 93 08 03 	sts	0x0308, r28	; 0x800308 <pxCurrentTCB>
     e10:	80 91 ce 02 	lds	r24, 0x02CE	; 0x8002ce <uxTaskNumber>
     e14:	8f 5f       	subi	r24, 0xFF	; 255
     e16:	80 93 ce 02 	sts	0x02CE, r24	; 0x8002ce <uxTaskNumber>
     e1a:	8e 89       	ldd	r24, Y+22	; 0x16
     e1c:	90 91 d3 02 	lds	r25, 0x02D3	; 0x8002d3 <uxTopReadyPriority>
     e20:	98 17       	cp	r25, r24
     e22:	10 f4       	brcc	.+4      	; 0xe28 <xTaskCreate+0x18a>
     e24:	80 93 d3 02 	sts	0x02D3, r24	; 0x8002d3 <uxTopReadyPriority>
     e28:	90 e0       	ldi	r25, 0x00	; 0
     e2a:	9c 01       	movw	r18, r24
     e2c:	22 0f       	add	r18, r18
     e2e:	33 1f       	adc	r19, r19
     e30:	22 0f       	add	r18, r18
     e32:	33 1f       	adc	r19, r19
     e34:	22 0f       	add	r18, r18
     e36:	33 1f       	adc	r19, r19
     e38:	82 0f       	add	r24, r18
     e3a:	93 1f       	adc	r25, r19
     e3c:	b6 01       	movw	r22, r12
     e3e:	8a 50       	subi	r24, 0x0A	; 10
     e40:	9d 4f       	sbci	r25, 0xFD	; 253
     e42:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
     e46:	0f 90       	pop	r0
     e48:	0f be       	out	0x3f, r0	; 63
     e4a:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <xSchedulerRunning>
     e4e:	88 23       	and	r24, r24
     e50:	61 f0       	breq	.+24     	; 0xe6a <xTaskCreate+0x1cc>
     e52:	e0 91 08 03 	lds	r30, 0x0308	; 0x800308 <pxCurrentTCB>
     e56:	f0 91 09 03 	lds	r31, 0x0309	; 0x800309 <pxCurrentTCB+0x1>
     e5a:	96 89       	ldd	r25, Z+22	; 0x16
     e5c:	8e 89       	ldd	r24, Y+22	; 0x16
     e5e:	98 17       	cp	r25, r24
     e60:	30 f4       	brcc	.+12     	; 0xe6e <xTaskCreate+0x1d0>
     e62:	0e 94 c3 02 	call	0x586	; 0x586 <vPortYield>
     e66:	81 e0       	ldi	r24, 0x01	; 1
     e68:	05 c0       	rjmp	.+10     	; 0xe74 <xTaskCreate+0x1d6>
     e6a:	81 e0       	ldi	r24, 0x01	; 1
     e6c:	03 c0       	rjmp	.+6      	; 0xe74 <xTaskCreate+0x1d6>
     e6e:	81 e0       	ldi	r24, 0x01	; 1
     e70:	01 c0       	rjmp	.+2      	; 0xe74 <xTaskCreate+0x1d6>
     e72:	8f ef       	ldi	r24, 0xFF	; 255
     e74:	df 91       	pop	r29
     e76:	cf 91       	pop	r28
     e78:	0f 91       	pop	r16
     e7a:	ff 90       	pop	r15
     e7c:	ef 90       	pop	r14
     e7e:	df 90       	pop	r13
     e80:	cf 90       	pop	r12
     e82:	bf 90       	pop	r11
     e84:	af 90       	pop	r10
     e86:	9f 90       	pop	r9
     e88:	8f 90       	pop	r8
     e8a:	7f 90       	pop	r7
     e8c:	6f 90       	pop	r6
     e8e:	5f 90       	pop	r5
     e90:	4f 90       	pop	r4
     e92:	08 95       	ret

00000e94 <vTaskStartScheduler>:
     e94:	ef 92       	push	r14
     e96:	ff 92       	push	r15
     e98:	0f 93       	push	r16
     e9a:	0f 2e       	mov	r0, r31
     e9c:	fa ec       	ldi	r31, 0xCA	; 202
     e9e:	ef 2e       	mov	r14, r31
     ea0:	f2 e0       	ldi	r31, 0x02	; 2
     ea2:	ff 2e       	mov	r15, r31
     ea4:	f0 2d       	mov	r31, r0
     ea6:	00 e0       	ldi	r16, 0x00	; 0
     ea8:	20 e0       	ldi	r18, 0x00	; 0
     eaa:	30 e0       	ldi	r19, 0x00	; 0
     eac:	44 e6       	ldi	r20, 0x64	; 100
     eae:	50 e0       	ldi	r21, 0x00	; 0
     eb0:	62 e6       	ldi	r22, 0x62	; 98
     eb2:	70 e0       	ldi	r23, 0x00	; 0
     eb4:	8b ee       	ldi	r24, 0xEB	; 235
     eb6:	95 e0       	ldi	r25, 0x05	; 5
     eb8:	0e 94 4f 06 	call	0xc9e	; 0xc9e <xTaskCreate>
     ebc:	81 30       	cpi	r24, 0x01	; 1
     ebe:	81 f4       	brne	.+32     	; 0xee0 <vTaskStartScheduler+0x4c>
     ec0:	f8 94       	cli
     ec2:	8f ef       	ldi	r24, 0xFF	; 255
     ec4:	9f ef       	ldi	r25, 0xFF	; 255
     ec6:	90 93 cd 02 	sts	0x02CD, r25	; 0x8002cd <xNextTaskUnblockTime+0x1>
     eca:	80 93 cc 02 	sts	0x02CC, r24	; 0x8002cc <xNextTaskUnblockTime>
     ece:	81 e0       	ldi	r24, 0x01	; 1
     ed0:	80 93 d2 02 	sts	0x02D2, r24	; 0x8002d2 <xSchedulerRunning>
     ed4:	10 92 d5 02 	sts	0x02D5, r1	; 0x8002d5 <xTickCount+0x1>
     ed8:	10 92 d4 02 	sts	0x02D4, r1	; 0x8002d4 <xTickCount>
     edc:	0e 94 8e 02 	call	0x51c	; 0x51c <xPortStartScheduler>
     ee0:	0f 91       	pop	r16
     ee2:	ff 90       	pop	r15
     ee4:	ef 90       	pop	r14
     ee6:	08 95       	ret

00000ee8 <vTaskSuspendAll>:
     ee8:	80 91 c9 02 	lds	r24, 0x02C9	; 0x8002c9 <uxSchedulerSuspended>
     eec:	8f 5f       	subi	r24, 0xFF	; 255
     eee:	80 93 c9 02 	sts	0x02C9, r24	; 0x8002c9 <uxSchedulerSuspended>
     ef2:	08 95       	ret

00000ef4 <xTaskIncrementTick>:
     ef4:	cf 92       	push	r12
     ef6:	df 92       	push	r13
     ef8:	ef 92       	push	r14
     efa:	ff 92       	push	r15
     efc:	0f 93       	push	r16
     efe:	1f 93       	push	r17
     f00:	cf 93       	push	r28
     f02:	df 93       	push	r29
     f04:	80 91 c9 02 	lds	r24, 0x02C9	; 0x8002c9 <uxSchedulerSuspended>
     f08:	81 11       	cpse	r24, r1
     f0a:	99 c0       	rjmp	.+306    	; 0x103e <xTaskIncrementTick+0x14a>
     f0c:	e0 90 d4 02 	lds	r14, 0x02D4	; 0x8002d4 <xTickCount>
     f10:	f0 90 d5 02 	lds	r15, 0x02D5	; 0x8002d5 <xTickCount+0x1>
     f14:	8f ef       	ldi	r24, 0xFF	; 255
     f16:	e8 1a       	sub	r14, r24
     f18:	f8 0a       	sbc	r15, r24
     f1a:	f0 92 d5 02 	sts	0x02D5, r15	; 0x8002d5 <xTickCount+0x1>
     f1e:	e0 92 d4 02 	sts	0x02D4, r14	; 0x8002d4 <xTickCount>
     f22:	e1 14       	cp	r14, r1
     f24:	f1 04       	cpc	r15, r1
     f26:	b9 f4       	brne	.+46     	; 0xf56 <xTaskIncrementTick+0x62>
     f28:	80 91 e2 02 	lds	r24, 0x02E2	; 0x8002e2 <pxDelayedTaskList>
     f2c:	90 91 e3 02 	lds	r25, 0x02E3	; 0x8002e3 <pxDelayedTaskList+0x1>
     f30:	20 91 e0 02 	lds	r18, 0x02E0	; 0x8002e0 <pxOverflowDelayedTaskList>
     f34:	30 91 e1 02 	lds	r19, 0x02E1	; 0x8002e1 <pxOverflowDelayedTaskList+0x1>
     f38:	30 93 e3 02 	sts	0x02E3, r19	; 0x8002e3 <pxDelayedTaskList+0x1>
     f3c:	20 93 e2 02 	sts	0x02E2, r18	; 0x8002e2 <pxDelayedTaskList>
     f40:	90 93 e1 02 	sts	0x02E1, r25	; 0x8002e1 <pxOverflowDelayedTaskList+0x1>
     f44:	80 93 e0 02 	sts	0x02E0, r24	; 0x8002e0 <pxOverflowDelayedTaskList>
     f48:	80 91 cf 02 	lds	r24, 0x02CF	; 0x8002cf <xNumOfOverflows>
     f4c:	8f 5f       	subi	r24, 0xFF	; 255
     f4e:	80 93 cf 02 	sts	0x02CF, r24	; 0x8002cf <xNumOfOverflows>
     f52:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <prvResetNextTaskUnblockTime>
     f56:	80 91 cc 02 	lds	r24, 0x02CC	; 0x8002cc <xNextTaskUnblockTime>
     f5a:	90 91 cd 02 	lds	r25, 0x02CD	; 0x8002cd <xNextTaskUnblockTime+0x1>
     f5e:	e8 16       	cp	r14, r24
     f60:	f9 06       	cpc	r15, r25
     f62:	10 f4       	brcc	.+4      	; 0xf68 <xTaskIncrementTick+0x74>
     f64:	d1 2c       	mov	r13, r1
     f66:	53 c0       	rjmp	.+166    	; 0x100e <xTaskIncrementTick+0x11a>
     f68:	d1 2c       	mov	r13, r1
     f6a:	cc 24       	eor	r12, r12
     f6c:	c3 94       	inc	r12
     f6e:	e0 91 e2 02 	lds	r30, 0x02E2	; 0x8002e2 <pxDelayedTaskList>
     f72:	f0 91 e3 02 	lds	r31, 0x02E3	; 0x8002e3 <pxDelayedTaskList+0x1>
     f76:	80 81       	ld	r24, Z
     f78:	81 11       	cpse	r24, r1
     f7a:	07 c0       	rjmp	.+14     	; 0xf8a <xTaskIncrementTick+0x96>
     f7c:	8f ef       	ldi	r24, 0xFF	; 255
     f7e:	9f ef       	ldi	r25, 0xFF	; 255
     f80:	90 93 cd 02 	sts	0x02CD, r25	; 0x8002cd <xNextTaskUnblockTime+0x1>
     f84:	80 93 cc 02 	sts	0x02CC, r24	; 0x8002cc <xNextTaskUnblockTime>
     f88:	42 c0       	rjmp	.+132    	; 0x100e <xTaskIncrementTick+0x11a>
     f8a:	e0 91 e2 02 	lds	r30, 0x02E2	; 0x8002e2 <pxDelayedTaskList>
     f8e:	f0 91 e3 02 	lds	r31, 0x02E3	; 0x8002e3 <pxDelayedTaskList+0x1>
     f92:	05 80       	ldd	r0, Z+5	; 0x05
     f94:	f6 81       	ldd	r31, Z+6	; 0x06
     f96:	e0 2d       	mov	r30, r0
     f98:	c6 81       	ldd	r28, Z+6	; 0x06
     f9a:	d7 81       	ldd	r29, Z+7	; 0x07
     f9c:	8a 81       	ldd	r24, Y+2	; 0x02
     f9e:	9b 81       	ldd	r25, Y+3	; 0x03
     fa0:	e8 16       	cp	r14, r24
     fa2:	f9 06       	cpc	r15, r25
     fa4:	28 f4       	brcc	.+10     	; 0xfb0 <xTaskIncrementTick+0xbc>
     fa6:	90 93 cd 02 	sts	0x02CD, r25	; 0x8002cd <xNextTaskUnblockTime+0x1>
     faa:	80 93 cc 02 	sts	0x02CC, r24	; 0x8002cc <xNextTaskUnblockTime>
     fae:	2f c0       	rjmp	.+94     	; 0x100e <xTaskIncrementTick+0x11a>
     fb0:	8e 01       	movw	r16, r28
     fb2:	0e 5f       	subi	r16, 0xFE	; 254
     fb4:	1f 4f       	sbci	r17, 0xFF	; 255
     fb6:	c8 01       	movw	r24, r16
     fb8:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
     fbc:	8c 89       	ldd	r24, Y+20	; 0x14
     fbe:	9d 89       	ldd	r25, Y+21	; 0x15
     fc0:	89 2b       	or	r24, r25
     fc2:	21 f0       	breq	.+8      	; 0xfcc <xTaskIncrementTick+0xd8>
     fc4:	ce 01       	movw	r24, r28
     fc6:	0c 96       	adiw	r24, 0x0c	; 12
     fc8:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
     fcc:	8e 89       	ldd	r24, Y+22	; 0x16
     fce:	90 91 d3 02 	lds	r25, 0x02D3	; 0x8002d3 <uxTopReadyPriority>
     fd2:	98 17       	cp	r25, r24
     fd4:	10 f4       	brcc	.+4      	; 0xfda <xTaskIncrementTick+0xe6>
     fd6:	80 93 d3 02 	sts	0x02D3, r24	; 0x8002d3 <uxTopReadyPriority>
     fda:	90 e0       	ldi	r25, 0x00	; 0
     fdc:	9c 01       	movw	r18, r24
     fde:	22 0f       	add	r18, r18
     fe0:	33 1f       	adc	r19, r19
     fe2:	22 0f       	add	r18, r18
     fe4:	33 1f       	adc	r19, r19
     fe6:	22 0f       	add	r18, r18
     fe8:	33 1f       	adc	r19, r19
     fea:	82 0f       	add	r24, r18
     fec:	93 1f       	adc	r25, r19
     fee:	b8 01       	movw	r22, r16
     ff0:	8a 50       	subi	r24, 0x0A	; 10
     ff2:	9d 4f       	sbci	r25, 0xFD	; 253
     ff4:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
     ff8:	e0 91 08 03 	lds	r30, 0x0308	; 0x800308 <pxCurrentTCB>
     ffc:	f0 91 09 03 	lds	r31, 0x0309	; 0x800309 <pxCurrentTCB+0x1>
    1000:	9e 89       	ldd	r25, Y+22	; 0x16
    1002:	86 89       	ldd	r24, Z+22	; 0x16
    1004:	98 17       	cp	r25, r24
    1006:	08 f4       	brcc	.+2      	; 0x100a <xTaskIncrementTick+0x116>
    1008:	b2 cf       	rjmp	.-156    	; 0xf6e <xTaskIncrementTick+0x7a>
    100a:	dc 2c       	mov	r13, r12
    100c:	b0 cf       	rjmp	.-160    	; 0xf6e <xTaskIncrementTick+0x7a>
    100e:	e0 91 08 03 	lds	r30, 0x0308	; 0x800308 <pxCurrentTCB>
    1012:	f0 91 09 03 	lds	r31, 0x0309	; 0x800309 <pxCurrentTCB+0x1>
    1016:	86 89       	ldd	r24, Z+22	; 0x16
    1018:	90 e0       	ldi	r25, 0x00	; 0
    101a:	fc 01       	movw	r30, r24
    101c:	ee 0f       	add	r30, r30
    101e:	ff 1f       	adc	r31, r31
    1020:	ee 0f       	add	r30, r30
    1022:	ff 1f       	adc	r31, r31
    1024:	ee 0f       	add	r30, r30
    1026:	ff 1f       	adc	r31, r31
    1028:	8e 0f       	add	r24, r30
    102a:	9f 1f       	adc	r25, r31
    102c:	fc 01       	movw	r30, r24
    102e:	ea 50       	subi	r30, 0x0A	; 10
    1030:	fd 4f       	sbci	r31, 0xFD	; 253
    1032:	80 81       	ld	r24, Z
    1034:	82 30       	cpi	r24, 0x02	; 2
    1036:	48 f0       	brcs	.+18     	; 0x104a <xTaskIncrementTick+0x156>
    1038:	dd 24       	eor	r13, r13
    103a:	d3 94       	inc	r13
    103c:	06 c0       	rjmp	.+12     	; 0x104a <xTaskIncrementTick+0x156>
    103e:	80 91 d1 02 	lds	r24, 0x02D1	; 0x8002d1 <uxPendedTicks>
    1042:	8f 5f       	subi	r24, 0xFF	; 255
    1044:	80 93 d1 02 	sts	0x02D1, r24	; 0x8002d1 <uxPendedTicks>
    1048:	d1 2c       	mov	r13, r1
    104a:	80 91 d0 02 	lds	r24, 0x02D0	; 0x8002d0 <xYieldPending>
    104e:	88 23       	and	r24, r24
    1050:	11 f0       	breq	.+4      	; 0x1056 <xTaskIncrementTick+0x162>
    1052:	dd 24       	eor	r13, r13
    1054:	d3 94       	inc	r13
    1056:	8d 2d       	mov	r24, r13
    1058:	df 91       	pop	r29
    105a:	cf 91       	pop	r28
    105c:	1f 91       	pop	r17
    105e:	0f 91       	pop	r16
    1060:	ff 90       	pop	r15
    1062:	ef 90       	pop	r14
    1064:	df 90       	pop	r13
    1066:	cf 90       	pop	r12
    1068:	08 95       	ret

0000106a <xTaskResumeAll>:
    106a:	df 92       	push	r13
    106c:	ef 92       	push	r14
    106e:	ff 92       	push	r15
    1070:	0f 93       	push	r16
    1072:	1f 93       	push	r17
    1074:	cf 93       	push	r28
    1076:	df 93       	push	r29
    1078:	0f b6       	in	r0, 0x3f	; 63
    107a:	f8 94       	cli
    107c:	0f 92       	push	r0
    107e:	80 91 c9 02 	lds	r24, 0x02C9	; 0x8002c9 <uxSchedulerSuspended>
    1082:	81 50       	subi	r24, 0x01	; 1
    1084:	80 93 c9 02 	sts	0x02C9, r24	; 0x8002c9 <uxSchedulerSuspended>
    1088:	80 91 c9 02 	lds	r24, 0x02C9	; 0x8002c9 <uxSchedulerSuspended>
    108c:	81 11       	cpse	r24, r1
    108e:	5f c0       	rjmp	.+190    	; 0x114e <xTaskResumeAll+0xe4>
    1090:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <uxCurrentNumberOfTasks>
    1094:	81 11       	cpse	r24, r1
    1096:	33 c0       	rjmp	.+102    	; 0x10fe <xTaskResumeAll+0x94>
    1098:	5d c0       	rjmp	.+186    	; 0x1154 <xTaskResumeAll+0xea>
    109a:	d7 01       	movw	r26, r14
    109c:	15 96       	adiw	r26, 0x05	; 5
    109e:	ed 91       	ld	r30, X+
    10a0:	fc 91       	ld	r31, X
    10a2:	16 97       	sbiw	r26, 0x06	; 6
    10a4:	c6 81       	ldd	r28, Z+6	; 0x06
    10a6:	d7 81       	ldd	r29, Z+7	; 0x07
    10a8:	ce 01       	movw	r24, r28
    10aa:	0c 96       	adiw	r24, 0x0c	; 12
    10ac:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
    10b0:	8e 01       	movw	r16, r28
    10b2:	0e 5f       	subi	r16, 0xFE	; 254
    10b4:	1f 4f       	sbci	r17, 0xFF	; 255
    10b6:	c8 01       	movw	r24, r16
    10b8:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
    10bc:	8e 89       	ldd	r24, Y+22	; 0x16
    10be:	90 91 d3 02 	lds	r25, 0x02D3	; 0x8002d3 <uxTopReadyPriority>
    10c2:	98 17       	cp	r25, r24
    10c4:	10 f4       	brcc	.+4      	; 0x10ca <xTaskResumeAll+0x60>
    10c6:	80 93 d3 02 	sts	0x02D3, r24	; 0x8002d3 <uxTopReadyPriority>
    10ca:	90 e0       	ldi	r25, 0x00	; 0
    10cc:	9c 01       	movw	r18, r24
    10ce:	22 0f       	add	r18, r18
    10d0:	33 1f       	adc	r19, r19
    10d2:	22 0f       	add	r18, r18
    10d4:	33 1f       	adc	r19, r19
    10d6:	22 0f       	add	r18, r18
    10d8:	33 1f       	adc	r19, r19
    10da:	82 0f       	add	r24, r18
    10dc:	93 1f       	adc	r25, r19
    10de:	b8 01       	movw	r22, r16
    10e0:	8a 50       	subi	r24, 0x0A	; 10
    10e2:	9d 4f       	sbci	r25, 0xFD	; 253
    10e4:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
    10e8:	e0 91 08 03 	lds	r30, 0x0308	; 0x800308 <pxCurrentTCB>
    10ec:	f0 91 09 03 	lds	r31, 0x0309	; 0x800309 <pxCurrentTCB+0x1>
    10f0:	9e 89       	ldd	r25, Y+22	; 0x16
    10f2:	86 89       	ldd	r24, Z+22	; 0x16
    10f4:	98 17       	cp	r25, r24
    10f6:	68 f0       	brcs	.+26     	; 0x1112 <xTaskResumeAll+0xa8>
    10f8:	d0 92 d0 02 	sts	0x02D0, r13	; 0x8002d0 <xYieldPending>
    10fc:	0a c0       	rjmp	.+20     	; 0x1112 <xTaskResumeAll+0xa8>
    10fe:	c0 e0       	ldi	r28, 0x00	; 0
    1100:	d0 e0       	ldi	r29, 0x00	; 0
    1102:	0f 2e       	mov	r0, r31
    1104:	f7 ed       	ldi	r31, 0xD7	; 215
    1106:	ef 2e       	mov	r14, r31
    1108:	f2 e0       	ldi	r31, 0x02	; 2
    110a:	ff 2e       	mov	r15, r31
    110c:	f0 2d       	mov	r31, r0
    110e:	dd 24       	eor	r13, r13
    1110:	d3 94       	inc	r13
    1112:	f7 01       	movw	r30, r14
    1114:	80 81       	ld	r24, Z
    1116:	81 11       	cpse	r24, r1
    1118:	c0 cf       	rjmp	.-128    	; 0x109a <xTaskResumeAll+0x30>
    111a:	cd 2b       	or	r28, r29
    111c:	11 f0       	breq	.+4      	; 0x1122 <xTaskResumeAll+0xb8>
    111e:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <prvResetNextTaskUnblockTime>
    1122:	c0 91 d1 02 	lds	r28, 0x02D1	; 0x8002d1 <uxPendedTicks>
    1126:	cc 23       	and	r28, r28
    1128:	51 f0       	breq	.+20     	; 0x113e <xTaskResumeAll+0xd4>
    112a:	d1 e0       	ldi	r29, 0x01	; 1
    112c:	0e 94 7a 07 	call	0xef4	; 0xef4 <xTaskIncrementTick>
    1130:	81 11       	cpse	r24, r1
    1132:	d0 93 d0 02 	sts	0x02D0, r29	; 0x8002d0 <xYieldPending>
    1136:	c1 50       	subi	r28, 0x01	; 1
    1138:	c9 f7       	brne	.-14     	; 0x112c <xTaskResumeAll+0xc2>
    113a:	10 92 d1 02 	sts	0x02D1, r1	; 0x8002d1 <uxPendedTicks>
    113e:	80 91 d0 02 	lds	r24, 0x02D0	; 0x8002d0 <xYieldPending>
    1142:	88 23       	and	r24, r24
    1144:	31 f0       	breq	.+12     	; 0x1152 <xTaskResumeAll+0xe8>
    1146:	0e 94 c3 02 	call	0x586	; 0x586 <vPortYield>
    114a:	81 e0       	ldi	r24, 0x01	; 1
    114c:	03 c0       	rjmp	.+6      	; 0x1154 <xTaskResumeAll+0xea>
    114e:	80 e0       	ldi	r24, 0x00	; 0
    1150:	01 c0       	rjmp	.+2      	; 0x1154 <xTaskResumeAll+0xea>
    1152:	80 e0       	ldi	r24, 0x00	; 0
    1154:	0f 90       	pop	r0
    1156:	0f be       	out	0x3f, r0	; 63
    1158:	df 91       	pop	r29
    115a:	cf 91       	pop	r28
    115c:	1f 91       	pop	r17
    115e:	0f 91       	pop	r16
    1160:	ff 90       	pop	r15
    1162:	ef 90       	pop	r14
    1164:	df 90       	pop	r13
    1166:	08 95       	ret

00001168 <vTaskDelay>:
    1168:	cf 93       	push	r28
    116a:	df 93       	push	r29
    116c:	ec 01       	movw	r28, r24
    116e:	89 2b       	or	r24, r25
    1170:	51 f0       	breq	.+20     	; 0x1186 <vTaskDelay+0x1e>
    1172:	0e 94 74 07 	call	0xee8	; 0xee8 <vTaskSuspendAll>
    1176:	60 e0       	ldi	r22, 0x00	; 0
    1178:	ce 01       	movw	r24, r28
    117a:	0e 94 0b 06 	call	0xc16	; 0xc16 <prvAddCurrentTaskToDelayedList>
    117e:	0e 94 35 08 	call	0x106a	; 0x106a <xTaskResumeAll>
    1182:	81 11       	cpse	r24, r1
    1184:	02 c0       	rjmp	.+4      	; 0x118a <vTaskDelay+0x22>
    1186:	0e 94 c3 02 	call	0x586	; 0x586 <vPortYield>
    118a:	df 91       	pop	r29
    118c:	cf 91       	pop	r28
    118e:	08 95       	ret

00001190 <vTaskSwitchContext>:
    1190:	80 91 c9 02 	lds	r24, 0x02C9	; 0x8002c9 <uxSchedulerSuspended>
    1194:	88 23       	and	r24, r24
    1196:	21 f0       	breq	.+8      	; 0x11a0 <vTaskSwitchContext+0x10>
    1198:	81 e0       	ldi	r24, 0x01	; 1
    119a:	80 93 d0 02 	sts	0x02D0, r24	; 0x8002d0 <xYieldPending>
    119e:	08 95       	ret
    11a0:	10 92 d0 02 	sts	0x02D0, r1	; 0x8002d0 <xYieldPending>
    11a4:	20 91 d3 02 	lds	r18, 0x02D3	; 0x8002d3 <uxTopReadyPriority>
    11a8:	82 2f       	mov	r24, r18
    11aa:	90 e0       	ldi	r25, 0x00	; 0
    11ac:	fc 01       	movw	r30, r24
    11ae:	ee 0f       	add	r30, r30
    11b0:	ff 1f       	adc	r31, r31
    11b2:	ee 0f       	add	r30, r30
    11b4:	ff 1f       	adc	r31, r31
    11b6:	ee 0f       	add	r30, r30
    11b8:	ff 1f       	adc	r31, r31
    11ba:	e8 0f       	add	r30, r24
    11bc:	f9 1f       	adc	r31, r25
    11be:	ea 50       	subi	r30, 0x0A	; 10
    11c0:	fd 4f       	sbci	r31, 0xFD	; 253
    11c2:	30 81       	ld	r19, Z
    11c4:	31 11       	cpse	r19, r1
    11c6:	11 c0       	rjmp	.+34     	; 0x11ea <vTaskSwitchContext+0x5a>
    11c8:	21 50       	subi	r18, 0x01	; 1
    11ca:	82 2f       	mov	r24, r18
    11cc:	90 e0       	ldi	r25, 0x00	; 0
    11ce:	fc 01       	movw	r30, r24
    11d0:	ee 0f       	add	r30, r30
    11d2:	ff 1f       	adc	r31, r31
    11d4:	ee 0f       	add	r30, r30
    11d6:	ff 1f       	adc	r31, r31
    11d8:	ee 0f       	add	r30, r30
    11da:	ff 1f       	adc	r31, r31
    11dc:	e8 0f       	add	r30, r24
    11de:	f9 1f       	adc	r31, r25
    11e0:	ea 50       	subi	r30, 0x0A	; 10
    11e2:	fd 4f       	sbci	r31, 0xFD	; 253
    11e4:	30 81       	ld	r19, Z
    11e6:	33 23       	and	r19, r19
    11e8:	79 f3       	breq	.-34     	; 0x11c8 <vTaskSwitchContext+0x38>
    11ea:	ac 01       	movw	r20, r24
    11ec:	44 0f       	add	r20, r20
    11ee:	55 1f       	adc	r21, r21
    11f0:	44 0f       	add	r20, r20
    11f2:	55 1f       	adc	r21, r21
    11f4:	44 0f       	add	r20, r20
    11f6:	55 1f       	adc	r21, r21
    11f8:	48 0f       	add	r20, r24
    11fa:	59 1f       	adc	r21, r25
    11fc:	da 01       	movw	r26, r20
    11fe:	aa 50       	subi	r26, 0x0A	; 10
    1200:	bd 4f       	sbci	r27, 0xFD	; 253
    1202:	11 96       	adiw	r26, 0x01	; 1
    1204:	ed 91       	ld	r30, X+
    1206:	fc 91       	ld	r31, X
    1208:	12 97       	sbiw	r26, 0x02	; 2
    120a:	02 80       	ldd	r0, Z+2	; 0x02
    120c:	f3 81       	ldd	r31, Z+3	; 0x03
    120e:	e0 2d       	mov	r30, r0
    1210:	12 96       	adiw	r26, 0x02	; 2
    1212:	fc 93       	st	X, r31
    1214:	ee 93       	st	-X, r30
    1216:	11 97       	sbiw	r26, 0x01	; 1
    1218:	47 50       	subi	r20, 0x07	; 7
    121a:	5d 4f       	sbci	r21, 0xFD	; 253
    121c:	e4 17       	cp	r30, r20
    121e:	f5 07       	cpc	r31, r21
    1220:	29 f4       	brne	.+10     	; 0x122c <vTaskSwitchContext+0x9c>
    1222:	42 81       	ldd	r20, Z+2	; 0x02
    1224:	53 81       	ldd	r21, Z+3	; 0x03
    1226:	fd 01       	movw	r30, r26
    1228:	52 83       	std	Z+2, r21	; 0x02
    122a:	41 83       	std	Z+1, r20	; 0x01
    122c:	fc 01       	movw	r30, r24
    122e:	ee 0f       	add	r30, r30
    1230:	ff 1f       	adc	r31, r31
    1232:	ee 0f       	add	r30, r30
    1234:	ff 1f       	adc	r31, r31
    1236:	ee 0f       	add	r30, r30
    1238:	ff 1f       	adc	r31, r31
    123a:	8e 0f       	add	r24, r30
    123c:	9f 1f       	adc	r25, r31
    123e:	fc 01       	movw	r30, r24
    1240:	ea 50       	subi	r30, 0x0A	; 10
    1242:	fd 4f       	sbci	r31, 0xFD	; 253
    1244:	01 80       	ldd	r0, Z+1	; 0x01
    1246:	f2 81       	ldd	r31, Z+2	; 0x02
    1248:	e0 2d       	mov	r30, r0
    124a:	86 81       	ldd	r24, Z+6	; 0x06
    124c:	97 81       	ldd	r25, Z+7	; 0x07
    124e:	90 93 09 03 	sts	0x0309, r25	; 0x800309 <pxCurrentTCB+0x1>
    1252:	80 93 08 03 	sts	0x0308, r24	; 0x800308 <pxCurrentTCB>
    1256:	20 93 d3 02 	sts	0x02D3, r18	; 0x8002d3 <uxTopReadyPriority>
    125a:	08 95       	ret

0000125c <vTaskPlaceOnEventList>:
    125c:	cf 93       	push	r28
    125e:	df 93       	push	r29
    1260:	eb 01       	movw	r28, r22
    1262:	60 91 08 03 	lds	r22, 0x0308	; 0x800308 <pxCurrentTCB>
    1266:	70 91 09 03 	lds	r23, 0x0309	; 0x800309 <pxCurrentTCB+0x1>
    126a:	64 5f       	subi	r22, 0xF4	; 244
    126c:	7f 4f       	sbci	r23, 0xFF	; 255
    126e:	0e 94 49 01 	call	0x292	; 0x292 <vListInsert>
    1272:	61 e0       	ldi	r22, 0x01	; 1
    1274:	ce 01       	movw	r24, r28
    1276:	0e 94 0b 06 	call	0xc16	; 0xc16 <prvAddCurrentTaskToDelayedList>
    127a:	df 91       	pop	r29
    127c:	cf 91       	pop	r28
    127e:	08 95       	ret

00001280 <xTaskRemoveFromEventList>:
    1280:	0f 93       	push	r16
    1282:	1f 93       	push	r17
    1284:	cf 93       	push	r28
    1286:	df 93       	push	r29
    1288:	dc 01       	movw	r26, r24
    128a:	15 96       	adiw	r26, 0x05	; 5
    128c:	ed 91       	ld	r30, X+
    128e:	fc 91       	ld	r31, X
    1290:	16 97       	sbiw	r26, 0x06	; 6
    1292:	c6 81       	ldd	r28, Z+6	; 0x06
    1294:	d7 81       	ldd	r29, Z+7	; 0x07
    1296:	8e 01       	movw	r16, r28
    1298:	04 5f       	subi	r16, 0xF4	; 244
    129a:	1f 4f       	sbci	r17, 0xFF	; 255
    129c:	c8 01       	movw	r24, r16
    129e:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
    12a2:	80 91 c9 02 	lds	r24, 0x02C9	; 0x8002c9 <uxSchedulerSuspended>
    12a6:	81 11       	cpse	r24, r1
    12a8:	1c c0       	rjmp	.+56     	; 0x12e2 <xTaskRemoveFromEventList+0x62>
    12aa:	0a 50       	subi	r16, 0x0A	; 10
    12ac:	11 09       	sbc	r17, r1
    12ae:	c8 01       	movw	r24, r16
    12b0:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
    12b4:	8e 89       	ldd	r24, Y+22	; 0x16
    12b6:	90 91 d3 02 	lds	r25, 0x02D3	; 0x8002d3 <uxTopReadyPriority>
    12ba:	98 17       	cp	r25, r24
    12bc:	10 f4       	brcc	.+4      	; 0x12c2 <xTaskRemoveFromEventList+0x42>
    12be:	80 93 d3 02 	sts	0x02D3, r24	; 0x8002d3 <uxTopReadyPriority>
    12c2:	90 e0       	ldi	r25, 0x00	; 0
    12c4:	9c 01       	movw	r18, r24
    12c6:	22 0f       	add	r18, r18
    12c8:	33 1f       	adc	r19, r19
    12ca:	22 0f       	add	r18, r18
    12cc:	33 1f       	adc	r19, r19
    12ce:	22 0f       	add	r18, r18
    12d0:	33 1f       	adc	r19, r19
    12d2:	82 0f       	add	r24, r18
    12d4:	93 1f       	adc	r25, r19
    12d6:	b8 01       	movw	r22, r16
    12d8:	8a 50       	subi	r24, 0x0A	; 10
    12da:	9d 4f       	sbci	r25, 0xFD	; 253
    12dc:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
    12e0:	05 c0       	rjmp	.+10     	; 0x12ec <xTaskRemoveFromEventList+0x6c>
    12e2:	b8 01       	movw	r22, r16
    12e4:	87 ed       	ldi	r24, 0xD7	; 215
    12e6:	92 e0       	ldi	r25, 0x02	; 2
    12e8:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
    12ec:	e0 91 08 03 	lds	r30, 0x0308	; 0x800308 <pxCurrentTCB>
    12f0:	f0 91 09 03 	lds	r31, 0x0309	; 0x800309 <pxCurrentTCB+0x1>
    12f4:	9e 89       	ldd	r25, Y+22	; 0x16
    12f6:	86 89       	ldd	r24, Z+22	; 0x16
    12f8:	89 17       	cp	r24, r25
    12fa:	20 f4       	brcc	.+8      	; 0x1304 <xTaskRemoveFromEventList+0x84>
    12fc:	81 e0       	ldi	r24, 0x01	; 1
    12fe:	80 93 d0 02 	sts	0x02D0, r24	; 0x8002d0 <xYieldPending>
    1302:	01 c0       	rjmp	.+2      	; 0x1306 <xTaskRemoveFromEventList+0x86>
    1304:	80 e0       	ldi	r24, 0x00	; 0
    1306:	df 91       	pop	r29
    1308:	cf 91       	pop	r28
    130a:	1f 91       	pop	r17
    130c:	0f 91       	pop	r16
    130e:	08 95       	ret

00001310 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1310:	20 91 cf 02 	lds	r18, 0x02CF	; 0x8002cf <xNumOfOverflows>
    1314:	fc 01       	movw	r30, r24
    1316:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1318:	20 91 d4 02 	lds	r18, 0x02D4	; 0x8002d4 <xTickCount>
    131c:	30 91 d5 02 	lds	r19, 0x02D5	; 0x8002d5 <xTickCount+0x1>
    1320:	32 83       	std	Z+2, r19	; 0x02
    1322:	21 83       	std	Z+1, r18	; 0x01
    1324:	08 95       	ret

00001326 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    1326:	cf 93       	push	r28
    1328:	df 93       	push	r29
    132a:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    132c:	0f b6       	in	r0, 0x3f	; 63
    132e:	f8 94       	cli
    1330:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    1332:	20 91 d4 02 	lds	r18, 0x02D4	; 0x8002d4 <xTickCount>
    1336:	30 91 d5 02 	lds	r19, 0x02D5	; 0x8002d5 <xTickCount+0x1>
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    133a:	80 91 cf 02 	lds	r24, 0x02CF	; 0x8002cf <xNumOfOverflows>
    133e:	90 81       	ld	r25, Z
    1340:	98 17       	cp	r25, r24
    1342:	29 f0       	breq	.+10     	; 0x134e <xTaskCheckForTimeOut+0x28>
    1344:	81 81       	ldd	r24, Z+1	; 0x01
    1346:	92 81       	ldd	r25, Z+2	; 0x02
    1348:	28 17       	cp	r18, r24
    134a:	39 07       	cpc	r19, r25
    134c:	b0 f4       	brcc	.+44     	; 0x137a <xTaskCheckForTimeOut+0x54>
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    134e:	a1 81       	ldd	r26, Z+1	; 0x01
    1350:	b2 81       	ldd	r27, Z+2	; 0x02
    1352:	eb 01       	movw	r28, r22
    1354:	48 81       	ld	r20, Y
    1356:	59 81       	ldd	r21, Y+1	; 0x01
    1358:	c9 01       	movw	r24, r18
    135a:	8a 1b       	sub	r24, r26
    135c:	9b 0b       	sbc	r25, r27
    135e:	84 17       	cp	r24, r20
    1360:	95 07       	cpc	r25, r21
    1362:	68 f4       	brcc	.+26     	; 0x137e <xTaskCheckForTimeOut+0x58>
    1364:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    1366:	a2 1b       	sub	r26, r18
    1368:	b3 0b       	sbc	r27, r19
    136a:	4a 0f       	add	r20, r26
    136c:	5b 1f       	adc	r21, r27
    136e:	59 83       	std	Y+1, r21	; 0x01
    1370:	48 83       	st	Y, r20
			vTaskSetTimeOutState( pxTimeOut );
    1372:	0e 94 88 09 	call	0x1310	; 0x1310 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1376:	80 e0       	ldi	r24, 0x00	; 0
    1378:	03 c0       	rjmp	.+6      	; 0x1380 <xTaskCheckForTimeOut+0x5a>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    137a:	81 e0       	ldi	r24, 0x01	; 1
    137c:	01 c0       	rjmp	.+2      	; 0x1380 <xTaskCheckForTimeOut+0x5a>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    137e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1380:	0f 90       	pop	r0
    1382:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1384:	df 91       	pop	r29
    1386:	cf 91       	pop	r28
    1388:	08 95       	ret

0000138a <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    138a:	81 e0       	ldi	r24, 0x01	; 1
    138c:	80 93 d0 02 	sts	0x02D0, r24	; 0x8002d0 <xYieldPending>
    1390:	08 95       	ret

00001392 <memcpy>:
    1392:	fb 01       	movw	r30, r22
    1394:	dc 01       	movw	r26, r24
    1396:	02 c0       	rjmp	.+4      	; 0x139c <memcpy+0xa>
    1398:	01 90       	ld	r0, Z+
    139a:	0d 92       	st	X+, r0
    139c:	41 50       	subi	r20, 0x01	; 1
    139e:	50 40       	sbci	r21, 0x00	; 0
    13a0:	d8 f7       	brcc	.-10     	; 0x1398 <memcpy+0x6>
    13a2:	08 95       	ret

000013a4 <_exit>:
    13a4:	f8 94       	cli

000013a6 <__stop_program>:
    13a6:	ff cf       	rjmp	.-2      	; 0x13a6 <__stop_program>
