
FREERTOS_V9.0.0_atmega32_Z_SecondShoot.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000e30  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000008  00800060  00000e30  00000ec4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002be  00800068  00800068  00000ecc  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000ecc  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000efc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001f8  00000000  00000000  00000f38  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000026e0  00000000  00000000  00001130  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000c98  00000000  00000000  00003810  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001539  00000000  00000000  000044a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000598  00000000  00000000  000059e4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000e90  00000000  00000000  00005f7c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001fc6  00000000  00000000  00006e0c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001f0  00000000  00000000  00008dd2  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__vector_7>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e0 e3       	ldi	r30, 0x30	; 48
  68:	fe e0       	ldi	r31, 0x0E	; 14
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a8 36       	cpi	r26, 0x68	; 104
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	23 e0       	ldi	r18, 0x03	; 3
  78:	a8 e6       	ldi	r26, 0x68	; 104
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a6 32       	cpi	r26, 0x26	; 38
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 c1 01 	call	0x382	; 0x382 <main>
  8a:	0c 94 16 07 	jmp	0xe2c	; 0xe2c <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
  92:	0f 93       	push	r16
  94:	1f 93       	push	r17
  96:	cf 93       	push	r28
  98:	df 93       	push	r29
  9a:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
  9c:	0e 94 2b 05 	call	0xa56	; 0xa56 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
  a0:	80 91 68 00 	lds	r24, 0x0068	; 0x800068 <__data_end>
  a4:	81 11       	cpse	r24, r1
  a6:	1d c0       	rjmp	.+58     	; 0xe2 <pvPortMalloc+0x50>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
  a8:	ed e6       	ldi	r30, 0x6D	; 109
  aa:	f0 e0       	ldi	r31, 0x00	; 0
  ac:	82 e7       	ldi	r24, 0x72	; 114
  ae:	90 e0       	ldi	r25, 0x00	; 0
  b0:	91 83       	std	Z+1, r25	; 0x01
  b2:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
  b4:	13 82       	std	Z+3, r1	; 0x03
  b6:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
  b8:	e9 e6       	ldi	r30, 0x69	; 105
  ba:	f0 e0       	ldi	r31, 0x00	; 0
  bc:	87 e5       	ldi	r24, 0x57	; 87
  be:	92 e0       	ldi	r25, 0x02	; 2
  c0:	93 83       	std	Z+3, r25	; 0x03
  c2:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
  c4:	11 82       	std	Z+1, r1	; 0x01
  c6:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
  c8:	a1 e7       	ldi	r26, 0x71	; 113
  ca:	b0 e0       	ldi	r27, 0x00	; 0
  cc:	14 96       	adiw	r26, 0x04	; 4
  ce:	9c 93       	st	X, r25
  d0:	8e 93       	st	-X, r24
  d2:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
  d4:	12 96       	adiw	r26, 0x02	; 2
  d6:	fc 93       	st	X, r31
  d8:	ee 93       	st	-X, r30
  da:	11 97       	sbiw	r26, 0x01	; 1
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
  dc:	81 e0       	ldi	r24, 0x01	; 1
  de:	80 93 68 00 	sts	0x0068, r24	; 0x800068 <__data_end>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
  e2:	20 97       	sbiw	r28, 0x00	; 0
  e4:	09 f4       	brne	.+2      	; 0xe8 <pvPortMalloc+0x56>
  e6:	5f c0       	rjmp	.+190    	; 0x1a6 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
  e8:	9e 01       	movw	r18, r28
  ea:	2c 5f       	subi	r18, 0xFC	; 252
  ec:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
  ee:	23 96       	adiw	r28, 0x03	; 3
  f0:	c6 35       	cpi	r28, 0x56	; 86
  f2:	d2 40       	sbci	r29, 0x02	; 2
  f4:	08 f0       	brcs	.+2      	; 0xf8 <pvPortMalloc+0x66>
  f6:	5a c0       	rjmp	.+180    	; 0x1ac <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
  f8:	e0 91 6d 00 	lds	r30, 0x006D	; 0x80006d <xStart>
  fc:	f0 91 6e 00 	lds	r31, 0x006E	; 0x80006e <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
 100:	ad e6       	ldi	r26, 0x6D	; 109
 102:	b0 e0       	ldi	r27, 0x00	; 0
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 104:	02 c0       	rjmp	.+4      	; 0x10a <pvPortMalloc+0x78>
 106:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
 108:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 10a:	82 81       	ldd	r24, Z+2	; 0x02
 10c:	93 81       	ldd	r25, Z+3	; 0x03
 10e:	82 17       	cp	r24, r18
 110:	93 07       	cpc	r25, r19
 112:	20 f4       	brcc	.+8      	; 0x11c <pvPortMalloc+0x8a>
 114:	80 81       	ld	r24, Z
 116:	91 81       	ldd	r25, Z+1	; 0x01
 118:	00 97       	sbiw	r24, 0x00	; 0
 11a:	a9 f7       	brne	.-22     	; 0x106 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
 11c:	c0 e0       	ldi	r28, 0x00	; 0
 11e:	e9 36       	cpi	r30, 0x69	; 105
 120:	fc 07       	cpc	r31, r28
 122:	09 f4       	brne	.+2      	; 0x126 <pvPortMalloc+0x94>
 124:	46 c0       	rjmp	.+140    	; 0x1b2 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
 126:	cd 91       	ld	r28, X+
 128:	dc 91       	ld	r29, X
 12a:	11 97       	sbiw	r26, 0x01	; 1
 12c:	8e 01       	movw	r16, r28
 12e:	0c 5f       	subi	r16, 0xFC	; 252
 130:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 132:	80 81       	ld	r24, Z
 134:	91 81       	ldd	r25, Z+1	; 0x01
 136:	8d 93       	st	X+, r24
 138:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 13a:	82 81       	ldd	r24, Z+2	; 0x02
 13c:	93 81       	ldd	r25, Z+3	; 0x03
 13e:	82 1b       	sub	r24, r18
 140:	93 0b       	sbc	r25, r19
 142:	89 30       	cpi	r24, 0x09	; 9
 144:	91 05       	cpc	r25, r1
 146:	10 f1       	brcs	.+68     	; 0x18c <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 148:	bf 01       	movw	r22, r30
 14a:	62 0f       	add	r22, r18
 14c:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 14e:	db 01       	movw	r26, r22
 150:	13 96       	adiw	r26, 0x03	; 3
 152:	9c 93       	st	X, r25
 154:	8e 93       	st	-X, r24
 156:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
 158:	33 83       	std	Z+3, r19	; 0x03
 15a:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
 15c:	12 96       	adiw	r26, 0x02	; 2
 15e:	4d 91       	ld	r20, X+
 160:	5c 91       	ld	r21, X
 162:	13 97       	sbiw	r26, 0x03	; 3
 164:	8d e6       	ldi	r24, 0x6D	; 109
 166:	90 e0       	ldi	r25, 0x00	; 0
 168:	01 c0       	rjmp	.+2      	; 0x16c <pvPortMalloc+0xda>
 16a:	cd 01       	movw	r24, r26
 16c:	ec 01       	movw	r28, r24
 16e:	a8 81       	ld	r26, Y
 170:	b9 81       	ldd	r27, Y+1	; 0x01
 172:	12 96       	adiw	r26, 0x02	; 2
 174:	2d 91       	ld	r18, X+
 176:	3c 91       	ld	r19, X
 178:	13 97       	sbiw	r26, 0x03	; 3
 17a:	24 17       	cp	r18, r20
 17c:	35 07       	cpc	r19, r21
 17e:	a8 f3       	brcs	.-22     	; 0x16a <pvPortMalloc+0xd8>
 180:	eb 01       	movw	r28, r22
 182:	b9 83       	std	Y+1, r27	; 0x01
 184:	a8 83       	st	Y, r26
 186:	dc 01       	movw	r26, r24
 188:	6d 93       	st	X+, r22
 18a:	7c 93       	st	X, r23
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
 18c:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
 190:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__data_start+0x1>
 194:	22 81       	ldd	r18, Z+2	; 0x02
 196:	33 81       	ldd	r19, Z+3	; 0x03
 198:	82 1b       	sub	r24, r18
 19a:	93 0b       	sbc	r25, r19
 19c:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
 1a0:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
 1a4:	08 c0       	rjmp	.+16     	; 0x1b6 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
 1a6:	00 e0       	ldi	r16, 0x00	; 0
 1a8:	10 e0       	ldi	r17, 0x00	; 0
 1aa:	05 c0       	rjmp	.+10     	; 0x1b6 <pvPortMalloc+0x124>
 1ac:	00 e0       	ldi	r16, 0x00	; 0
 1ae:	10 e0       	ldi	r17, 0x00	; 0
 1b0:	02 c0       	rjmp	.+4      	; 0x1b6 <pvPortMalloc+0x124>
 1b2:	00 e0       	ldi	r16, 0x00	; 0
 1b4:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 1b6:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
 1ba:	c8 01       	movw	r24, r16
 1bc:	df 91       	pop	r29
 1be:	cf 91       	pop	r28
 1c0:	1f 91       	pop	r17
 1c2:	0f 91       	pop	r16
 1c4:	08 95       	ret

000001c6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 1c6:	0f 93       	push	r16
 1c8:	1f 93       	push	r17
 1ca:	cf 93       	push	r28
 1cc:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
 1ce:	00 97       	sbiw	r24, 0x00	; 0
 1d0:	41 f1       	breq	.+80     	; 0x222 <vPortFree+0x5c>
 1d2:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
 1d4:	8c 01       	movw	r16, r24
 1d6:	04 50       	subi	r16, 0x04	; 4
 1d8:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
 1da:	0e 94 2b 05 	call	0xa56	; 0xa56 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 1de:	f8 01       	movw	r30, r16
 1e0:	42 81       	ldd	r20, Z+2	; 0x02
 1e2:	53 81       	ldd	r21, Z+3	; 0x03
 1e4:	ad e6       	ldi	r26, 0x6D	; 109
 1e6:	b0 e0       	ldi	r27, 0x00	; 0
 1e8:	01 c0       	rjmp	.+2      	; 0x1ec <vPortFree+0x26>
 1ea:	df 01       	movw	r26, r30
 1ec:	ed 91       	ld	r30, X+
 1ee:	fc 91       	ld	r31, X
 1f0:	11 97       	sbiw	r26, 0x01	; 1
 1f2:	22 81       	ldd	r18, Z+2	; 0x02
 1f4:	33 81       	ldd	r19, Z+3	; 0x03
 1f6:	24 17       	cp	r18, r20
 1f8:	35 07       	cpc	r19, r21
 1fa:	b8 f3       	brcs	.-18     	; 0x1ea <vPortFree+0x24>
 1fc:	24 97       	sbiw	r28, 0x04	; 4
 1fe:	f9 83       	std	Y+1, r31	; 0x01
 200:	e8 83       	st	Y, r30
 202:	0d 93       	st	X+, r16
 204:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
 206:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <__data_start>
 20a:	30 91 61 00 	lds	r19, 0x0061	; 0x800061 <__data_start+0x1>
 20e:	8a 81       	ldd	r24, Y+2	; 0x02
 210:	9b 81       	ldd	r25, Y+3	; 0x03
 212:	82 0f       	add	r24, r18
 214:	93 1f       	adc	r25, r19
 216:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
 21a:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
 21e:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <xTaskResumeAll>
	}
}
 222:	df 91       	pop	r29
 224:	cf 91       	pop	r28
 226:	1f 91       	pop	r17
 228:	0f 91       	pop	r16
 22a:	08 95       	ret

0000022c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 22c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 22e:	03 96       	adiw	r24, 0x03	; 3
 230:	92 83       	std	Z+2, r25	; 0x02
 232:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 234:	2f ef       	ldi	r18, 0xFF	; 255
 236:	3f ef       	ldi	r19, 0xFF	; 255
 238:	34 83       	std	Z+4, r19	; 0x04
 23a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 23c:	96 83       	std	Z+6, r25	; 0x06
 23e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 240:	90 87       	std	Z+8, r25	; 0x08
 242:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 244:	10 82       	st	Z, r1
 246:	08 95       	ret

00000248 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 248:	fc 01       	movw	r30, r24
 24a:	11 86       	std	Z+9, r1	; 0x09
 24c:	10 86       	std	Z+8, r1	; 0x08
 24e:	08 95       	ret

00000250 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 250:	cf 93       	push	r28
 252:	df 93       	push	r29
 254:	9c 01       	movw	r18, r24
 256:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
 258:	dc 01       	movw	r26, r24
 25a:	11 96       	adiw	r26, 0x01	; 1
 25c:	cd 91       	ld	r28, X+
 25e:	dc 91       	ld	r29, X
 260:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 262:	d3 83       	std	Z+3, r29	; 0x03
 264:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 266:	8c 81       	ldd	r24, Y+4	; 0x04
 268:	9d 81       	ldd	r25, Y+5	; 0x05
 26a:	95 83       	std	Z+5, r25	; 0x05
 26c:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 26e:	8c 81       	ldd	r24, Y+4	; 0x04
 270:	9d 81       	ldd	r25, Y+5	; 0x05
 272:	dc 01       	movw	r26, r24
 274:	13 96       	adiw	r26, 0x03	; 3
 276:	7c 93       	st	X, r23
 278:	6e 93       	st	-X, r22
 27a:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
 27c:	7d 83       	std	Y+5, r23	; 0x05
 27e:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 280:	31 87       	std	Z+9, r19	; 0x09
 282:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
 284:	f9 01       	movw	r30, r18
 286:	80 81       	ld	r24, Z
 288:	8f 5f       	subi	r24, 0xFF	; 255
 28a:	80 83       	st	Z, r24
}
 28c:	df 91       	pop	r29
 28e:	cf 91       	pop	r28
 290:	08 95       	ret

00000292 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 292:	cf 93       	push	r28
 294:	df 93       	push	r29
 296:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 298:	48 81       	ld	r20, Y
 29a:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 29c:	4f 3f       	cpi	r20, 0xFF	; 255
 29e:	2f ef       	ldi	r18, 0xFF	; 255
 2a0:	52 07       	cpc	r21, r18
 2a2:	21 f4       	brne	.+8      	; 0x2ac <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 2a4:	fc 01       	movw	r30, r24
 2a6:	a7 81       	ldd	r26, Z+7	; 0x07
 2a8:	b0 85       	ldd	r27, Z+8	; 0x08
 2aa:	0d c0       	rjmp	.+26     	; 0x2c6 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 2ac:	dc 01       	movw	r26, r24
 2ae:	13 96       	adiw	r26, 0x03	; 3
 2b0:	01 c0       	rjmp	.+2      	; 0x2b4 <vListInsert+0x22>
 2b2:	df 01       	movw	r26, r30
 2b4:	12 96       	adiw	r26, 0x02	; 2
 2b6:	ed 91       	ld	r30, X+
 2b8:	fc 91       	ld	r31, X
 2ba:	13 97       	sbiw	r26, 0x03	; 3
 2bc:	20 81       	ld	r18, Z
 2be:	31 81       	ldd	r19, Z+1	; 0x01
 2c0:	42 17       	cp	r20, r18
 2c2:	53 07       	cpc	r21, r19
 2c4:	b0 f7       	brcc	.-20     	; 0x2b2 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 2c6:	12 96       	adiw	r26, 0x02	; 2
 2c8:	ed 91       	ld	r30, X+
 2ca:	fc 91       	ld	r31, X
 2cc:	13 97       	sbiw	r26, 0x03	; 3
 2ce:	fb 83       	std	Y+3, r31	; 0x03
 2d0:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 2d2:	d5 83       	std	Z+5, r29	; 0x05
 2d4:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
 2d6:	bd 83       	std	Y+5, r27	; 0x05
 2d8:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
 2da:	13 96       	adiw	r26, 0x03	; 3
 2dc:	dc 93       	st	X, r29
 2de:	ce 93       	st	-X, r28
 2e0:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 2e2:	99 87       	std	Y+9, r25	; 0x09
 2e4:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 2e6:	fc 01       	movw	r30, r24
 2e8:	20 81       	ld	r18, Z
 2ea:	2f 5f       	subi	r18, 0xFF	; 255
 2ec:	20 83       	st	Z, r18
}
 2ee:	df 91       	pop	r29
 2f0:	cf 91       	pop	r28
 2f2:	08 95       	ret

000002f4 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 2f4:	cf 93       	push	r28
 2f6:	df 93       	push	r29
 2f8:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 2fa:	a0 85       	ldd	r26, Z+8	; 0x08
 2fc:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 2fe:	c2 81       	ldd	r28, Z+2	; 0x02
 300:	d3 81       	ldd	r29, Z+3	; 0x03
 302:	84 81       	ldd	r24, Z+4	; 0x04
 304:	95 81       	ldd	r25, Z+5	; 0x05
 306:	9d 83       	std	Y+5, r25	; 0x05
 308:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 30a:	c4 81       	ldd	r28, Z+4	; 0x04
 30c:	d5 81       	ldd	r29, Z+5	; 0x05
 30e:	82 81       	ldd	r24, Z+2	; 0x02
 310:	93 81       	ldd	r25, Z+3	; 0x03
 312:	9b 83       	std	Y+3, r25	; 0x03
 314:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 316:	11 96       	adiw	r26, 0x01	; 1
 318:	8d 91       	ld	r24, X+
 31a:	9c 91       	ld	r25, X
 31c:	12 97       	sbiw	r26, 0x02	; 2
 31e:	e8 17       	cp	r30, r24
 320:	f9 07       	cpc	r31, r25
 322:	31 f4       	brne	.+12     	; 0x330 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 324:	84 81       	ldd	r24, Z+4	; 0x04
 326:	95 81       	ldd	r25, Z+5	; 0x05
 328:	12 96       	adiw	r26, 0x02	; 2
 32a:	9c 93       	st	X, r25
 32c:	8e 93       	st	-X, r24
 32e:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 330:	11 86       	std	Z+9, r1	; 0x09
 332:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 334:	8c 91       	ld	r24, X
 336:	81 50       	subi	r24, 0x01	; 1
 338:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
 33a:	df 91       	pop	r29
 33c:	cf 91       	pop	r28
 33e:	08 95       	ret

00000340 <task4>:
#define F_CPU 8000000UL
#include <avr/io.h>
#include "FREERTOS.h"
#include "task.h"
void task4(void * pv)
{
 340:	ec 01       	movw	r28, r24
	while(1)
	{
		//for (uint16_t a=1;a>0;a++);
		PORTD ^= (1<<3);
 342:	18 e0       	ldi	r17, 0x08	; 8
 344:	82 b3       	in	r24, 0x12	; 18
 346:	81 27       	eor	r24, r17
 348:	82 bb       	out	0x12, r24	; 18
		(*(char *)pv)--;
 34a:	88 81       	ld	r24, Y
 34c:	81 50       	subi	r24, 0x01	; 1
 34e:	88 83       	st	Y, r24
		vTaskDelay(20);
 350:	84 e1       	ldi	r24, 0x14	; 20
 352:	90 e0       	ldi	r25, 0x00	; 0
 354:	0e 94 6b 06 	call	0xcd6	; 0xcd6 <vTaskDelay>
 358:	f5 cf       	rjmp	.-22     	; 0x344 <task4+0x4>

0000035a <task5>:
	}
}

void task5(void * pv)
{
 35a:	6c 01       	movw	r12, r24
// 		xTaskCreate(task1,NULL,configMINIMAL_STACK_SIZE,pv,1,NULL);//&A it would be better if a structure and you r the user and know hot it'll be used
// 		xTaskCreate(task2,NULL,configMINIMAL_STACK_SIZE,pv,2,NULL);//&A it would be better if a structure and you r the user and know hot it'll be used
// 		xTaskCreate(task3,NULL,configMINIMAL_STACK_SIZE,pv,3,NULL);//&A it would be better if a structure and you r the user and know hot it'll be used
		xTaskCreate(task4,NULL,configMINIMAL_STACK_SIZE,pv,4,NULL);//&A it would be better if a structure and you r the user and know hot it'll be used
		vTaskDelete(NULL);
		PORTD=0xff;
 35c:	cf ef       	ldi	r28, 0xFF	; 255
	while(1)
	{
// 		xTaskCreate(task1,NULL,configMINIMAL_STACK_SIZE,pv,1,NULL);//&A it would be better if a structure and you r the user and know hot it'll be used
// 		xTaskCreate(task2,NULL,configMINIMAL_STACK_SIZE,pv,2,NULL);//&A it would be better if a structure and you r the user and know hot it'll be used
// 		xTaskCreate(task3,NULL,configMINIMAL_STACK_SIZE,pv,3,NULL);//&A it would be better if a structure and you r the user and know hot it'll be used
		xTaskCreate(task4,NULL,configMINIMAL_STACK_SIZE,pv,4,NULL);//&A it would be better if a structure and you r the user and know hot it'll be used
 35e:	e1 2c       	mov	r14, r1
 360:	f1 2c       	mov	r15, r1
 362:	04 e0       	ldi	r16, 0x04	; 4
 364:	96 01       	movw	r18, r12
 366:	45 e5       	ldi	r20, 0x55	; 85
 368:	50 e0       	ldi	r21, 0x00	; 0
 36a:	60 e0       	ldi	r22, 0x00	; 0
 36c:	70 e0       	ldi	r23, 0x00	; 0
 36e:	80 ea       	ldi	r24, 0xA0	; 160
 370:	91 e0       	ldi	r25, 0x01	; 1
 372:	0e 94 a4 03 	call	0x748	; 0x748 <xTaskCreate>
		vTaskDelete(NULL);
 376:	80 e0       	ldi	r24, 0x00	; 0
 378:	90 e0       	ldi	r25, 0x00	; 0
 37a:	0e 94 ac 04 	call	0x958	; 0x958 <vTaskDelete>
		PORTD=0xff;
 37e:	c2 bb       	out	0x12, r28	; 18
 380:	ee cf       	rjmp	.-36     	; 0x35e <task5+0x4>

00000382 <main>:
	}
}

int main(void)
{
 382:	ef 92       	push	r14
 384:	ff 92       	push	r15
 386:	0f 93       	push	r16
 388:	cf 93       	push	r28
 38a:	df 93       	push	r29
 38c:	1f 92       	push	r1
 38e:	cd b7       	in	r28, 0x3d	; 61
 390:	de b7       	in	r29, 0x3e	; 62
	
	DDRA=0xff;
 392:	8f ef       	ldi	r24, 0xFF	; 255
 394:	8a bb       	out	0x1a, r24	; 26
	DDRB=0xff;
 396:	87 bb       	out	0x17, r24	; 23
	DDRC=0xff;
 398:	84 bb       	out	0x14, r24	; 20
	DDRD=0xff;
 39a:	81 bb       	out	0x11, r24	; 17
	char msa=0xff;
 39c:	89 83       	std	Y+1, r24	; 0x01

	xTaskCreate(task5,NULL,configMINIMAL_STACK_SIZE,(void *)&msa,5,NULL);//&A it would be better if a structure and you r the user and know hot it'll be used
 39e:	e1 2c       	mov	r14, r1
 3a0:	f1 2c       	mov	r15, r1
 3a2:	05 e0       	ldi	r16, 0x05	; 5
 3a4:	9e 01       	movw	r18, r28
 3a6:	2f 5f       	subi	r18, 0xFF	; 255
 3a8:	3f 4f       	sbci	r19, 0xFF	; 255
 3aa:	45 e5       	ldi	r20, 0x55	; 85
 3ac:	50 e0       	ldi	r21, 0x00	; 0
 3ae:	60 e0       	ldi	r22, 0x00	; 0
 3b0:	70 e0       	ldi	r23, 0x00	; 0
 3b2:	8d ea       	ldi	r24, 0xAD	; 173
 3b4:	91 e0       	ldi	r25, 0x01	; 1
 3b6:	0e 94 a4 03 	call	0x748	; 0x748 <xTaskCreate>
	vTaskStartScheduler();
 3ba:	0e 94 01 05 	call	0xa02	; 0xa02 <vTaskStartScheduler>
}
 3be:	80 e0       	ldi	r24, 0x00	; 0
 3c0:	90 e0       	ldi	r25, 0x00	; 0
 3c2:	0f 90       	pop	r0
 3c4:	df 91       	pop	r29
 3c6:	cf 91       	pop	r28
 3c8:	0f 91       	pop	r16
 3ca:	ff 90       	pop	r15
 3cc:	ef 90       	pop	r14
 3ce:	08 95       	ret

000003d0 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 3d0:	31 e1       	ldi	r19, 0x11	; 17
 3d2:	fc 01       	movw	r30, r24
 3d4:	30 83       	st	Z, r19
 3d6:	31 97       	sbiw	r30, 0x01	; 1
 3d8:	22 e2       	ldi	r18, 0x22	; 34
 3da:	20 83       	st	Z, r18
 3dc:	31 97       	sbiw	r30, 0x01	; 1
 3de:	a3 e3       	ldi	r26, 0x33	; 51
 3e0:	a0 83       	st	Z, r26
 3e2:	31 97       	sbiw	r30, 0x01	; 1
 3e4:	60 83       	st	Z, r22
 3e6:	31 97       	sbiw	r30, 0x01	; 1
 3e8:	70 83       	st	Z, r23
 3ea:	31 97       	sbiw	r30, 0x01	; 1
 3ec:	10 82       	st	Z, r1
 3ee:	31 97       	sbiw	r30, 0x01	; 1
 3f0:	60 e8       	ldi	r22, 0x80	; 128
 3f2:	60 83       	st	Z, r22
 3f4:	31 97       	sbiw	r30, 0x01	; 1
 3f6:	10 82       	st	Z, r1
 3f8:	31 97       	sbiw	r30, 0x01	; 1
 3fa:	62 e0       	ldi	r22, 0x02	; 2
 3fc:	60 83       	st	Z, r22
 3fe:	31 97       	sbiw	r30, 0x01	; 1
 400:	63 e0       	ldi	r22, 0x03	; 3
 402:	60 83       	st	Z, r22
 404:	31 97       	sbiw	r30, 0x01	; 1
 406:	64 e0       	ldi	r22, 0x04	; 4
 408:	60 83       	st	Z, r22
 40a:	31 97       	sbiw	r30, 0x01	; 1
 40c:	65 e0       	ldi	r22, 0x05	; 5
 40e:	60 83       	st	Z, r22
 410:	31 97       	sbiw	r30, 0x01	; 1
 412:	66 e0       	ldi	r22, 0x06	; 6
 414:	60 83       	st	Z, r22
 416:	31 97       	sbiw	r30, 0x01	; 1
 418:	67 e0       	ldi	r22, 0x07	; 7
 41a:	60 83       	st	Z, r22
 41c:	31 97       	sbiw	r30, 0x01	; 1
 41e:	68 e0       	ldi	r22, 0x08	; 8
 420:	60 83       	st	Z, r22
 422:	31 97       	sbiw	r30, 0x01	; 1
 424:	69 e0       	ldi	r22, 0x09	; 9
 426:	60 83       	st	Z, r22
 428:	31 97       	sbiw	r30, 0x01	; 1
 42a:	60 e1       	ldi	r22, 0x10	; 16
 42c:	60 83       	st	Z, r22
 42e:	31 97       	sbiw	r30, 0x01	; 1
 430:	30 83       	st	Z, r19
 432:	31 97       	sbiw	r30, 0x01	; 1
 434:	32 e1       	ldi	r19, 0x12	; 18
 436:	30 83       	st	Z, r19
 438:	31 97       	sbiw	r30, 0x01	; 1
 43a:	33 e1       	ldi	r19, 0x13	; 19
 43c:	30 83       	st	Z, r19
 43e:	31 97       	sbiw	r30, 0x01	; 1
 440:	34 e1       	ldi	r19, 0x14	; 20
 442:	30 83       	st	Z, r19
 444:	31 97       	sbiw	r30, 0x01	; 1
 446:	35 e1       	ldi	r19, 0x15	; 21
 448:	30 83       	st	Z, r19
 44a:	31 97       	sbiw	r30, 0x01	; 1
 44c:	36 e1       	ldi	r19, 0x16	; 22
 44e:	30 83       	st	Z, r19
 450:	31 97       	sbiw	r30, 0x01	; 1
 452:	37 e1       	ldi	r19, 0x17	; 23
 454:	30 83       	st	Z, r19
 456:	31 97       	sbiw	r30, 0x01	; 1
 458:	38 e1       	ldi	r19, 0x18	; 24
 45a:	30 83       	st	Z, r19
 45c:	31 97       	sbiw	r30, 0x01	; 1
 45e:	39 e1       	ldi	r19, 0x19	; 25
 460:	30 83       	st	Z, r19
 462:	31 97       	sbiw	r30, 0x01	; 1
 464:	30 e2       	ldi	r19, 0x20	; 32
 466:	30 83       	st	Z, r19
 468:	31 97       	sbiw	r30, 0x01	; 1
 46a:	31 e2       	ldi	r19, 0x21	; 33
 46c:	30 83       	st	Z, r19
 46e:	31 97       	sbiw	r30, 0x01	; 1
 470:	20 83       	st	Z, r18
 472:	31 97       	sbiw	r30, 0x01	; 1
 474:	23 e2       	ldi	r18, 0x23	; 35
 476:	20 83       	st	Z, r18
 478:	31 97       	sbiw	r30, 0x01	; 1
 47a:	40 83       	st	Z, r20
 47c:	31 97       	sbiw	r30, 0x01	; 1
 47e:	50 83       	st	Z, r21
 480:	31 97       	sbiw	r30, 0x01	; 1
 482:	26 e2       	ldi	r18, 0x26	; 38
 484:	20 83       	st	Z, r18
 486:	31 97       	sbiw	r30, 0x01	; 1
 488:	27 e2       	ldi	r18, 0x27	; 39
 48a:	20 83       	st	Z, r18
 48c:	31 97       	sbiw	r30, 0x01	; 1
 48e:	28 e2       	ldi	r18, 0x28	; 40
 490:	20 83       	st	Z, r18
 492:	31 97       	sbiw	r30, 0x01	; 1
 494:	29 e2       	ldi	r18, 0x29	; 41
 496:	20 83       	st	Z, r18
 498:	31 97       	sbiw	r30, 0x01	; 1
 49a:	20 e3       	ldi	r18, 0x30	; 48
 49c:	20 83       	st	Z, r18
 49e:	31 97       	sbiw	r30, 0x01	; 1
 4a0:	21 e3       	ldi	r18, 0x31	; 49
 4a2:	20 83       	st	Z, r18
 4a4:	86 97       	sbiw	r24, 0x26	; 38
 4a6:	08 95       	ret

000004a8 <xPortStartScheduler>:
 4a8:	1b bc       	out	0x2b, r1	; 43
 4aa:	8c e7       	ldi	r24, 0x7C	; 124
 4ac:	8a bd       	out	0x2a, r24	; 42
 4ae:	8b e0       	ldi	r24, 0x0B	; 11
 4b0:	8e bd       	out	0x2e, r24	; 46
 4b2:	89 b7       	in	r24, 0x39	; 57
 4b4:	80 61       	ori	r24, 0x10	; 16
 4b6:	89 bf       	out	0x39, r24	; 57
 4b8:	a0 91 24 03 	lds	r26, 0x0324	; 0x800324 <pxCurrentTCB>
 4bc:	b0 91 25 03 	lds	r27, 0x0325	; 0x800325 <pxCurrentTCB+0x1>
 4c0:	cd 91       	ld	r28, X+
 4c2:	cd bf       	out	0x3d, r28	; 61
 4c4:	dd 91       	ld	r29, X+
 4c6:	de bf       	out	0x3e, r29	; 62
 4c8:	ff 91       	pop	r31
 4ca:	ef 91       	pop	r30
 4cc:	df 91       	pop	r29
 4ce:	cf 91       	pop	r28
 4d0:	bf 91       	pop	r27
 4d2:	af 91       	pop	r26
 4d4:	9f 91       	pop	r25
 4d6:	8f 91       	pop	r24
 4d8:	7f 91       	pop	r23
 4da:	6f 91       	pop	r22
 4dc:	5f 91       	pop	r21
 4de:	4f 91       	pop	r20
 4e0:	3f 91       	pop	r19
 4e2:	2f 91       	pop	r18
 4e4:	1f 91       	pop	r17
 4e6:	0f 91       	pop	r16
 4e8:	ff 90       	pop	r15
 4ea:	ef 90       	pop	r14
 4ec:	df 90       	pop	r13
 4ee:	cf 90       	pop	r12
 4f0:	bf 90       	pop	r11
 4f2:	af 90       	pop	r10
 4f4:	9f 90       	pop	r9
 4f6:	8f 90       	pop	r8
 4f8:	7f 90       	pop	r7
 4fa:	6f 90       	pop	r6
 4fc:	5f 90       	pop	r5
 4fe:	4f 90       	pop	r4
 500:	3f 90       	pop	r3
 502:	2f 90       	pop	r2
 504:	1f 90       	pop	r1
 506:	0f 90       	pop	r0
 508:	0f be       	out	0x3f, r0	; 63
 50a:	0f 90       	pop	r0
 50c:	08 95       	ret
 50e:	81 e0       	ldi	r24, 0x01	; 1
 510:	08 95       	ret

00000512 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 512:	0f 92       	push	r0
 514:	0f b6       	in	r0, 0x3f	; 63
 516:	f8 94       	cli
 518:	0f 92       	push	r0
 51a:	1f 92       	push	r1
 51c:	11 24       	eor	r1, r1
 51e:	2f 92       	push	r2
 520:	3f 92       	push	r3
 522:	4f 92       	push	r4
 524:	5f 92       	push	r5
 526:	6f 92       	push	r6
 528:	7f 92       	push	r7
 52a:	8f 92       	push	r8
 52c:	9f 92       	push	r9
 52e:	af 92       	push	r10
 530:	bf 92       	push	r11
 532:	cf 92       	push	r12
 534:	df 92       	push	r13
 536:	ef 92       	push	r14
 538:	ff 92       	push	r15
 53a:	0f 93       	push	r16
 53c:	1f 93       	push	r17
 53e:	2f 93       	push	r18
 540:	3f 93       	push	r19
 542:	4f 93       	push	r20
 544:	5f 93       	push	r21
 546:	6f 93       	push	r22
 548:	7f 93       	push	r23
 54a:	8f 93       	push	r24
 54c:	9f 93       	push	r25
 54e:	af 93       	push	r26
 550:	bf 93       	push	r27
 552:	cf 93       	push	r28
 554:	df 93       	push	r29
 556:	ef 93       	push	r30
 558:	ff 93       	push	r31
 55a:	a0 91 24 03 	lds	r26, 0x0324	; 0x800324 <pxCurrentTCB>
 55e:	b0 91 25 03 	lds	r27, 0x0325	; 0x800325 <pxCurrentTCB+0x1>
 562:	0d b6       	in	r0, 0x3d	; 61
 564:	0d 92       	st	X+, r0
 566:	0e b6       	in	r0, 0x3e	; 62
 568:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 56a:	0e 94 b0 06 	call	0xd60	; 0xd60 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 56e:	a0 91 24 03 	lds	r26, 0x0324	; 0x800324 <pxCurrentTCB>
 572:	b0 91 25 03 	lds	r27, 0x0325	; 0x800325 <pxCurrentTCB+0x1>
 576:	cd 91       	ld	r28, X+
 578:	cd bf       	out	0x3d, r28	; 61
 57a:	dd 91       	ld	r29, X+
 57c:	de bf       	out	0x3e, r29	; 62
 57e:	ff 91       	pop	r31
 580:	ef 91       	pop	r30
 582:	df 91       	pop	r29
 584:	cf 91       	pop	r28
 586:	bf 91       	pop	r27
 588:	af 91       	pop	r26
 58a:	9f 91       	pop	r25
 58c:	8f 91       	pop	r24
 58e:	7f 91       	pop	r23
 590:	6f 91       	pop	r22
 592:	5f 91       	pop	r21
 594:	4f 91       	pop	r20
 596:	3f 91       	pop	r19
 598:	2f 91       	pop	r18
 59a:	1f 91       	pop	r17
 59c:	0f 91       	pop	r16
 59e:	ff 90       	pop	r15
 5a0:	ef 90       	pop	r14
 5a2:	df 90       	pop	r13
 5a4:	cf 90       	pop	r12
 5a6:	bf 90       	pop	r11
 5a8:	af 90       	pop	r10
 5aa:	9f 90       	pop	r9
 5ac:	8f 90       	pop	r8
 5ae:	7f 90       	pop	r7
 5b0:	6f 90       	pop	r6
 5b2:	5f 90       	pop	r5
 5b4:	4f 90       	pop	r4
 5b6:	3f 90       	pop	r3
 5b8:	2f 90       	pop	r2
 5ba:	1f 90       	pop	r1
 5bc:	0f 90       	pop	r0
 5be:	0f be       	out	0x3f, r0	; 63
 5c0:	0f 90       	pop	r0

	asm volatile ( "ret" );
 5c2:	08 95       	ret

000005c4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 5c4:	0f 92       	push	r0
 5c6:	0f b6       	in	r0, 0x3f	; 63
 5c8:	f8 94       	cli
 5ca:	0f 92       	push	r0
 5cc:	1f 92       	push	r1
 5ce:	11 24       	eor	r1, r1
 5d0:	2f 92       	push	r2
 5d2:	3f 92       	push	r3
 5d4:	4f 92       	push	r4
 5d6:	5f 92       	push	r5
 5d8:	6f 92       	push	r6
 5da:	7f 92       	push	r7
 5dc:	8f 92       	push	r8
 5de:	9f 92       	push	r9
 5e0:	af 92       	push	r10
 5e2:	bf 92       	push	r11
 5e4:	cf 92       	push	r12
 5e6:	df 92       	push	r13
 5e8:	ef 92       	push	r14
 5ea:	ff 92       	push	r15
 5ec:	0f 93       	push	r16
 5ee:	1f 93       	push	r17
 5f0:	2f 93       	push	r18
 5f2:	3f 93       	push	r19
 5f4:	4f 93       	push	r20
 5f6:	5f 93       	push	r21
 5f8:	6f 93       	push	r22
 5fa:	7f 93       	push	r23
 5fc:	8f 93       	push	r24
 5fe:	9f 93       	push	r25
 600:	af 93       	push	r26
 602:	bf 93       	push	r27
 604:	cf 93       	push	r28
 606:	df 93       	push	r29
 608:	ef 93       	push	r30
 60a:	ff 93       	push	r31
 60c:	a0 91 24 03 	lds	r26, 0x0324	; 0x800324 <pxCurrentTCB>
 610:	b0 91 25 03 	lds	r27, 0x0325	; 0x800325 <pxCurrentTCB+0x1>
 614:	0d b6       	in	r0, 0x3d	; 61
 616:	0d 92       	st	X+, r0
 618:	0e b6       	in	r0, 0x3e	; 62
 61a:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
 61c:	0e 94 31 05 	call	0xa62	; 0xa62 <xTaskIncrementTick>
 620:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
 622:	0e 94 b0 06 	call	0xd60	; 0xd60 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
 626:	a0 91 24 03 	lds	r26, 0x0324	; 0x800324 <pxCurrentTCB>
 62a:	b0 91 25 03 	lds	r27, 0x0325	; 0x800325 <pxCurrentTCB+0x1>
 62e:	cd 91       	ld	r28, X+
 630:	cd bf       	out	0x3d, r28	; 61
 632:	dd 91       	ld	r29, X+
 634:	de bf       	out	0x3e, r29	; 62
 636:	ff 91       	pop	r31
 638:	ef 91       	pop	r30
 63a:	df 91       	pop	r29
 63c:	cf 91       	pop	r28
 63e:	bf 91       	pop	r27
 640:	af 91       	pop	r26
 642:	9f 91       	pop	r25
 644:	8f 91       	pop	r24
 646:	7f 91       	pop	r23
 648:	6f 91       	pop	r22
 64a:	5f 91       	pop	r21
 64c:	4f 91       	pop	r20
 64e:	3f 91       	pop	r19
 650:	2f 91       	pop	r18
 652:	1f 91       	pop	r17
 654:	0f 91       	pop	r16
 656:	ff 90       	pop	r15
 658:	ef 90       	pop	r14
 65a:	df 90       	pop	r13
 65c:	cf 90       	pop	r12
 65e:	bf 90       	pop	r11
 660:	af 90       	pop	r10
 662:	9f 90       	pop	r9
 664:	8f 90       	pop	r8
 666:	7f 90       	pop	r7
 668:	6f 90       	pop	r6
 66a:	5f 90       	pop	r5
 66c:	4f 90       	pop	r4
 66e:	3f 90       	pop	r3
 670:	2f 90       	pop	r2
 672:	1f 90       	pop	r1
 674:	0f 90       	pop	r0
 676:	0f be       	out	0x3f, r0	; 63
 678:	0f 90       	pop	r0

	asm volatile ( "ret" );
 67a:	08 95       	ret

0000067c <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
 67c:	0e 94 e2 02 	call	0x5c4	; 0x5c4 <vPortYieldFromTick>
		asm volatile ( "reti" );
 680:	18 95       	reti

00000682 <prvResetNextTaskUnblockTime>:
	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
 682:	e0 91 ec 02 	lds	r30, 0x02EC	; 0x8002ec <pxDelayedTaskList>
 686:	f0 91 ed 02 	lds	r31, 0x02ED	; 0x8002ed <pxDelayedTaskList+0x1>
 68a:	80 81       	ld	r24, Z
 68c:	81 11       	cpse	r24, r1
 68e:	07 c0       	rjmp	.+14     	; 0x69e <prvResetNextTaskUnblockTime+0x1c>
 690:	8f ef       	ldi	r24, 0xFF	; 255
 692:	9f ef       	ldi	r25, 0xFF	; 255
 694:	90 93 cd 02 	sts	0x02CD, r25	; 0x8002cd <xNextTaskUnblockTime+0x1>
 698:	80 93 cc 02 	sts	0x02CC, r24	; 0x8002cc <xNextTaskUnblockTime>
 69c:	08 95       	ret
 69e:	e0 91 ec 02 	lds	r30, 0x02EC	; 0x8002ec <pxDelayedTaskList>
 6a2:	f0 91 ed 02 	lds	r31, 0x02ED	; 0x8002ed <pxDelayedTaskList+0x1>
 6a6:	05 80       	ldd	r0, Z+5	; 0x05
 6a8:	f6 81       	ldd	r31, Z+6	; 0x06
 6aa:	e0 2d       	mov	r30, r0
 6ac:	06 80       	ldd	r0, Z+6	; 0x06
 6ae:	f7 81       	ldd	r31, Z+7	; 0x07
 6b0:	e0 2d       	mov	r30, r0
 6b2:	82 81       	ldd	r24, Z+2	; 0x02
 6b4:	93 81       	ldd	r25, Z+3	; 0x03
 6b6:	90 93 cd 02 	sts	0x02CD, r25	; 0x8002cd <xNextTaskUnblockTime+0x1>
 6ba:	80 93 cc 02 	sts	0x02CC, r24	; 0x8002cc <xNextTaskUnblockTime>
 6be:	08 95       	ret

000006c0 <prvAddCurrentTaskToDelayedList>:
 6c0:	0f 93       	push	r16
 6c2:	1f 93       	push	r17
 6c4:	cf 93       	push	r28
 6c6:	df 93       	push	r29
 6c8:	ec 01       	movw	r28, r24
 6ca:	00 91 d4 02 	lds	r16, 0x02D4	; 0x8002d4 <xTickCount>
 6ce:	10 91 d5 02 	lds	r17, 0x02D5	; 0x8002d5 <xTickCount+0x1>
 6d2:	80 91 24 03 	lds	r24, 0x0324	; 0x800324 <pxCurrentTCB>
 6d6:	90 91 25 03 	lds	r25, 0x0325	; 0x800325 <pxCurrentTCB+0x1>
 6da:	02 96       	adiw	r24, 0x02	; 2
 6dc:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
 6e0:	c0 0f       	add	r28, r16
 6e2:	d1 1f       	adc	r29, r17
 6e4:	e0 91 24 03 	lds	r30, 0x0324	; 0x800324 <pxCurrentTCB>
 6e8:	f0 91 25 03 	lds	r31, 0x0325	; 0x800325 <pxCurrentTCB+0x1>
 6ec:	d3 83       	std	Z+3, r29	; 0x03
 6ee:	c2 83       	std	Z+2, r28	; 0x02
 6f0:	c0 17       	cp	r28, r16
 6f2:	d1 07       	cpc	r29, r17
 6f4:	68 f4       	brcc	.+26     	; 0x710 <prvAddCurrentTaskToDelayedList+0x50>
 6f6:	60 91 24 03 	lds	r22, 0x0324	; 0x800324 <pxCurrentTCB>
 6fa:	70 91 25 03 	lds	r23, 0x0325	; 0x800325 <pxCurrentTCB+0x1>
 6fe:	80 91 ea 02 	lds	r24, 0x02EA	; 0x8002ea <pxOverflowDelayedTaskList>
 702:	90 91 eb 02 	lds	r25, 0x02EB	; 0x8002eb <pxOverflowDelayedTaskList+0x1>
 706:	6e 5f       	subi	r22, 0xFE	; 254
 708:	7f 4f       	sbci	r23, 0xFF	; 255
 70a:	0e 94 49 01 	call	0x292	; 0x292 <vListInsert>
 70e:	17 c0       	rjmp	.+46     	; 0x73e <prvAddCurrentTaskToDelayedList+0x7e>
 710:	60 91 24 03 	lds	r22, 0x0324	; 0x800324 <pxCurrentTCB>
 714:	70 91 25 03 	lds	r23, 0x0325	; 0x800325 <pxCurrentTCB+0x1>
 718:	80 91 ec 02 	lds	r24, 0x02EC	; 0x8002ec <pxDelayedTaskList>
 71c:	90 91 ed 02 	lds	r25, 0x02ED	; 0x8002ed <pxDelayedTaskList+0x1>
 720:	6e 5f       	subi	r22, 0xFE	; 254
 722:	7f 4f       	sbci	r23, 0xFF	; 255
 724:	0e 94 49 01 	call	0x292	; 0x292 <vListInsert>
 728:	80 91 cc 02 	lds	r24, 0x02CC	; 0x8002cc <xNextTaskUnblockTime>
 72c:	90 91 cd 02 	lds	r25, 0x02CD	; 0x8002cd <xNextTaskUnblockTime+0x1>
 730:	c8 17       	cp	r28, r24
 732:	d9 07       	cpc	r29, r25
 734:	20 f4       	brcc	.+8      	; 0x73e <prvAddCurrentTaskToDelayedList+0x7e>
 736:	d0 93 cd 02 	sts	0x02CD, r29	; 0x8002cd <xNextTaskUnblockTime+0x1>
 73a:	c0 93 cc 02 	sts	0x02CC, r28	; 0x8002cc <xNextTaskUnblockTime>
 73e:	df 91       	pop	r29
 740:	cf 91       	pop	r28
 742:	1f 91       	pop	r17
 744:	0f 91       	pop	r16
 746:	08 95       	ret

00000748 <xTaskCreate>:
 748:	4f 92       	push	r4
 74a:	5f 92       	push	r5
 74c:	6f 92       	push	r6
 74e:	7f 92       	push	r7
 750:	8f 92       	push	r8
 752:	9f 92       	push	r9
 754:	af 92       	push	r10
 756:	bf 92       	push	r11
 758:	cf 92       	push	r12
 75a:	df 92       	push	r13
 75c:	ef 92       	push	r14
 75e:	ff 92       	push	r15
 760:	0f 93       	push	r16
 762:	cf 93       	push	r28
 764:	df 93       	push	r29
 766:	4c 01       	movw	r8, r24
 768:	6b 01       	movw	r12, r22
 76a:	5a 01       	movw	r10, r20
 76c:	29 01       	movw	r4, r18
 76e:	ca 01       	movw	r24, r20
 770:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
 774:	3c 01       	movw	r6, r24
 776:	89 2b       	or	r24, r25
 778:	09 f4       	brne	.+2      	; 0x77c <xTaskCreate+0x34>
 77a:	dd c0       	rjmp	.+442    	; 0x936 <__stack+0xd7>
 77c:	86 e2       	ldi	r24, 0x26	; 38
 77e:	90 e0       	ldi	r25, 0x00	; 0
 780:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
 784:	ec 01       	movw	r28, r24
 786:	89 2b       	or	r24, r25
 788:	71 f0       	breq	.+28     	; 0x7a6 <xTaskCreate+0x5e>
 78a:	78 8e       	std	Y+24, r7	; 0x18
 78c:	6f 8a       	std	Y+23, r6	; 0x17
 78e:	81 e0       	ldi	r24, 0x01	; 1
 790:	a8 1a       	sub	r10, r24
 792:	b1 08       	sbc	r11, r1
 794:	a6 0c       	add	r10, r6
 796:	b7 1c       	adc	r11, r7
 798:	d6 01       	movw	r26, r12
 79a:	8c 91       	ld	r24, X
 79c:	89 8f       	std	Y+25, r24	; 0x19
 79e:	8c 91       	ld	r24, X
 7a0:	81 11       	cpse	r24, r1
 7a2:	05 c0       	rjmp	.+10     	; 0x7ae <xTaskCreate+0x66>
 7a4:	18 c0       	rjmp	.+48     	; 0x7d6 <xTaskCreate+0x8e>
 7a6:	c3 01       	movw	r24, r6
 7a8:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <vPortFree>
 7ac:	c4 c0       	rjmp	.+392    	; 0x936 <__stack+0xd7>
 7ae:	ae 01       	movw	r20, r28
 7b0:	46 5e       	subi	r20, 0xE6	; 230
 7b2:	5f 4f       	sbci	r21, 0xFF	; 255
 7b4:	f6 01       	movw	r30, r12
 7b6:	31 96       	adiw	r30, 0x01	; 1
 7b8:	b8 e0       	ldi	r27, 0x08	; 8
 7ba:	cb 0e       	add	r12, r27
 7bc:	d1 1c       	adc	r13, r1
 7be:	cf 01       	movw	r24, r30
 7c0:	21 91       	ld	r18, Z+
 7c2:	da 01       	movw	r26, r20
 7c4:	2d 93       	st	X+, r18
 7c6:	ad 01       	movw	r20, r26
 7c8:	dc 01       	movw	r26, r24
 7ca:	8c 91       	ld	r24, X
 7cc:	88 23       	and	r24, r24
 7ce:	19 f0       	breq	.+6      	; 0x7d6 <xTaskCreate+0x8e>
 7d0:	ec 15       	cp	r30, r12
 7d2:	fd 05       	cpc	r31, r13
 7d4:	a1 f7       	brne	.-24     	; 0x7be <xTaskCreate+0x76>
 7d6:	18 a2       	std	Y+32, r1	; 0x20
 7d8:	04 30       	cpi	r16, 0x04	; 4
 7da:	08 f0       	brcs	.+2      	; 0x7de <xTaskCreate+0x96>
 7dc:	03 e0       	ldi	r16, 0x03	; 3
 7de:	0e 8b       	std	Y+22, r16	; 0x16
 7e0:	6e 01       	movw	r12, r28
 7e2:	b2 e0       	ldi	r27, 0x02	; 2
 7e4:	cb 0e       	add	r12, r27
 7e6:	d1 1c       	adc	r13, r1
 7e8:	c6 01       	movw	r24, r12
 7ea:	0e 94 24 01 	call	0x248	; 0x248 <vListInitialiseItem>
 7ee:	ce 01       	movw	r24, r28
 7f0:	0c 96       	adiw	r24, 0x0c	; 12
 7f2:	0e 94 24 01 	call	0x248	; 0x248 <vListInitialiseItem>
 7f6:	d9 87       	std	Y+9, r29	; 0x09
 7f8:	c8 87       	std	Y+8, r28	; 0x08
 7fa:	84 e0       	ldi	r24, 0x04	; 4
 7fc:	90 e0       	ldi	r25, 0x00	; 0
 7fe:	80 1b       	sub	r24, r16
 800:	91 09       	sbc	r25, r1
 802:	9d 87       	std	Y+13, r25	; 0x0d
 804:	8c 87       	std	Y+12, r24	; 0x0c
 806:	db 8b       	std	Y+19, r29	; 0x13
 808:	ca 8b       	std	Y+18, r28	; 0x12
 80a:	19 a2       	std	Y+33, r1	; 0x21
 80c:	1a a2       	std	Y+34, r1	; 0x22
 80e:	1b a2       	std	Y+35, r1	; 0x23
 810:	1c a2       	std	Y+36, r1	; 0x24
 812:	1d a2       	std	Y+37, r1	; 0x25
 814:	a2 01       	movw	r20, r4
 816:	b4 01       	movw	r22, r8
 818:	c5 01       	movw	r24, r10
 81a:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <pxPortInitialiseStack>
 81e:	99 83       	std	Y+1, r25	; 0x01
 820:	88 83       	st	Y, r24
 822:	e1 14       	cp	r14, r1
 824:	f1 04       	cpc	r15, r1
 826:	19 f0       	breq	.+6      	; 0x82e <xTaskCreate+0xe6>
 828:	f7 01       	movw	r30, r14
 82a:	d1 83       	std	Z+1, r29	; 0x01
 82c:	c0 83       	st	Z, r28
 82e:	0f b6       	in	r0, 0x3f	; 63
 830:	f8 94       	cli
 832:	0f 92       	push	r0
 834:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <uxCurrentNumberOfTasks>
 838:	8f 5f       	subi	r24, 0xFF	; 255
 83a:	80 93 d6 02 	sts	0x02D6, r24	; 0x8002d6 <uxCurrentNumberOfTasks>
 83e:	80 91 24 03 	lds	r24, 0x0324	; 0x800324 <pxCurrentTCB>
 842:	90 91 25 03 	lds	r25, 0x0325	; 0x800325 <pxCurrentTCB+0x1>
 846:	89 2b       	or	r24, r25
 848:	a9 f5       	brne	.+106    	; 0x8b4 <__stack+0x55>
 84a:	d0 93 25 03 	sts	0x0325, r29	; 0x800325 <pxCurrentTCB+0x1>
 84e:	c0 93 24 03 	sts	0x0324, r28	; 0x800324 <pxCurrentTCB>
 852:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <uxCurrentNumberOfTasks>
 856:	81 30       	cpi	r24, 0x01	; 1
 858:	e9 f5       	brne	.+122    	; 0x8d4 <__stack+0x75>
 85a:	80 e0       	ldi	r24, 0x00	; 0
 85c:	93 e0       	ldi	r25, 0x03	; 3
 85e:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
 862:	89 e0       	ldi	r24, 0x09	; 9
 864:	93 e0       	ldi	r25, 0x03	; 3
 866:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
 86a:	82 e1       	ldi	r24, 0x12	; 18
 86c:	93 e0       	ldi	r25, 0x03	; 3
 86e:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
 872:	8b e1       	ldi	r24, 0x1B	; 27
 874:	93 e0       	ldi	r25, 0x03	; 3
 876:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
 87a:	87 ef       	ldi	r24, 0xF7	; 247
 87c:	92 e0       	ldi	r25, 0x02	; 2
 87e:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
 882:	8e ee       	ldi	r24, 0xEE	; 238
 884:	92 e0       	ldi	r25, 0x02	; 2
 886:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
 88a:	81 ee       	ldi	r24, 0xE1	; 225
 88c:	92 e0       	ldi	r25, 0x02	; 2
 88e:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
 892:	88 ed       	ldi	r24, 0xD8	; 216
 894:	92 e0       	ldi	r25, 0x02	; 2
 896:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
 89a:	87 ef       	ldi	r24, 0xF7	; 247
 89c:	92 e0       	ldi	r25, 0x02	; 2
 89e:	90 93 ed 02 	sts	0x02ED, r25	; 0x8002ed <pxDelayedTaskList+0x1>
 8a2:	80 93 ec 02 	sts	0x02EC, r24	; 0x8002ec <pxDelayedTaskList>
 8a6:	8e ee       	ldi	r24, 0xEE	; 238
 8a8:	92 e0       	ldi	r25, 0x02	; 2
 8aa:	90 93 eb 02 	sts	0x02EB, r25	; 0x8002eb <pxOverflowDelayedTaskList+0x1>
 8ae:	80 93 ea 02 	sts	0x02EA, r24	; 0x8002ea <pxOverflowDelayedTaskList>
 8b2:	10 c0       	rjmp	.+32     	; 0x8d4 <__stack+0x75>
 8b4:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <xSchedulerRunning>
 8b8:	81 11       	cpse	r24, r1
 8ba:	0c c0       	rjmp	.+24     	; 0x8d4 <__stack+0x75>
 8bc:	e0 91 24 03 	lds	r30, 0x0324	; 0x800324 <pxCurrentTCB>
 8c0:	f0 91 25 03 	lds	r31, 0x0325	; 0x800325 <pxCurrentTCB+0x1>
 8c4:	96 89       	ldd	r25, Z+22	; 0x16
 8c6:	8e 89       	ldd	r24, Y+22	; 0x16
 8c8:	89 17       	cp	r24, r25
 8ca:	20 f0       	brcs	.+8      	; 0x8d4 <__stack+0x75>
 8cc:	d0 93 25 03 	sts	0x0325, r29	; 0x800325 <pxCurrentTCB+0x1>
 8d0:	c0 93 24 03 	sts	0x0324, r28	; 0x800324 <pxCurrentTCB>
 8d4:	80 91 ce 02 	lds	r24, 0x02CE	; 0x8002ce <uxTaskNumber>
 8d8:	8f 5f       	subi	r24, 0xFF	; 255
 8da:	80 93 ce 02 	sts	0x02CE, r24	; 0x8002ce <uxTaskNumber>
 8de:	8e 89       	ldd	r24, Y+22	; 0x16
 8e0:	90 91 d3 02 	lds	r25, 0x02D3	; 0x8002d3 <uxTopReadyPriority>
 8e4:	98 17       	cp	r25, r24
 8e6:	10 f4       	brcc	.+4      	; 0x8ec <__stack+0x8d>
 8e8:	80 93 d3 02 	sts	0x02D3, r24	; 0x8002d3 <uxTopReadyPriority>
 8ec:	90 e0       	ldi	r25, 0x00	; 0
 8ee:	9c 01       	movw	r18, r24
 8f0:	22 0f       	add	r18, r18
 8f2:	33 1f       	adc	r19, r19
 8f4:	22 0f       	add	r18, r18
 8f6:	33 1f       	adc	r19, r19
 8f8:	22 0f       	add	r18, r18
 8fa:	33 1f       	adc	r19, r19
 8fc:	82 0f       	add	r24, r18
 8fe:	93 1f       	adc	r25, r19
 900:	b6 01       	movw	r22, r12
 902:	80 50       	subi	r24, 0x00	; 0
 904:	9d 4f       	sbci	r25, 0xFD	; 253
 906:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
 90a:	0f 90       	pop	r0
 90c:	0f be       	out	0x3f, r0	; 63
 90e:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <xSchedulerRunning>
 912:	88 23       	and	r24, r24
 914:	61 f0       	breq	.+24     	; 0x92e <__stack+0xcf>
 916:	e0 91 24 03 	lds	r30, 0x0324	; 0x800324 <pxCurrentTCB>
 91a:	f0 91 25 03 	lds	r31, 0x0325	; 0x800325 <pxCurrentTCB+0x1>
 91e:	96 89       	ldd	r25, Z+22	; 0x16
 920:	8e 89       	ldd	r24, Y+22	; 0x16
 922:	98 17       	cp	r25, r24
 924:	30 f4       	brcc	.+12     	; 0x932 <__stack+0xd3>
 926:	0e 94 89 02 	call	0x512	; 0x512 <vPortYield>
 92a:	81 e0       	ldi	r24, 0x01	; 1
 92c:	05 c0       	rjmp	.+10     	; 0x938 <__stack+0xd9>
 92e:	81 e0       	ldi	r24, 0x01	; 1
 930:	03 c0       	rjmp	.+6      	; 0x938 <__stack+0xd9>
 932:	81 e0       	ldi	r24, 0x01	; 1
 934:	01 c0       	rjmp	.+2      	; 0x938 <__stack+0xd9>
 936:	8f ef       	ldi	r24, 0xFF	; 255
 938:	df 91       	pop	r29
 93a:	cf 91       	pop	r28
 93c:	0f 91       	pop	r16
 93e:	ff 90       	pop	r15
 940:	ef 90       	pop	r14
 942:	df 90       	pop	r13
 944:	cf 90       	pop	r12
 946:	bf 90       	pop	r11
 948:	af 90       	pop	r10
 94a:	9f 90       	pop	r9
 94c:	8f 90       	pop	r8
 94e:	7f 90       	pop	r7
 950:	6f 90       	pop	r6
 952:	5f 90       	pop	r5
 954:	4f 90       	pop	r4
 956:	08 95       	ret

00000958 <vTaskDelete>:
 958:	0f 93       	push	r16
 95a:	1f 93       	push	r17
 95c:	cf 93       	push	r28
 95e:	df 93       	push	r29
 960:	ec 01       	movw	r28, r24
 962:	0f b6       	in	r0, 0x3f	; 63
 964:	f8 94       	cli
 966:	0f 92       	push	r0
 968:	89 2b       	or	r24, r25
 96a:	21 f4       	brne	.+8      	; 0x974 <vTaskDelete+0x1c>
 96c:	c0 91 24 03 	lds	r28, 0x0324	; 0x800324 <pxCurrentTCB>
 970:	d0 91 25 03 	lds	r29, 0x0325	; 0x800325 <pxCurrentTCB+0x1>
 974:	8e 01       	movw	r16, r28
 976:	0e 5f       	subi	r16, 0xFE	; 254
 978:	1f 4f       	sbci	r17, 0xFF	; 255
 97a:	c8 01       	movw	r24, r16
 97c:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
 980:	8c 89       	ldd	r24, Y+20	; 0x14
 982:	9d 89       	ldd	r25, Y+21	; 0x15
 984:	89 2b       	or	r24, r25
 986:	21 f0       	breq	.+8      	; 0x990 <vTaskDelete+0x38>
 988:	ce 01       	movw	r24, r28
 98a:	0c 96       	adiw	r24, 0x0c	; 12
 98c:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
 990:	80 91 ce 02 	lds	r24, 0x02CE	; 0x8002ce <uxTaskNumber>
 994:	8f 5f       	subi	r24, 0xFF	; 255
 996:	80 93 ce 02 	sts	0x02CE, r24	; 0x8002ce <uxTaskNumber>
 99a:	80 91 24 03 	lds	r24, 0x0324	; 0x800324 <pxCurrentTCB>
 99e:	90 91 25 03 	lds	r25, 0x0325	; 0x800325 <pxCurrentTCB+0x1>
 9a2:	c8 17       	cp	r28, r24
 9a4:	d9 07       	cpc	r29, r25
 9a6:	59 f4       	brne	.+22     	; 0x9be <vTaskDelete+0x66>
 9a8:	b8 01       	movw	r22, r16
 9aa:	88 ed       	ldi	r24, 0xD8	; 216
 9ac:	92 e0       	ldi	r25, 0x02	; 2
 9ae:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
 9b2:	80 91 d7 02 	lds	r24, 0x02D7	; 0x8002d7 <uxDeletedTasksWaitingCleanUp>
 9b6:	8f 5f       	subi	r24, 0xFF	; 255
 9b8:	80 93 d7 02 	sts	0x02D7, r24	; 0x8002d7 <uxDeletedTasksWaitingCleanUp>
 9bc:	0e c0       	rjmp	.+28     	; 0x9da <vTaskDelete+0x82>
 9be:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <uxCurrentNumberOfTasks>
 9c2:	81 50       	subi	r24, 0x01	; 1
 9c4:	80 93 d6 02 	sts	0x02D6, r24	; 0x8002d6 <uxCurrentNumberOfTasks>
 9c8:	8f 89       	ldd	r24, Y+23	; 0x17
 9ca:	98 8d       	ldd	r25, Y+24	; 0x18
 9cc:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <vPortFree>
 9d0:	ce 01       	movw	r24, r28
 9d2:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <vPortFree>
 9d6:	0e 94 41 03 	call	0x682	; 0x682 <prvResetNextTaskUnblockTime>
 9da:	0f 90       	pop	r0
 9dc:	0f be       	out	0x3f, r0	; 63
 9de:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <xSchedulerRunning>
 9e2:	88 23       	and	r24, r24
 9e4:	49 f0       	breq	.+18     	; 0x9f8 <vTaskDelete+0xa0>
 9e6:	80 91 24 03 	lds	r24, 0x0324	; 0x800324 <pxCurrentTCB>
 9ea:	90 91 25 03 	lds	r25, 0x0325	; 0x800325 <pxCurrentTCB+0x1>
 9ee:	c8 17       	cp	r28, r24
 9f0:	d9 07       	cpc	r29, r25
 9f2:	11 f4       	brne	.+4      	; 0x9f8 <vTaskDelete+0xa0>
 9f4:	0e 94 89 02 	call	0x512	; 0x512 <vPortYield>
 9f8:	df 91       	pop	r29
 9fa:	cf 91       	pop	r28
 9fc:	1f 91       	pop	r17
 9fe:	0f 91       	pop	r16
 a00:	08 95       	ret

00000a02 <vTaskStartScheduler>:
 a02:	ef 92       	push	r14
 a04:	ff 92       	push	r15
 a06:	0f 93       	push	r16
 a08:	0f 2e       	mov	r0, r31
 a0a:	fa ec       	ldi	r31, 0xCA	; 202
 a0c:	ef 2e       	mov	r14, r31
 a0e:	f2 e0       	ldi	r31, 0x02	; 2
 a10:	ff 2e       	mov	r15, r31
 a12:	f0 2d       	mov	r31, r0
 a14:	00 e0       	ldi	r16, 0x00	; 0
 a16:	20 e0       	ldi	r18, 0x00	; 0
 a18:	30 e0       	ldi	r19, 0x00	; 0
 a1a:	45 e5       	ldi	r20, 0x55	; 85
 a1c:	50 e0       	ldi	r21, 0x00	; 0
 a1e:	62 e6       	ldi	r22, 0x62	; 98
 a20:	70 e0       	ldi	r23, 0x00	; 0
 a22:	8f e7       	ldi	r24, 0x7F	; 127
 a24:	96 e0       	ldi	r25, 0x06	; 6
 a26:	0e 94 a4 03 	call	0x748	; 0x748 <xTaskCreate>
 a2a:	81 30       	cpi	r24, 0x01	; 1
 a2c:	81 f4       	brne	.+32     	; 0xa4e <vTaskStartScheduler+0x4c>
 a2e:	f8 94       	cli
 a30:	8f ef       	ldi	r24, 0xFF	; 255
 a32:	9f ef       	ldi	r25, 0xFF	; 255
 a34:	90 93 cd 02 	sts	0x02CD, r25	; 0x8002cd <xNextTaskUnblockTime+0x1>
 a38:	80 93 cc 02 	sts	0x02CC, r24	; 0x8002cc <xNextTaskUnblockTime>
 a3c:	81 e0       	ldi	r24, 0x01	; 1
 a3e:	80 93 d2 02 	sts	0x02D2, r24	; 0x8002d2 <xSchedulerRunning>
 a42:	10 92 d5 02 	sts	0x02D5, r1	; 0x8002d5 <xTickCount+0x1>
 a46:	10 92 d4 02 	sts	0x02D4, r1	; 0x8002d4 <xTickCount>
 a4a:	0e 94 54 02 	call	0x4a8	; 0x4a8 <xPortStartScheduler>
 a4e:	0f 91       	pop	r16
 a50:	ff 90       	pop	r15
 a52:	ef 90       	pop	r14
 a54:	08 95       	ret

00000a56 <vTaskSuspendAll>:
 a56:	80 91 c9 02 	lds	r24, 0x02C9	; 0x8002c9 <uxSchedulerSuspended>
 a5a:	8f 5f       	subi	r24, 0xFF	; 255
 a5c:	80 93 c9 02 	sts	0x02C9, r24	; 0x8002c9 <uxSchedulerSuspended>
 a60:	08 95       	ret

00000a62 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 a62:	cf 92       	push	r12
 a64:	df 92       	push	r13
 a66:	ef 92       	push	r14
 a68:	ff 92       	push	r15
 a6a:	0f 93       	push	r16
 a6c:	1f 93       	push	r17
 a6e:	cf 93       	push	r28
 a70:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 a72:	80 91 c9 02 	lds	r24, 0x02C9	; 0x8002c9 <uxSchedulerSuspended>
 a76:	81 11       	cpse	r24, r1
 a78:	99 c0       	rjmp	.+306    	; 0xbac <xTaskIncrementTick+0x14a>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
 a7a:	e0 90 d4 02 	lds	r14, 0x02D4	; 0x8002d4 <xTickCount>
 a7e:	f0 90 d5 02 	lds	r15, 0x02D5	; 0x8002d5 <xTickCount+0x1>
 a82:	8f ef       	ldi	r24, 0xFF	; 255
 a84:	e8 1a       	sub	r14, r24
 a86:	f8 0a       	sbc	r15, r24

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
 a88:	f0 92 d5 02 	sts	0x02D5, r15	; 0x8002d5 <xTickCount+0x1>
 a8c:	e0 92 d4 02 	sts	0x02D4, r14	; 0x8002d4 <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U )
 a90:	e1 14       	cp	r14, r1
 a92:	f1 04       	cpc	r15, r1
 a94:	b9 f4       	brne	.+46     	; 0xac4 <xTaskIncrementTick+0x62>
		{
			taskSWITCH_DELAYED_LISTS();
 a96:	80 91 ec 02 	lds	r24, 0x02EC	; 0x8002ec <pxDelayedTaskList>
 a9a:	90 91 ed 02 	lds	r25, 0x02ED	; 0x8002ed <pxDelayedTaskList+0x1>
 a9e:	20 91 ea 02 	lds	r18, 0x02EA	; 0x8002ea <pxOverflowDelayedTaskList>
 aa2:	30 91 eb 02 	lds	r19, 0x02EB	; 0x8002eb <pxOverflowDelayedTaskList+0x1>
 aa6:	30 93 ed 02 	sts	0x02ED, r19	; 0x8002ed <pxDelayedTaskList+0x1>
 aaa:	20 93 ec 02 	sts	0x02EC, r18	; 0x8002ec <pxDelayedTaskList>
 aae:	90 93 eb 02 	sts	0x02EB, r25	; 0x8002eb <pxOverflowDelayedTaskList+0x1>
 ab2:	80 93 ea 02 	sts	0x02EA, r24	; 0x8002ea <pxOverflowDelayedTaskList>
 ab6:	80 91 cf 02 	lds	r24, 0x02CF	; 0x8002cf <xNumOfOverflows>
 aba:	8f 5f       	subi	r24, 0xFF	; 255
 abc:	80 93 cf 02 	sts	0x02CF, r24	; 0x8002cf <xNumOfOverflows>
 ac0:	0e 94 41 03 	call	0x682	; 0x682 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
 ac4:	80 91 cc 02 	lds	r24, 0x02CC	; 0x8002cc <xNextTaskUnblockTime>
 ac8:	90 91 cd 02 	lds	r25, 0x02CD	; 0x8002cd <xNextTaskUnblockTime+0x1>
 acc:	e8 16       	cp	r14, r24
 ace:	f9 06       	cpc	r15, r25
 ad0:	10 f4       	brcc	.+4      	; 0xad6 <xTaskIncrementTick+0x74>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 ad2:	d1 2c       	mov	r13, r1
 ad4:	53 c0       	rjmp	.+166    	; 0xb7c <xTaskIncrementTick+0x11a>
 ad6:	d1 2c       	mov	r13, r1
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
 ad8:	cc 24       	eor	r12, r12
 ada:	c3 94       	inc	r12
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 adc:	e0 91 ec 02 	lds	r30, 0x02EC	; 0x8002ec <pxDelayedTaskList>
 ae0:	f0 91 ed 02 	lds	r31, 0x02ED	; 0x8002ed <pxDelayedTaskList+0x1>
 ae4:	80 81       	ld	r24, Z
 ae6:	81 11       	cpse	r24, r1
 ae8:	07 c0       	rjmp	.+14     	; 0xaf8 <xTaskIncrementTick+0x96>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 aea:	8f ef       	ldi	r24, 0xFF	; 255
 aec:	9f ef       	ldi	r25, 0xFF	; 255
 aee:	90 93 cd 02 	sts	0x02CD, r25	; 0x8002cd <xNextTaskUnblockTime+0x1>
 af2:	80 93 cc 02 	sts	0x02CC, r24	; 0x8002cc <xNextTaskUnblockTime>
					break;
 af6:	42 c0       	rjmp	.+132    	; 0xb7c <xTaskIncrementTick+0x11a>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 af8:	e0 91 ec 02 	lds	r30, 0x02EC	; 0x8002ec <pxDelayedTaskList>
 afc:	f0 91 ed 02 	lds	r31, 0x02ED	; 0x8002ed <pxDelayedTaskList+0x1>
 b00:	05 80       	ldd	r0, Z+5	; 0x05
 b02:	f6 81       	ldd	r31, Z+6	; 0x06
 b04:	e0 2d       	mov	r30, r0
 b06:	c6 81       	ldd	r28, Z+6	; 0x06
 b08:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 b0a:	8a 81       	ldd	r24, Y+2	; 0x02
 b0c:	9b 81       	ldd	r25, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
 b0e:	e8 16       	cp	r14, r24
 b10:	f9 06       	cpc	r15, r25
 b12:	28 f4       	brcc	.+10     	; 0xb1e <xTaskIncrementTick+0xbc>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
 b14:	90 93 cd 02 	sts	0x02CD, r25	; 0x8002cd <xNextTaskUnblockTime+0x1>
 b18:	80 93 cc 02 	sts	0x02CC, r24	; 0x8002cc <xNextTaskUnblockTime>
						break;
 b1c:	2f c0       	rjmp	.+94     	; 0xb7c <xTaskIncrementTick+0x11a>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 b1e:	8e 01       	movw	r16, r28
 b20:	0e 5f       	subi	r16, 0xFE	; 254
 b22:	1f 4f       	sbci	r17, 0xFF	; 255
 b24:	c8 01       	movw	r24, r16
 b26:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 b2a:	8c 89       	ldd	r24, Y+20	; 0x14
 b2c:	9d 89       	ldd	r25, Y+21	; 0x15
 b2e:	89 2b       	or	r24, r25
 b30:	21 f0       	breq	.+8      	; 0xb3a <xTaskIncrementTick+0xd8>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 b32:	ce 01       	movw	r24, r28
 b34:	0c 96       	adiw	r24, 0x0c	; 12
 b36:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
 b3a:	8e 89       	ldd	r24, Y+22	; 0x16
 b3c:	90 91 d3 02 	lds	r25, 0x02D3	; 0x8002d3 <uxTopReadyPriority>
 b40:	98 17       	cp	r25, r24
 b42:	10 f4       	brcc	.+4      	; 0xb48 <xTaskIncrementTick+0xe6>
 b44:	80 93 d3 02 	sts	0x02D3, r24	; 0x8002d3 <uxTopReadyPriority>
 b48:	90 e0       	ldi	r25, 0x00	; 0
 b4a:	9c 01       	movw	r18, r24
 b4c:	22 0f       	add	r18, r18
 b4e:	33 1f       	adc	r19, r19
 b50:	22 0f       	add	r18, r18
 b52:	33 1f       	adc	r19, r19
 b54:	22 0f       	add	r18, r18
 b56:	33 1f       	adc	r19, r19
 b58:	82 0f       	add	r24, r18
 b5a:	93 1f       	adc	r25, r19
 b5c:	b8 01       	movw	r22, r16
 b5e:	80 50       	subi	r24, 0x00	; 0
 b60:	9d 4f       	sbci	r25, 0xFD	; 253
 b62:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 b66:	e0 91 24 03 	lds	r30, 0x0324	; 0x800324 <pxCurrentTCB>
 b6a:	f0 91 25 03 	lds	r31, 0x0325	; 0x800325 <pxCurrentTCB+0x1>
 b6e:	9e 89       	ldd	r25, Y+22	; 0x16
 b70:	86 89       	ldd	r24, Z+22	; 0x16
 b72:	98 17       	cp	r25, r24
 b74:	08 f4       	brcc	.+2      	; 0xb78 <xTaskIncrementTick+0x116>
 b76:	b2 cf       	rjmp	.-156    	; 0xadc <xTaskIncrementTick+0x7a>
						{
							xSwitchRequired = pdTRUE;
 b78:	dc 2c       	mov	r13, r12
 b7a:	b0 cf       	rjmp	.-160    	; 0xadc <xTaskIncrementTick+0x7a>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 b7c:	e0 91 24 03 	lds	r30, 0x0324	; 0x800324 <pxCurrentTCB>
 b80:	f0 91 25 03 	lds	r31, 0x0325	; 0x800325 <pxCurrentTCB+0x1>
 b84:	86 89       	ldd	r24, Z+22	; 0x16
 b86:	90 e0       	ldi	r25, 0x00	; 0
 b88:	fc 01       	movw	r30, r24
 b8a:	ee 0f       	add	r30, r30
 b8c:	ff 1f       	adc	r31, r31
 b8e:	ee 0f       	add	r30, r30
 b90:	ff 1f       	adc	r31, r31
 b92:	ee 0f       	add	r30, r30
 b94:	ff 1f       	adc	r31, r31
 b96:	8e 0f       	add	r24, r30
 b98:	9f 1f       	adc	r25, r31
 b9a:	fc 01       	movw	r30, r24
 b9c:	e0 50       	subi	r30, 0x00	; 0
 b9e:	fd 4f       	sbci	r31, 0xFD	; 253
 ba0:	80 81       	ld	r24, Z
 ba2:	82 30       	cpi	r24, 0x02	; 2
 ba4:	48 f0       	brcs	.+18     	; 0xbb8 <xTaskIncrementTick+0x156>
			{
				xSwitchRequired = pdTRUE;
 ba6:	dd 24       	eor	r13, r13
 ba8:	d3 94       	inc	r13
 baa:	06 c0       	rjmp	.+12     	; 0xbb8 <xTaskIncrementTick+0x156>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 bac:	80 91 d1 02 	lds	r24, 0x02D1	; 0x8002d1 <uxPendedTicks>
 bb0:	8f 5f       	subi	r24, 0xFF	; 255
 bb2:	80 93 d1 02 	sts	0x02D1, r24	; 0x8002d1 <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 bb6:	d1 2c       	mov	r13, r1
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
 bb8:	80 91 d0 02 	lds	r24, 0x02D0	; 0x8002d0 <xYieldPending>
 bbc:	88 23       	and	r24, r24
 bbe:	11 f0       	breq	.+4      	; 0xbc4 <xTaskIncrementTick+0x162>
		{
			xSwitchRequired = pdTRUE;
 bc0:	dd 24       	eor	r13, r13
 bc2:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
 bc4:	8d 2d       	mov	r24, r13
 bc6:	df 91       	pop	r29
 bc8:	cf 91       	pop	r28
 bca:	1f 91       	pop	r17
 bcc:	0f 91       	pop	r16
 bce:	ff 90       	pop	r15
 bd0:	ef 90       	pop	r14
 bd2:	df 90       	pop	r13
 bd4:	cf 90       	pop	r12
 bd6:	08 95       	ret

00000bd8 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 bd8:	df 92       	push	r13
 bda:	ef 92       	push	r14
 bdc:	ff 92       	push	r15
 bde:	0f 93       	push	r16
 be0:	1f 93       	push	r17
 be2:	cf 93       	push	r28
 be4:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 be6:	0f b6       	in	r0, 0x3f	; 63
 be8:	f8 94       	cli
 bea:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
 bec:	80 91 c9 02 	lds	r24, 0x02C9	; 0x8002c9 <uxSchedulerSuspended>
 bf0:	81 50       	subi	r24, 0x01	; 1
 bf2:	80 93 c9 02 	sts	0x02C9, r24	; 0x8002c9 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 bf6:	80 91 c9 02 	lds	r24, 0x02C9	; 0x8002c9 <uxSchedulerSuspended>
 bfa:	81 11       	cpse	r24, r1
 bfc:	5f c0       	rjmp	.+190    	; 0xcbc <xTaskResumeAll+0xe4>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 bfe:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <uxCurrentNumberOfTasks>
 c02:	81 11       	cpse	r24, r1
 c04:	33 c0       	rjmp	.+102    	; 0xc6c <xTaskResumeAll+0x94>
 c06:	5d c0       	rjmp	.+186    	; 0xcc2 <xTaskResumeAll+0xea>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 c08:	d7 01       	movw	r26, r14
 c0a:	15 96       	adiw	r26, 0x05	; 5
 c0c:	ed 91       	ld	r30, X+
 c0e:	fc 91       	ld	r31, X
 c10:	16 97       	sbiw	r26, 0x06	; 6
 c12:	c6 81       	ldd	r28, Z+6	; 0x06
 c14:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 c16:	ce 01       	movw	r24, r28
 c18:	0c 96       	adiw	r24, 0x0c	; 12
 c1a:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 c1e:	8e 01       	movw	r16, r28
 c20:	0e 5f       	subi	r16, 0xFE	; 254
 c22:	1f 4f       	sbci	r17, 0xFF	; 255
 c24:	c8 01       	movw	r24, r16
 c26:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 c2a:	8e 89       	ldd	r24, Y+22	; 0x16
 c2c:	90 91 d3 02 	lds	r25, 0x02D3	; 0x8002d3 <uxTopReadyPriority>
 c30:	98 17       	cp	r25, r24
 c32:	10 f4       	brcc	.+4      	; 0xc38 <xTaskResumeAll+0x60>
 c34:	80 93 d3 02 	sts	0x02D3, r24	; 0x8002d3 <uxTopReadyPriority>
 c38:	90 e0       	ldi	r25, 0x00	; 0
 c3a:	9c 01       	movw	r18, r24
 c3c:	22 0f       	add	r18, r18
 c3e:	33 1f       	adc	r19, r19
 c40:	22 0f       	add	r18, r18
 c42:	33 1f       	adc	r19, r19
 c44:	22 0f       	add	r18, r18
 c46:	33 1f       	adc	r19, r19
 c48:	82 0f       	add	r24, r18
 c4a:	93 1f       	adc	r25, r19
 c4c:	b8 01       	movw	r22, r16
 c4e:	80 50       	subi	r24, 0x00	; 0
 c50:	9d 4f       	sbci	r25, 0xFD	; 253
 c52:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 c56:	e0 91 24 03 	lds	r30, 0x0324	; 0x800324 <pxCurrentTCB>
 c5a:	f0 91 25 03 	lds	r31, 0x0325	; 0x800325 <pxCurrentTCB+0x1>
 c5e:	9e 89       	ldd	r25, Y+22	; 0x16
 c60:	86 89       	ldd	r24, Z+22	; 0x16
 c62:	98 17       	cp	r25, r24
 c64:	68 f0       	brcs	.+26     	; 0xc80 <xTaskResumeAll+0xa8>
					{
						xYieldPending = pdTRUE;
 c66:	d0 92 d0 02 	sts	0x02D0, r13	; 0x8002d0 <xYieldPending>
 c6a:	0a c0       	rjmp	.+20     	; 0xc80 <xTaskResumeAll+0xa8>
 c6c:	c0 e0       	ldi	r28, 0x00	; 0
 c6e:	d0 e0       	ldi	r29, 0x00	; 0
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 c70:	0f 2e       	mov	r0, r31
 c72:	f1 ee       	ldi	r31, 0xE1	; 225
 c74:	ef 2e       	mov	r14, r31
 c76:	f2 e0       	ldi	r31, 0x02	; 2
 c78:	ff 2e       	mov	r15, r31
 c7a:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
 c7c:	dd 24       	eor	r13, r13
 c7e:	d3 94       	inc	r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 c80:	f7 01       	movw	r30, r14
 c82:	80 81       	ld	r24, Z
 c84:	81 11       	cpse	r24, r1
 c86:	c0 cf       	rjmp	.-128    	; 0xc08 <xTaskResumeAll+0x30>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
 c88:	cd 2b       	or	r28, r29
 c8a:	11 f0       	breq	.+4      	; 0xc90 <xTaskResumeAll+0xb8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
 c8c:	0e 94 41 03 	call	0x682	; 0x682 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 c90:	c0 91 d1 02 	lds	r28, 0x02D1	; 0x8002d1 <uxPendedTicks>

					if( uxPendedCounts > ( UBaseType_t ) 0U )
 c94:	cc 23       	and	r28, r28
 c96:	51 f0       	breq	.+20     	; 0xcac <xTaskResumeAll+0xd4>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
 c98:	d1 e0       	ldi	r29, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
 c9a:	0e 94 31 05 	call	0xa62	; 0xa62 <xTaskIncrementTick>
 c9e:	81 11       	cpse	r24, r1
							{
								xYieldPending = pdTRUE;
 ca0:	d0 93 d0 02 	sts	0x02D0, r29	; 0x8002d0 <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
 ca4:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 ca6:	c9 f7       	brne	.-14     	; 0xc9a <xTaskResumeAll+0xc2>

						uxPendedTicks = 0;
 ca8:	10 92 d1 02 	sts	0x02D1, r1	; 0x8002d1 <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
 cac:	80 91 d0 02 	lds	r24, 0x02D0	; 0x8002d0 <xYieldPending>
 cb0:	88 23       	and	r24, r24
 cb2:	31 f0       	breq	.+12     	; 0xcc0 <xTaskResumeAll+0xe8>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 cb4:	0e 94 89 02 	call	0x512	; 0x512 <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
 cb8:	81 e0       	ldi	r24, 0x01	; 1
 cba:	03 c0       	rjmp	.+6      	; 0xcc2 <xTaskResumeAll+0xea>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
 cbc:	80 e0       	ldi	r24, 0x00	; 0
 cbe:	01 c0       	rjmp	.+2      	; 0xcc2 <xTaskResumeAll+0xea>
 cc0:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 cc2:	0f 90       	pop	r0
 cc4:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
 cc6:	df 91       	pop	r29
 cc8:	cf 91       	pop	r28
 cca:	1f 91       	pop	r17
 ccc:	0f 91       	pop	r16
 cce:	ff 90       	pop	r15
 cd0:	ef 90       	pop	r14
 cd2:	df 90       	pop	r13
 cd4:	08 95       	ret

00000cd6 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 cd6:	cf 93       	push	r28
 cd8:	df 93       	push	r29
 cda:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 cdc:	89 2b       	or	r24, r25
 cde:	51 f0       	breq	.+20     	; 0xcf4 <vTaskDelay+0x1e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
 ce0:	0e 94 2b 05 	call	0xa56	; 0xa56 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 ce4:	60 e0       	ldi	r22, 0x00	; 0
 ce6:	ce 01       	movw	r24, r28
 ce8:	0e 94 60 03 	call	0x6c0	; 0x6c0 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 cec:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 cf0:	81 11       	cpse	r24, r1
 cf2:	02 c0       	rjmp	.+4      	; 0xcf8 <vTaskDelay+0x22>
		{
			portYIELD_WITHIN_API();
 cf4:	0e 94 89 02 	call	0x512	; 0x512 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 cf8:	df 91       	pop	r29
 cfa:	cf 91       	pop	r28
 cfc:	08 95       	ret

00000cfe <prvIdleTask>:
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 cfe:	08 ed       	ldi	r16, 0xD8	; 216
 d00:	12 e0       	ldi	r17, 0x02	; 2
 d02:	29 c0       	rjmp	.+82     	; 0xd56 <prvIdleTask+0x58>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
 d04:	0e 94 2b 05 	call	0xa56	; 0xa56 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 d08:	d8 01       	movw	r26, r16
 d0a:	cc 91       	ld	r28, X
			}
			( void ) xTaskResumeAll();
 d0c:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 d10:	cc 23       	and	r28, r28
 d12:	09 f1       	breq	.+66     	; 0xd56 <prvIdleTask+0x58>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
 d14:	0f b6       	in	r0, 0x3f	; 63
 d16:	f8 94       	cli
 d18:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 d1a:	d8 01       	movw	r26, r16
 d1c:	15 96       	adiw	r26, 0x05	; 5
 d1e:	ed 91       	ld	r30, X+
 d20:	fc 91       	ld	r31, X
 d22:	16 97       	sbiw	r26, 0x06	; 6
 d24:	c6 81       	ldd	r28, Z+6	; 0x06
 d26:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 d28:	ce 01       	movw	r24, r28
 d2a:	02 96       	adiw	r24, 0x02	; 2
 d2c:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
					--uxCurrentNumberOfTasks;
 d30:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <uxCurrentNumberOfTasks>
 d34:	81 50       	subi	r24, 0x01	; 1
 d36:	80 93 d6 02 	sts	0x02D6, r24	; 0x8002d6 <uxCurrentNumberOfTasks>
					--uxDeletedTasksWaitingCleanUp;
 d3a:	80 91 d7 02 	lds	r24, 0x02D7	; 0x8002d7 <uxDeletedTasksWaitingCleanUp>
 d3e:	81 50       	subi	r24, 0x01	; 1
 d40:	80 93 d7 02 	sts	0x02D7, r24	; 0x8002d7 <uxDeletedTasksWaitingCleanUp>
				}
				taskEXIT_CRITICAL();
 d44:	0f 90       	pop	r0
 d46:	0f be       	out	0x3f, r0	; 63

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
 d48:	8f 89       	ldd	r24, Y+23	; 0x17
 d4a:	98 8d       	ldd	r25, Y+24	; 0x18
 d4c:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <vPortFree>
			vPortFree( pxTCB );
 d50:	ce 01       	movw	r24, r28
 d52:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 d56:	80 91 d7 02 	lds	r24, 0x02D7	; 0x8002d7 <uxDeletedTasksWaitingCleanUp>
 d5a:	81 11       	cpse	r24, r1
 d5c:	d3 cf       	rjmp	.-90     	; 0xd04 <prvIdleTask+0x6>
 d5e:	fb cf       	rjmp	.-10     	; 0xd56 <prvIdleTask+0x58>

00000d60 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 d60:	80 91 c9 02 	lds	r24, 0x02C9	; 0x8002c9 <uxSchedulerSuspended>
 d64:	88 23       	and	r24, r24
 d66:	21 f0       	breq	.+8      	; 0xd70 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 d68:	81 e0       	ldi	r24, 0x01	; 1
 d6a:	80 93 d0 02 	sts	0x02D0, r24	; 0x8002d0 <xYieldPending>
 d6e:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
 d70:	10 92 d0 02 	sts	0x02D0, r1	; 0x8002d0 <xYieldPending>
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 d74:	20 91 d3 02 	lds	r18, 0x02D3	; 0x8002d3 <uxTopReadyPriority>
 d78:	82 2f       	mov	r24, r18
 d7a:	90 e0       	ldi	r25, 0x00	; 0
 d7c:	fc 01       	movw	r30, r24
 d7e:	ee 0f       	add	r30, r30
 d80:	ff 1f       	adc	r31, r31
 d82:	ee 0f       	add	r30, r30
 d84:	ff 1f       	adc	r31, r31
 d86:	ee 0f       	add	r30, r30
 d88:	ff 1f       	adc	r31, r31
 d8a:	e8 0f       	add	r30, r24
 d8c:	f9 1f       	adc	r31, r25
 d8e:	e0 50       	subi	r30, 0x00	; 0
 d90:	fd 4f       	sbci	r31, 0xFD	; 253
 d92:	30 81       	ld	r19, Z
 d94:	31 11       	cpse	r19, r1
 d96:	11 c0       	rjmp	.+34     	; 0xdba <vTaskSwitchContext+0x5a>
 d98:	21 50       	subi	r18, 0x01	; 1
 d9a:	82 2f       	mov	r24, r18
 d9c:	90 e0       	ldi	r25, 0x00	; 0
 d9e:	fc 01       	movw	r30, r24
 da0:	ee 0f       	add	r30, r30
 da2:	ff 1f       	adc	r31, r31
 da4:	ee 0f       	add	r30, r30
 da6:	ff 1f       	adc	r31, r31
 da8:	ee 0f       	add	r30, r30
 daa:	ff 1f       	adc	r31, r31
 dac:	e8 0f       	add	r30, r24
 dae:	f9 1f       	adc	r31, r25
 db0:	e0 50       	subi	r30, 0x00	; 0
 db2:	fd 4f       	sbci	r31, 0xFD	; 253
 db4:	30 81       	ld	r19, Z
 db6:	33 23       	and	r19, r19
 db8:	79 f3       	breq	.-34     	; 0xd98 <vTaskSwitchContext+0x38>
 dba:	ac 01       	movw	r20, r24
 dbc:	44 0f       	add	r20, r20
 dbe:	55 1f       	adc	r21, r21
 dc0:	44 0f       	add	r20, r20
 dc2:	55 1f       	adc	r21, r21
 dc4:	44 0f       	add	r20, r20
 dc6:	55 1f       	adc	r21, r21
 dc8:	48 0f       	add	r20, r24
 dca:	59 1f       	adc	r21, r25
 dcc:	da 01       	movw	r26, r20
 dce:	a0 50       	subi	r26, 0x00	; 0
 dd0:	bd 4f       	sbci	r27, 0xFD	; 253
 dd2:	11 96       	adiw	r26, 0x01	; 1
 dd4:	ed 91       	ld	r30, X+
 dd6:	fc 91       	ld	r31, X
 dd8:	12 97       	sbiw	r26, 0x02	; 2
 dda:	02 80       	ldd	r0, Z+2	; 0x02
 ddc:	f3 81       	ldd	r31, Z+3	; 0x03
 dde:	e0 2d       	mov	r30, r0
 de0:	12 96       	adiw	r26, 0x02	; 2
 de2:	fc 93       	st	X, r31
 de4:	ee 93       	st	-X, r30
 de6:	11 97       	sbiw	r26, 0x01	; 1
 de8:	4d 5f       	subi	r20, 0xFD	; 253
 dea:	5c 4f       	sbci	r21, 0xFC	; 252
 dec:	e4 17       	cp	r30, r20
 dee:	f5 07       	cpc	r31, r21
 df0:	29 f4       	brne	.+10     	; 0xdfc <vTaskSwitchContext+0x9c>
 df2:	42 81       	ldd	r20, Z+2	; 0x02
 df4:	53 81       	ldd	r21, Z+3	; 0x03
 df6:	fd 01       	movw	r30, r26
 df8:	52 83       	std	Z+2, r21	; 0x02
 dfa:	41 83       	std	Z+1, r20	; 0x01
 dfc:	fc 01       	movw	r30, r24
 dfe:	ee 0f       	add	r30, r30
 e00:	ff 1f       	adc	r31, r31
 e02:	ee 0f       	add	r30, r30
 e04:	ff 1f       	adc	r31, r31
 e06:	ee 0f       	add	r30, r30
 e08:	ff 1f       	adc	r31, r31
 e0a:	8e 0f       	add	r24, r30
 e0c:	9f 1f       	adc	r25, r31
 e0e:	fc 01       	movw	r30, r24
 e10:	e0 50       	subi	r30, 0x00	; 0
 e12:	fd 4f       	sbci	r31, 0xFD	; 253
 e14:	01 80       	ldd	r0, Z+1	; 0x01
 e16:	f2 81       	ldd	r31, Z+2	; 0x02
 e18:	e0 2d       	mov	r30, r0
 e1a:	86 81       	ldd	r24, Z+6	; 0x06
 e1c:	97 81       	ldd	r25, Z+7	; 0x07
 e1e:	90 93 25 03 	sts	0x0325, r25	; 0x800325 <pxCurrentTCB+0x1>
 e22:	80 93 24 03 	sts	0x0324, r24	; 0x800324 <pxCurrentTCB>
 e26:	20 93 d3 02 	sts	0x02D3, r18	; 0x8002d3 <uxTopReadyPriority>
 e2a:	08 95       	ret

00000e2c <_exit>:
 e2c:	f8 94       	cli

00000e2e <__stop_program>:
 e2e:	ff cf       	rjmp	.-2      	; 0xe2e <__stop_program>
