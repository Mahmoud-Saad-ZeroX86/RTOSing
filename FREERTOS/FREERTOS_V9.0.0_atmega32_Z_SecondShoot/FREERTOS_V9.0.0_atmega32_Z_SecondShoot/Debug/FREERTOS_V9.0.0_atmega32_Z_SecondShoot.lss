
FREERTOS_V9.0.0_atmega32_Z_SecondShoot.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000013a0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000008  00800060  000013a0  00001434  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002a4  00800068  00800068  0000143c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000143c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000146c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000290  00000000  00000000  000014a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003616  00000000  00000000  00001738  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000f2a  00000000  00000000  00004d4e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001c7f  00000000  00000000  00005c78  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000007ec  00000000  00000000  000078f8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000115b  00000000  00000000  000080e4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000033d8  00000000  00000000  0000923f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000002d8  00000000  00000000  0000c617  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 74 03 	jmp	0x6e8	; 0x6e8 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e0 ea       	ldi	r30, 0xA0	; 160
      68:	f3 e1       	ldi	r31, 0x13	; 19
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a8 36       	cpi	r26, 0x68	; 104
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	23 e0       	ldi	r18, 0x03	; 3
      78:	a8 e6       	ldi	r26, 0x68	; 104
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ac 30       	cpi	r26, 0x0C	; 12
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 e1 01 	call	0x3c2	; 0x3c2 <main>
      8a:	0c 94 ce 09 	jmp	0x139c	; 0x139c <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
      92:	0f 93       	push	r16
      94:	1f 93       	push	r17
      96:	cf 93       	push	r28
      98:	df 93       	push	r29
      9a:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
      9c:	0e 94 70 07 	call	0xee0	; 0xee0 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
      a0:	80 91 68 00 	lds	r24, 0x0068	; 0x800068 <__data_end>
      a4:	81 11       	cpse	r24, r1
      a6:	1d c0       	rjmp	.+58     	; 0xe2 <pvPortMalloc+0x50>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
      a8:	ed e6       	ldi	r30, 0x6D	; 109
      aa:	f0 e0       	ldi	r31, 0x00	; 0
      ac:	82 e7       	ldi	r24, 0x72	; 114
      ae:	90 e0       	ldi	r25, 0x00	; 0
      b0:	91 83       	std	Z+1, r25	; 0x01
      b2:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
      b4:	13 82       	std	Z+3, r1	; 0x03
      b6:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
      b8:	e9 e6       	ldi	r30, 0x69	; 105
      ba:	f0 e0       	ldi	r31, 0x00	; 0
      bc:	87 e5       	ldi	r24, 0x57	; 87
      be:	92 e0       	ldi	r25, 0x02	; 2
      c0:	93 83       	std	Z+3, r25	; 0x03
      c2:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
      c4:	11 82       	std	Z+1, r1	; 0x01
      c6:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
      c8:	a1 e7       	ldi	r26, 0x71	; 113
      ca:	b0 e0       	ldi	r27, 0x00	; 0
      cc:	14 96       	adiw	r26, 0x04	; 4
      ce:	9c 93       	st	X, r25
      d0:	8e 93       	st	-X, r24
      d2:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
      d4:	12 96       	adiw	r26, 0x02	; 2
      d6:	fc 93       	st	X, r31
      d8:	ee 93       	st	-X, r30
      da:	11 97       	sbiw	r26, 0x01	; 1
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
      dc:	81 e0       	ldi	r24, 0x01	; 1
      de:	80 93 68 00 	sts	0x0068, r24	; 0x800068 <__data_end>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
      e2:	20 97       	sbiw	r28, 0x00	; 0
      e4:	09 f4       	brne	.+2      	; 0xe8 <pvPortMalloc+0x56>
      e6:	5f c0       	rjmp	.+190    	; 0x1a6 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
      e8:	9e 01       	movw	r18, r28
      ea:	2c 5f       	subi	r18, 0xFC	; 252
      ec:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
      ee:	23 96       	adiw	r28, 0x03	; 3
      f0:	c6 35       	cpi	r28, 0x56	; 86
      f2:	d2 40       	sbci	r29, 0x02	; 2
      f4:	08 f0       	brcs	.+2      	; 0xf8 <pvPortMalloc+0x66>
      f6:	5a c0       	rjmp	.+180    	; 0x1ac <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
      f8:	e0 91 6d 00 	lds	r30, 0x006D	; 0x80006d <xStart>
      fc:	f0 91 6e 00 	lds	r31, 0x006E	; 0x80006e <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     100:	ad e6       	ldi	r26, 0x6D	; 109
     102:	b0 e0       	ldi	r27, 0x00	; 0
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     104:	02 c0       	rjmp	.+4      	; 0x10a <pvPortMalloc+0x78>
     106:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     108:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     10a:	82 81       	ldd	r24, Z+2	; 0x02
     10c:	93 81       	ldd	r25, Z+3	; 0x03
     10e:	82 17       	cp	r24, r18
     110:	93 07       	cpc	r25, r19
     112:	20 f4       	brcc	.+8      	; 0x11c <pvPortMalloc+0x8a>
     114:	80 81       	ld	r24, Z
     116:	91 81       	ldd	r25, Z+1	; 0x01
     118:	00 97       	sbiw	r24, 0x00	; 0
     11a:	a9 f7       	brne	.-22     	; 0x106 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     11c:	c0 e0       	ldi	r28, 0x00	; 0
     11e:	e9 36       	cpi	r30, 0x69	; 105
     120:	fc 07       	cpc	r31, r28
     122:	09 f4       	brne	.+2      	; 0x126 <pvPortMalloc+0x94>
     124:	46 c0       	rjmp	.+140    	; 0x1b2 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     126:	cd 91       	ld	r28, X+
     128:	dc 91       	ld	r29, X
     12a:	11 97       	sbiw	r26, 0x01	; 1
     12c:	8e 01       	movw	r16, r28
     12e:	0c 5f       	subi	r16, 0xFC	; 252
     130:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     132:	80 81       	ld	r24, Z
     134:	91 81       	ldd	r25, Z+1	; 0x01
     136:	8d 93       	st	X+, r24
     138:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     13a:	82 81       	ldd	r24, Z+2	; 0x02
     13c:	93 81       	ldd	r25, Z+3	; 0x03
     13e:	82 1b       	sub	r24, r18
     140:	93 0b       	sbc	r25, r19
     142:	89 30       	cpi	r24, 0x09	; 9
     144:	91 05       	cpc	r25, r1
     146:	10 f1       	brcs	.+68     	; 0x18c <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     148:	bf 01       	movw	r22, r30
     14a:	62 0f       	add	r22, r18
     14c:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     14e:	db 01       	movw	r26, r22
     150:	13 96       	adiw	r26, 0x03	; 3
     152:	9c 93       	st	X, r25
     154:	8e 93       	st	-X, r24
     156:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     158:	33 83       	std	Z+3, r19	; 0x03
     15a:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     15c:	12 96       	adiw	r26, 0x02	; 2
     15e:	4d 91       	ld	r20, X+
     160:	5c 91       	ld	r21, X
     162:	13 97       	sbiw	r26, 0x03	; 3
     164:	8d e6       	ldi	r24, 0x6D	; 109
     166:	90 e0       	ldi	r25, 0x00	; 0
     168:	01 c0       	rjmp	.+2      	; 0x16c <pvPortMalloc+0xda>
     16a:	cd 01       	movw	r24, r26
     16c:	ec 01       	movw	r28, r24
     16e:	a8 81       	ld	r26, Y
     170:	b9 81       	ldd	r27, Y+1	; 0x01
     172:	12 96       	adiw	r26, 0x02	; 2
     174:	2d 91       	ld	r18, X+
     176:	3c 91       	ld	r19, X
     178:	13 97       	sbiw	r26, 0x03	; 3
     17a:	24 17       	cp	r18, r20
     17c:	35 07       	cpc	r19, r21
     17e:	a8 f3       	brcs	.-22     	; 0x16a <pvPortMalloc+0xd8>
     180:	eb 01       	movw	r28, r22
     182:	b9 83       	std	Y+1, r27	; 0x01
     184:	a8 83       	st	Y, r26
     186:	dc 01       	movw	r26, r24
     188:	6d 93       	st	X+, r22
     18a:	7c 93       	st	X, r23
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     18c:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
     190:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__data_start+0x1>
     194:	22 81       	ldd	r18, Z+2	; 0x02
     196:	33 81       	ldd	r19, Z+3	; 0x03
     198:	82 1b       	sub	r24, r18
     19a:	93 0b       	sbc	r25, r19
     19c:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
     1a0:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
     1a4:	08 c0       	rjmp	.+16     	; 0x1b6 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     1a6:	00 e0       	ldi	r16, 0x00	; 0
     1a8:	10 e0       	ldi	r17, 0x00	; 0
     1aa:	05 c0       	rjmp	.+10     	; 0x1b6 <pvPortMalloc+0x124>
     1ac:	00 e0       	ldi	r16, 0x00	; 0
     1ae:	10 e0       	ldi	r17, 0x00	; 0
     1b0:	02 c0       	rjmp	.+4      	; 0x1b6 <pvPortMalloc+0x124>
     1b2:	00 e0       	ldi	r16, 0x00	; 0
     1b4:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     1b6:	0e 94 31 08 	call	0x1062	; 0x1062 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     1ba:	c8 01       	movw	r24, r16
     1bc:	df 91       	pop	r29
     1be:	cf 91       	pop	r28
     1c0:	1f 91       	pop	r17
     1c2:	0f 91       	pop	r16
     1c4:	08 95       	ret

000001c6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     1c6:	0f 93       	push	r16
     1c8:	1f 93       	push	r17
     1ca:	cf 93       	push	r28
     1cc:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     1ce:	00 97       	sbiw	r24, 0x00	; 0
     1d0:	41 f1       	breq	.+80     	; 0x222 <vPortFree+0x5c>
     1d2:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     1d4:	8c 01       	movw	r16, r24
     1d6:	04 50       	subi	r16, 0x04	; 4
     1d8:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     1da:	0e 94 70 07 	call	0xee0	; 0xee0 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     1de:	f8 01       	movw	r30, r16
     1e0:	42 81       	ldd	r20, Z+2	; 0x02
     1e2:	53 81       	ldd	r21, Z+3	; 0x03
     1e4:	ad e6       	ldi	r26, 0x6D	; 109
     1e6:	b0 e0       	ldi	r27, 0x00	; 0
     1e8:	01 c0       	rjmp	.+2      	; 0x1ec <vPortFree+0x26>
     1ea:	df 01       	movw	r26, r30
     1ec:	ed 91       	ld	r30, X+
     1ee:	fc 91       	ld	r31, X
     1f0:	11 97       	sbiw	r26, 0x01	; 1
     1f2:	22 81       	ldd	r18, Z+2	; 0x02
     1f4:	33 81       	ldd	r19, Z+3	; 0x03
     1f6:	24 17       	cp	r18, r20
     1f8:	35 07       	cpc	r19, r21
     1fa:	b8 f3       	brcs	.-18     	; 0x1ea <vPortFree+0x24>
     1fc:	24 97       	sbiw	r28, 0x04	; 4
     1fe:	f9 83       	std	Y+1, r31	; 0x01
     200:	e8 83       	st	Y, r30
     202:	0d 93       	st	X+, r16
     204:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     206:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <__data_start>
     20a:	30 91 61 00 	lds	r19, 0x0061	; 0x800061 <__data_start+0x1>
     20e:	8a 81       	ldd	r24, Y+2	; 0x02
     210:	9b 81       	ldd	r25, Y+3	; 0x03
     212:	82 0f       	add	r24, r18
     214:	93 1f       	adc	r25, r19
     216:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
     21a:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     21e:	0e 94 31 08 	call	0x1062	; 0x1062 <xTaskResumeAll>
	}
}
     222:	df 91       	pop	r29
     224:	cf 91       	pop	r28
     226:	1f 91       	pop	r17
     228:	0f 91       	pop	r16
     22a:	08 95       	ret

0000022c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     22c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     22e:	03 96       	adiw	r24, 0x03	; 3
     230:	92 83       	std	Z+2, r25	; 0x02
     232:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     234:	2f ef       	ldi	r18, 0xFF	; 255
     236:	3f ef       	ldi	r19, 0xFF	; 255
     238:	34 83       	std	Z+4, r19	; 0x04
     23a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     23c:	96 83       	std	Z+6, r25	; 0x06
     23e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     240:	90 87       	std	Z+8, r25	; 0x08
     242:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     244:	10 82       	st	Z, r1
     246:	08 95       	ret

00000248 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     248:	fc 01       	movw	r30, r24
     24a:	11 86       	std	Z+9, r1	; 0x09
     24c:	10 86       	std	Z+8, r1	; 0x08
     24e:	08 95       	ret

00000250 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     250:	cf 93       	push	r28
     252:	df 93       	push	r29
     254:	9c 01       	movw	r18, r24
     256:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     258:	dc 01       	movw	r26, r24
     25a:	11 96       	adiw	r26, 0x01	; 1
     25c:	cd 91       	ld	r28, X+
     25e:	dc 91       	ld	r29, X
     260:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     262:	d3 83       	std	Z+3, r29	; 0x03
     264:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     266:	8c 81       	ldd	r24, Y+4	; 0x04
     268:	9d 81       	ldd	r25, Y+5	; 0x05
     26a:	95 83       	std	Z+5, r25	; 0x05
     26c:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     26e:	8c 81       	ldd	r24, Y+4	; 0x04
     270:	9d 81       	ldd	r25, Y+5	; 0x05
     272:	dc 01       	movw	r26, r24
     274:	13 96       	adiw	r26, 0x03	; 3
     276:	7c 93       	st	X, r23
     278:	6e 93       	st	-X, r22
     27a:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     27c:	7d 83       	std	Y+5, r23	; 0x05
     27e:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     280:	31 87       	std	Z+9, r19	; 0x09
     282:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     284:	f9 01       	movw	r30, r18
     286:	80 81       	ld	r24, Z
     288:	8f 5f       	subi	r24, 0xFF	; 255
     28a:	80 83       	st	Z, r24
}
     28c:	df 91       	pop	r29
     28e:	cf 91       	pop	r28
     290:	08 95       	ret

00000292 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     292:	cf 93       	push	r28
     294:	df 93       	push	r29
     296:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     298:	48 81       	ld	r20, Y
     29a:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     29c:	4f 3f       	cpi	r20, 0xFF	; 255
     29e:	2f ef       	ldi	r18, 0xFF	; 255
     2a0:	52 07       	cpc	r21, r18
     2a2:	21 f4       	brne	.+8      	; 0x2ac <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     2a4:	fc 01       	movw	r30, r24
     2a6:	a7 81       	ldd	r26, Z+7	; 0x07
     2a8:	b0 85       	ldd	r27, Z+8	; 0x08
     2aa:	0d c0       	rjmp	.+26     	; 0x2c6 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     2ac:	dc 01       	movw	r26, r24
     2ae:	13 96       	adiw	r26, 0x03	; 3
     2b0:	01 c0       	rjmp	.+2      	; 0x2b4 <vListInsert+0x22>
     2b2:	df 01       	movw	r26, r30
     2b4:	12 96       	adiw	r26, 0x02	; 2
     2b6:	ed 91       	ld	r30, X+
     2b8:	fc 91       	ld	r31, X
     2ba:	13 97       	sbiw	r26, 0x03	; 3
     2bc:	20 81       	ld	r18, Z
     2be:	31 81       	ldd	r19, Z+1	; 0x01
     2c0:	42 17       	cp	r20, r18
     2c2:	53 07       	cpc	r21, r19
     2c4:	b0 f7       	brcc	.-20     	; 0x2b2 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     2c6:	12 96       	adiw	r26, 0x02	; 2
     2c8:	ed 91       	ld	r30, X+
     2ca:	fc 91       	ld	r31, X
     2cc:	13 97       	sbiw	r26, 0x03	; 3
     2ce:	fb 83       	std	Y+3, r31	; 0x03
     2d0:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     2d2:	d5 83       	std	Z+5, r29	; 0x05
     2d4:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     2d6:	bd 83       	std	Y+5, r27	; 0x05
     2d8:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     2da:	13 96       	adiw	r26, 0x03	; 3
     2dc:	dc 93       	st	X, r29
     2de:	ce 93       	st	-X, r28
     2e0:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     2e2:	99 87       	std	Y+9, r25	; 0x09
     2e4:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     2e6:	fc 01       	movw	r30, r24
     2e8:	20 81       	ld	r18, Z
     2ea:	2f 5f       	subi	r18, 0xFF	; 255
     2ec:	20 83       	st	Z, r18
}
     2ee:	df 91       	pop	r29
     2f0:	cf 91       	pop	r28
     2f2:	08 95       	ret

000002f4 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     2f4:	cf 93       	push	r28
     2f6:	df 93       	push	r29
     2f8:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     2fa:	a0 85       	ldd	r26, Z+8	; 0x08
     2fc:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     2fe:	c2 81       	ldd	r28, Z+2	; 0x02
     300:	d3 81       	ldd	r29, Z+3	; 0x03
     302:	84 81       	ldd	r24, Z+4	; 0x04
     304:	95 81       	ldd	r25, Z+5	; 0x05
     306:	9d 83       	std	Y+5, r25	; 0x05
     308:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     30a:	c4 81       	ldd	r28, Z+4	; 0x04
     30c:	d5 81       	ldd	r29, Z+5	; 0x05
     30e:	82 81       	ldd	r24, Z+2	; 0x02
     310:	93 81       	ldd	r25, Z+3	; 0x03
     312:	9b 83       	std	Y+3, r25	; 0x03
     314:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     316:	11 96       	adiw	r26, 0x01	; 1
     318:	8d 91       	ld	r24, X+
     31a:	9c 91       	ld	r25, X
     31c:	12 97       	sbiw	r26, 0x02	; 2
     31e:	e8 17       	cp	r30, r24
     320:	f9 07       	cpc	r31, r25
     322:	31 f4       	brne	.+12     	; 0x330 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     324:	84 81       	ldd	r24, Z+4	; 0x04
     326:	95 81       	ldd	r25, Z+5	; 0x05
     328:	12 96       	adiw	r26, 0x02	; 2
     32a:	9c 93       	st	X, r25
     32c:	8e 93       	st	-X, r24
     32e:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     330:	11 86       	std	Z+9, r1	; 0x09
     332:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     334:	8c 91       	ld	r24, X
     336:	81 50       	subi	r24, 0x01	; 1
     338:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     33a:	df 91       	pop	r29
     33c:	cf 91       	pop	r28
     33e:	08 95       	ret

00000340 <task1>:
	//	PORTA=PORTB=PORTC=PORTD=0x55;
//	}
	
}
void task1(void * pv)
{
     340:	cf 93       	push	r28
     342:	df 93       	push	r29
     344:	1f 92       	push	r1
     346:	cd b7       	in	r28, 0x3d	; 61
     348:	de b7       	in	r29, 0x3e	; 62
	char loc_val=(char)pv;
     34a:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		PORTC ^=(1<<1);
     34c:	12 e0       	ldi	r17, 0x02	; 2
		PORTA=loc_val;
		portBASE_TYPE stat= xQueueSendToBack(queue_1_handle,&loc_val,10);
		loc_val++;
		if (stat==pdFAIL)
		{
			PORTA=0xff;
     34e:	0f ef       	ldi	r16, 0xFF	; 255
void task1(void * pv)
{
	char loc_val=(char)pv;
	while(1)
	{
		PORTC ^=(1<<1);
     350:	85 b3       	in	r24, 0x15	; 21
     352:	81 27       	eor	r24, r17
     354:	85 bb       	out	0x15, r24	; 21
		PORTA=loc_val;
     356:	89 81       	ldd	r24, Y+1	; 0x01
     358:	8b bb       	out	0x1b, r24	; 27
		portBASE_TYPE stat= xQueueSendToBack(queue_1_handle,&loc_val,10);
     35a:	20 e0       	ldi	r18, 0x00	; 0
     35c:	4a e0       	ldi	r20, 0x0A	; 10
     35e:	50 e0       	ldi	r21, 0x00	; 0
     360:	be 01       	movw	r22, r28
     362:	6f 5f       	subi	r22, 0xFF	; 255
     364:	7f 4f       	sbci	r23, 0xFF	; 255
     366:	80 91 0a 03 	lds	r24, 0x030A	; 0x80030a <queue_1_handle>
     36a:	90 91 0b 03 	lds	r25, 0x030B	; 0x80030b <queue_1_handle+0x1>
     36e:	0e 94 91 04 	call	0x922	; 0x922 <xQueueGenericSend>
		loc_val++;
     372:	99 81       	ldd	r25, Y+1	; 0x01
     374:	9f 5f       	subi	r25, 0xFF	; 255
     376:	99 83       	std	Y+1, r25	; 0x01
		if (stat==pdFAIL)
     378:	81 11       	cpse	r24, r1
     37a:	01 c0       	rjmp	.+2      	; 0x37e <task1+0x3e>
		{
			PORTA=0xff;
     37c:	0b bb       	out	0x1b, r16	; 27
		}
		vTaskDelay(100);
     37e:	84 e6       	ldi	r24, 0x64	; 100
     380:	90 e0       	ldi	r25, 0x00	; 0
     382:	0e 94 b0 08 	call	0x1160	; 0x1160 <vTaskDelay>
	}
     386:	e4 cf       	rjmp	.-56     	; 0x350 <task1+0x10>

00000388 <task2>:
}

void task2(void * pv)
{
     388:	cf 93       	push	r28
     38a:	df 93       	push	r29
     38c:	1f 92       	push	r1
     38e:	cd b7       	in	r28, 0x3d	; 61
     390:	de b7       	in	r29, 0x3e	; 62
	portBASE_TYPE rx_buff=0;
     392:	19 82       	std	Y+1, r1	; 0x01
	while(1)
	{
		PORTC ^=(1<<2);
     394:	14 e0       	ldi	r17, 0x04	; 4
     396:	85 b3       	in	r24, 0x15	; 21
     398:	81 27       	eor	r24, r17
     39a:	85 bb       	out	0x15, r24	; 21
		xQueueReceive(queue_1_handle,&rx_buff,10);
     39c:	20 e0       	ldi	r18, 0x00	; 0
     39e:	4a e0       	ldi	r20, 0x0A	; 10
     3a0:	50 e0       	ldi	r21, 0x00	; 0
     3a2:	be 01       	movw	r22, r28
     3a4:	6f 5f       	subi	r22, 0xFF	; 255
     3a6:	7f 4f       	sbci	r23, 0xFF	; 255
     3a8:	80 91 0a 03 	lds	r24, 0x030A	; 0x80030a <queue_1_handle>
     3ac:	90 91 0b 03 	lds	r25, 0x030B	; 0x80030b <queue_1_handle+0x1>
     3b0:	0e 94 32 05 	call	0xa64	; 0xa64 <xQueueGenericReceive>
		PORTB= rx_buff;
     3b4:	89 81       	ldd	r24, Y+1	; 0x01
     3b6:	88 bb       	out	0x18, r24	; 24
		vTaskDelay(100);
     3b8:	84 e6       	ldi	r24, 0x64	; 100
     3ba:	90 e0       	ldi	r25, 0x00	; 0
     3bc:	0e 94 b0 08 	call	0x1160	; 0x1160 <vTaskDelay>
     3c0:	ea cf       	rjmp	.-44     	; 0x396 <task2+0xe>

000003c2 <main>:

void task1(void * pv);
void task2(void * pv);
	xQueueHandle queue_1_handle;
void main(void)
{
     3c2:	ef 92       	push	r14
     3c4:	ff 92       	push	r15
     3c6:	0f 93       	push	r16
     3c8:	cf 93       	push	r28
     3ca:	df 93       	push	r29
     3cc:	1f 92       	push	r1
     3ce:	cd b7       	in	r28, 0x3d	; 61
     3d0:	de b7       	in	r29, 0x3e	; 62
	DDRA=0xff;		DDRB=0xff;		DDRC=0xff;		DDRD=0xff;
     3d2:	8f ef       	ldi	r24, 0xFF	; 255
     3d4:	8a bb       	out	0x1a, r24	; 26
     3d6:	87 bb       	out	0x17, r24	; 23
     3d8:	84 bb       	out	0x14, r24	; 20
     3da:	81 bb       	out	0x11, r24	; 17
	char msa=0xff;
     3dc:	89 83       	std	Y+1, r24	; 0x01
	queue_1_handle=xQueueCreate( 2,sizeof(int));
     3de:	40 e0       	ldi	r20, 0x00	; 0
     3e0:	62 e0       	ldi	r22, 0x02	; 2
     3e2:	82 e0       	ldi	r24, 0x02	; 2
     3e4:	0e 94 64 04 	call	0x8c8	; 0x8c8 <xQueueGenericCreate>
     3e8:	90 93 0b 03 	sts	0x030B, r25	; 0x80030b <queue_1_handle+0x1>
     3ec:	80 93 0a 03 	sts	0x030A, r24	; 0x80030a <queue_1_handle>
	if (queue_1_handle == NULL)
     3f0:	89 2b       	or	r24, r25
     3f2:	11 f4       	brne	.+4      	; 0x3f8 <main+0x36>
		PORTD=0xff;
     3f4:	8f ef       	ldi	r24, 0xFF	; 255
     3f6:	82 bb       	out	0x12, r24	; 18
	//{
		
		xTaskCreate(task1,NULL,configMINIMAL_STACK_SIZE,(void *)&msa,1,NULL);
     3f8:	e1 2c       	mov	r14, r1
     3fa:	f1 2c       	mov	r15, r1
     3fc:	01 e0       	ldi	r16, 0x01	; 1
     3fe:	9e 01       	movw	r18, r28
     400:	2f 5f       	subi	r18, 0xFF	; 255
     402:	3f 4f       	sbci	r19, 0xFF	; 255
     404:	44 e6       	ldi	r20, 0x64	; 100
     406:	50 e0       	ldi	r21, 0x00	; 0
     408:	60 e0       	ldi	r22, 0x00	; 0
     40a:	70 e0       	ldi	r23, 0x00	; 0
     40c:	80 ea       	ldi	r24, 0xA0	; 160
     40e:	91 e0       	ldi	r25, 0x01	; 1
     410:	0e 94 4b 06 	call	0xc96	; 0xc96 <xTaskCreate>
		xTaskCreate(task2,NULL,configMINIMAL_STACK_SIZE,(void *)&msa,1,NULL);
     414:	9e 01       	movw	r18, r28
     416:	2f 5f       	subi	r18, 0xFF	; 255
     418:	3f 4f       	sbci	r19, 0xFF	; 255
     41a:	44 e6       	ldi	r20, 0x64	; 100
     41c:	50 e0       	ldi	r21, 0x00	; 0
     41e:	60 e0       	ldi	r22, 0x00	; 0
     420:	70 e0       	ldi	r23, 0x00	; 0
     422:	84 ec       	ldi	r24, 0xC4	; 196
     424:	91 e0       	ldi	r25, 0x01	; 1
     426:	0e 94 4b 06 	call	0xc96	; 0xc96 <xTaskCreate>
		
		vTaskStartScheduler();
     42a:	0e 94 46 07 	call	0xe8c	; 0xe8c <vTaskStartScheduler>
	//else //couldn't create a queue
	//{
	//	PORTA=PORTB=PORTC=PORTD=0x55;
//	}
	
}
     42e:	0f 90       	pop	r0
     430:	df 91       	pop	r29
     432:	cf 91       	pop	r28
     434:	0f 91       	pop	r16
     436:	ff 90       	pop	r15
     438:	ef 90       	pop	r14
     43a:	08 95       	ret

0000043c <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     43c:	31 e1       	ldi	r19, 0x11	; 17
     43e:	fc 01       	movw	r30, r24
     440:	30 83       	st	Z, r19
     442:	31 97       	sbiw	r30, 0x01	; 1
     444:	22 e2       	ldi	r18, 0x22	; 34
     446:	20 83       	st	Z, r18
     448:	31 97       	sbiw	r30, 0x01	; 1
     44a:	a3 e3       	ldi	r26, 0x33	; 51
     44c:	a0 83       	st	Z, r26
     44e:	31 97       	sbiw	r30, 0x01	; 1
     450:	60 83       	st	Z, r22
     452:	31 97       	sbiw	r30, 0x01	; 1
     454:	70 83       	st	Z, r23
     456:	31 97       	sbiw	r30, 0x01	; 1
     458:	10 82       	st	Z, r1
     45a:	31 97       	sbiw	r30, 0x01	; 1
     45c:	60 e8       	ldi	r22, 0x80	; 128
     45e:	60 83       	st	Z, r22
     460:	31 97       	sbiw	r30, 0x01	; 1
     462:	10 82       	st	Z, r1
     464:	31 97       	sbiw	r30, 0x01	; 1
     466:	62 e0       	ldi	r22, 0x02	; 2
     468:	60 83       	st	Z, r22
     46a:	31 97       	sbiw	r30, 0x01	; 1
     46c:	63 e0       	ldi	r22, 0x03	; 3
     46e:	60 83       	st	Z, r22
     470:	31 97       	sbiw	r30, 0x01	; 1
     472:	64 e0       	ldi	r22, 0x04	; 4
     474:	60 83       	st	Z, r22
     476:	31 97       	sbiw	r30, 0x01	; 1
     478:	65 e0       	ldi	r22, 0x05	; 5
     47a:	60 83       	st	Z, r22
     47c:	31 97       	sbiw	r30, 0x01	; 1
     47e:	66 e0       	ldi	r22, 0x06	; 6
     480:	60 83       	st	Z, r22
     482:	31 97       	sbiw	r30, 0x01	; 1
     484:	67 e0       	ldi	r22, 0x07	; 7
     486:	60 83       	st	Z, r22
     488:	31 97       	sbiw	r30, 0x01	; 1
     48a:	68 e0       	ldi	r22, 0x08	; 8
     48c:	60 83       	st	Z, r22
     48e:	31 97       	sbiw	r30, 0x01	; 1
     490:	69 e0       	ldi	r22, 0x09	; 9
     492:	60 83       	st	Z, r22
     494:	31 97       	sbiw	r30, 0x01	; 1
     496:	60 e1       	ldi	r22, 0x10	; 16
     498:	60 83       	st	Z, r22
     49a:	31 97       	sbiw	r30, 0x01	; 1
     49c:	30 83       	st	Z, r19
     49e:	31 97       	sbiw	r30, 0x01	; 1
     4a0:	32 e1       	ldi	r19, 0x12	; 18
     4a2:	30 83       	st	Z, r19
     4a4:	31 97       	sbiw	r30, 0x01	; 1
     4a6:	33 e1       	ldi	r19, 0x13	; 19
     4a8:	30 83       	st	Z, r19
     4aa:	31 97       	sbiw	r30, 0x01	; 1
     4ac:	34 e1       	ldi	r19, 0x14	; 20
     4ae:	30 83       	st	Z, r19
     4b0:	31 97       	sbiw	r30, 0x01	; 1
     4b2:	35 e1       	ldi	r19, 0x15	; 21
     4b4:	30 83       	st	Z, r19
     4b6:	31 97       	sbiw	r30, 0x01	; 1
     4b8:	36 e1       	ldi	r19, 0x16	; 22
     4ba:	30 83       	st	Z, r19
     4bc:	31 97       	sbiw	r30, 0x01	; 1
     4be:	37 e1       	ldi	r19, 0x17	; 23
     4c0:	30 83       	st	Z, r19
     4c2:	31 97       	sbiw	r30, 0x01	; 1
     4c4:	38 e1       	ldi	r19, 0x18	; 24
     4c6:	30 83       	st	Z, r19
     4c8:	31 97       	sbiw	r30, 0x01	; 1
     4ca:	39 e1       	ldi	r19, 0x19	; 25
     4cc:	30 83       	st	Z, r19
     4ce:	31 97       	sbiw	r30, 0x01	; 1
     4d0:	30 e2       	ldi	r19, 0x20	; 32
     4d2:	30 83       	st	Z, r19
     4d4:	31 97       	sbiw	r30, 0x01	; 1
     4d6:	31 e2       	ldi	r19, 0x21	; 33
     4d8:	30 83       	st	Z, r19
     4da:	31 97       	sbiw	r30, 0x01	; 1
     4dc:	20 83       	st	Z, r18
     4de:	31 97       	sbiw	r30, 0x01	; 1
     4e0:	23 e2       	ldi	r18, 0x23	; 35
     4e2:	20 83       	st	Z, r18
     4e4:	31 97       	sbiw	r30, 0x01	; 1
     4e6:	40 83       	st	Z, r20
     4e8:	31 97       	sbiw	r30, 0x01	; 1
     4ea:	50 83       	st	Z, r21
     4ec:	31 97       	sbiw	r30, 0x01	; 1
     4ee:	26 e2       	ldi	r18, 0x26	; 38
     4f0:	20 83       	st	Z, r18
     4f2:	31 97       	sbiw	r30, 0x01	; 1
     4f4:	27 e2       	ldi	r18, 0x27	; 39
     4f6:	20 83       	st	Z, r18
     4f8:	31 97       	sbiw	r30, 0x01	; 1
     4fa:	28 e2       	ldi	r18, 0x28	; 40
     4fc:	20 83       	st	Z, r18
     4fe:	31 97       	sbiw	r30, 0x01	; 1
     500:	29 e2       	ldi	r18, 0x29	; 41
     502:	20 83       	st	Z, r18
     504:	31 97       	sbiw	r30, 0x01	; 1
     506:	20 e3       	ldi	r18, 0x30	; 48
     508:	20 83       	st	Z, r18
     50a:	31 97       	sbiw	r30, 0x01	; 1
     50c:	21 e3       	ldi	r18, 0x31	; 49
     50e:	20 83       	st	Z, r18
     510:	86 97       	sbiw	r24, 0x26	; 38
     512:	08 95       	ret

00000514 <xPortStartScheduler>:
     514:	1b bc       	out	0x2b, r1	; 43
     516:	8c e7       	ldi	r24, 0x7C	; 124
     518:	8a bd       	out	0x2a, r24	; 42
     51a:	8b e0       	ldi	r24, 0x0B	; 11
     51c:	8e bd       	out	0x2e, r24	; 46
     51e:	89 b7       	in	r24, 0x39	; 57
     520:	80 61       	ori	r24, 0x10	; 16
     522:	89 bf       	out	0x39, r24	; 57
     524:	a0 91 08 03 	lds	r26, 0x0308	; 0x800308 <pxCurrentTCB>
     528:	b0 91 09 03 	lds	r27, 0x0309	; 0x800309 <pxCurrentTCB+0x1>
     52c:	cd 91       	ld	r28, X+
     52e:	cd bf       	out	0x3d, r28	; 61
     530:	dd 91       	ld	r29, X+
     532:	de bf       	out	0x3e, r29	; 62
     534:	ff 91       	pop	r31
     536:	ef 91       	pop	r30
     538:	df 91       	pop	r29
     53a:	cf 91       	pop	r28
     53c:	bf 91       	pop	r27
     53e:	af 91       	pop	r26
     540:	9f 91       	pop	r25
     542:	8f 91       	pop	r24
     544:	7f 91       	pop	r23
     546:	6f 91       	pop	r22
     548:	5f 91       	pop	r21
     54a:	4f 91       	pop	r20
     54c:	3f 91       	pop	r19
     54e:	2f 91       	pop	r18
     550:	1f 91       	pop	r17
     552:	0f 91       	pop	r16
     554:	ff 90       	pop	r15
     556:	ef 90       	pop	r14
     558:	df 90       	pop	r13
     55a:	cf 90       	pop	r12
     55c:	bf 90       	pop	r11
     55e:	af 90       	pop	r10
     560:	9f 90       	pop	r9
     562:	8f 90       	pop	r8
     564:	7f 90       	pop	r7
     566:	6f 90       	pop	r6
     568:	5f 90       	pop	r5
     56a:	4f 90       	pop	r4
     56c:	3f 90       	pop	r3
     56e:	2f 90       	pop	r2
     570:	1f 90       	pop	r1
     572:	0f 90       	pop	r0
     574:	0f be       	out	0x3f, r0	; 63
     576:	0f 90       	pop	r0
     578:	08 95       	ret
     57a:	81 e0       	ldi	r24, 0x01	; 1
     57c:	08 95       	ret

0000057e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     57e:	0f 92       	push	r0
     580:	0f b6       	in	r0, 0x3f	; 63
     582:	f8 94       	cli
     584:	0f 92       	push	r0
     586:	1f 92       	push	r1
     588:	11 24       	eor	r1, r1
     58a:	2f 92       	push	r2
     58c:	3f 92       	push	r3
     58e:	4f 92       	push	r4
     590:	5f 92       	push	r5
     592:	6f 92       	push	r6
     594:	7f 92       	push	r7
     596:	8f 92       	push	r8
     598:	9f 92       	push	r9
     59a:	af 92       	push	r10
     59c:	bf 92       	push	r11
     59e:	cf 92       	push	r12
     5a0:	df 92       	push	r13
     5a2:	ef 92       	push	r14
     5a4:	ff 92       	push	r15
     5a6:	0f 93       	push	r16
     5a8:	1f 93       	push	r17
     5aa:	2f 93       	push	r18
     5ac:	3f 93       	push	r19
     5ae:	4f 93       	push	r20
     5b0:	5f 93       	push	r21
     5b2:	6f 93       	push	r22
     5b4:	7f 93       	push	r23
     5b6:	8f 93       	push	r24
     5b8:	9f 93       	push	r25
     5ba:	af 93       	push	r26
     5bc:	bf 93       	push	r27
     5be:	cf 93       	push	r28
     5c0:	df 93       	push	r29
     5c2:	ef 93       	push	r30
     5c4:	ff 93       	push	r31
     5c6:	a0 91 08 03 	lds	r26, 0x0308	; 0x800308 <pxCurrentTCB>
     5ca:	b0 91 09 03 	lds	r27, 0x0309	; 0x800309 <pxCurrentTCB+0x1>
     5ce:	0d b6       	in	r0, 0x3d	; 61
     5d0:	0d 92       	st	X+, r0
     5d2:	0e b6       	in	r0, 0x3e	; 62
     5d4:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     5d6:	0e 94 c4 08 	call	0x1188	; 0x1188 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     5da:	a0 91 08 03 	lds	r26, 0x0308	; 0x800308 <pxCurrentTCB>
     5de:	b0 91 09 03 	lds	r27, 0x0309	; 0x800309 <pxCurrentTCB+0x1>
     5e2:	cd 91       	ld	r28, X+
     5e4:	cd bf       	out	0x3d, r28	; 61
     5e6:	dd 91       	ld	r29, X+
     5e8:	de bf       	out	0x3e, r29	; 62
     5ea:	ff 91       	pop	r31
     5ec:	ef 91       	pop	r30
     5ee:	df 91       	pop	r29
     5f0:	cf 91       	pop	r28
     5f2:	bf 91       	pop	r27
     5f4:	af 91       	pop	r26
     5f6:	9f 91       	pop	r25
     5f8:	8f 91       	pop	r24
     5fa:	7f 91       	pop	r23
     5fc:	6f 91       	pop	r22
     5fe:	5f 91       	pop	r21
     600:	4f 91       	pop	r20
     602:	3f 91       	pop	r19
     604:	2f 91       	pop	r18
     606:	1f 91       	pop	r17
     608:	0f 91       	pop	r16
     60a:	ff 90       	pop	r15
     60c:	ef 90       	pop	r14
     60e:	df 90       	pop	r13
     610:	cf 90       	pop	r12
     612:	bf 90       	pop	r11
     614:	af 90       	pop	r10
     616:	9f 90       	pop	r9
     618:	8f 90       	pop	r8
     61a:	7f 90       	pop	r7
     61c:	6f 90       	pop	r6
     61e:	5f 90       	pop	r5
     620:	4f 90       	pop	r4
     622:	3f 90       	pop	r3
     624:	2f 90       	pop	r2
     626:	1f 90       	pop	r1
     628:	0f 90       	pop	r0
     62a:	0f be       	out	0x3f, r0	; 63
     62c:	0f 90       	pop	r0

	asm volatile ( "ret" );
     62e:	08 95       	ret

00000630 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     630:	0f 92       	push	r0
     632:	0f b6       	in	r0, 0x3f	; 63
     634:	f8 94       	cli
     636:	0f 92       	push	r0
     638:	1f 92       	push	r1
     63a:	11 24       	eor	r1, r1
     63c:	2f 92       	push	r2
     63e:	3f 92       	push	r3
     640:	4f 92       	push	r4
     642:	5f 92       	push	r5
     644:	6f 92       	push	r6
     646:	7f 92       	push	r7
     648:	8f 92       	push	r8
     64a:	9f 92       	push	r9
     64c:	af 92       	push	r10
     64e:	bf 92       	push	r11
     650:	cf 92       	push	r12
     652:	df 92       	push	r13
     654:	ef 92       	push	r14
     656:	ff 92       	push	r15
     658:	0f 93       	push	r16
     65a:	1f 93       	push	r17
     65c:	2f 93       	push	r18
     65e:	3f 93       	push	r19
     660:	4f 93       	push	r20
     662:	5f 93       	push	r21
     664:	6f 93       	push	r22
     666:	7f 93       	push	r23
     668:	8f 93       	push	r24
     66a:	9f 93       	push	r25
     66c:	af 93       	push	r26
     66e:	bf 93       	push	r27
     670:	cf 93       	push	r28
     672:	df 93       	push	r29
     674:	ef 93       	push	r30
     676:	ff 93       	push	r31
     678:	a0 91 08 03 	lds	r26, 0x0308	; 0x800308 <pxCurrentTCB>
     67c:	b0 91 09 03 	lds	r27, 0x0309	; 0x800309 <pxCurrentTCB+0x1>
     680:	0d b6       	in	r0, 0x3d	; 61
     682:	0d 92       	st	X+, r0
     684:	0e b6       	in	r0, 0x3e	; 62
     686:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     688:	0e 94 76 07 	call	0xeec	; 0xeec <xTaskIncrementTick>
     68c:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     68e:	0e 94 c4 08 	call	0x1188	; 0x1188 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     692:	a0 91 08 03 	lds	r26, 0x0308	; 0x800308 <pxCurrentTCB>
     696:	b0 91 09 03 	lds	r27, 0x0309	; 0x800309 <pxCurrentTCB+0x1>
     69a:	cd 91       	ld	r28, X+
     69c:	cd bf       	out	0x3d, r28	; 61
     69e:	dd 91       	ld	r29, X+
     6a0:	de bf       	out	0x3e, r29	; 62
     6a2:	ff 91       	pop	r31
     6a4:	ef 91       	pop	r30
     6a6:	df 91       	pop	r29
     6a8:	cf 91       	pop	r28
     6aa:	bf 91       	pop	r27
     6ac:	af 91       	pop	r26
     6ae:	9f 91       	pop	r25
     6b0:	8f 91       	pop	r24
     6b2:	7f 91       	pop	r23
     6b4:	6f 91       	pop	r22
     6b6:	5f 91       	pop	r21
     6b8:	4f 91       	pop	r20
     6ba:	3f 91       	pop	r19
     6bc:	2f 91       	pop	r18
     6be:	1f 91       	pop	r17
     6c0:	0f 91       	pop	r16
     6c2:	ff 90       	pop	r15
     6c4:	ef 90       	pop	r14
     6c6:	df 90       	pop	r13
     6c8:	cf 90       	pop	r12
     6ca:	bf 90       	pop	r11
     6cc:	af 90       	pop	r10
     6ce:	9f 90       	pop	r9
     6d0:	8f 90       	pop	r8
     6d2:	7f 90       	pop	r7
     6d4:	6f 90       	pop	r6
     6d6:	5f 90       	pop	r5
     6d8:	4f 90       	pop	r4
     6da:	3f 90       	pop	r3
     6dc:	2f 90       	pop	r2
     6de:	1f 90       	pop	r1
     6e0:	0f 90       	pop	r0
     6e2:	0f be       	out	0x3f, r0	; 63
     6e4:	0f 90       	pop	r0

	asm volatile ( "ret" );
     6e6:	08 95       	ret

000006e8 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     6e8:	0e 94 18 03 	call	0x630	; 0x630 <vPortYieldFromTick>
		asm volatile ( "reti" );
     6ec:	18 95       	reti

000006ee <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     6ee:	0f 93       	push	r16
     6f0:	1f 93       	push	r17
     6f2:	cf 93       	push	r28
     6f4:	df 93       	push	r29
     6f6:	ec 01       	movw	r28, r24
     6f8:	04 2f       	mov	r16, r20
     6fa:	1a 8d       	ldd	r17, Y+26	; 0x1a
     6fc:	4c 8d       	ldd	r20, Y+28	; 0x1c
     6fe:	44 23       	and	r20, r20
     700:	b9 f1       	breq	.+110    	; 0x770 <prvCopyDataToQueue+0x82>
     702:	01 11       	cpse	r16, r1
     704:	16 c0       	rjmp	.+44     	; 0x732 <prvCopyDataToQueue+0x44>
     706:	50 e0       	ldi	r21, 0x00	; 0
     708:	8c 81       	ldd	r24, Y+4	; 0x04
     70a:	9d 81       	ldd	r25, Y+5	; 0x05
     70c:	0e 94 c5 09 	call	0x138a	; 0x138a <memcpy>
     710:	2c 8d       	ldd	r18, Y+28	; 0x1c
     712:	8c 81       	ldd	r24, Y+4	; 0x04
     714:	9d 81       	ldd	r25, Y+5	; 0x05
     716:	82 0f       	add	r24, r18
     718:	91 1d       	adc	r25, r1
     71a:	9d 83       	std	Y+5, r25	; 0x05
     71c:	8c 83       	std	Y+4, r24	; 0x04
     71e:	2a 81       	ldd	r18, Y+2	; 0x02
     720:	3b 81       	ldd	r19, Y+3	; 0x03
     722:	82 17       	cp	r24, r18
     724:	93 07       	cpc	r25, r19
     726:	20 f1       	brcs	.+72     	; 0x770 <prvCopyDataToQueue+0x82>
     728:	88 81       	ld	r24, Y
     72a:	99 81       	ldd	r25, Y+1	; 0x01
     72c:	9d 83       	std	Y+5, r25	; 0x05
     72e:	8c 83       	std	Y+4, r24	; 0x04
     730:	1f c0       	rjmp	.+62     	; 0x770 <prvCopyDataToQueue+0x82>
     732:	50 e0       	ldi	r21, 0x00	; 0
     734:	8e 81       	ldd	r24, Y+6	; 0x06
     736:	9f 81       	ldd	r25, Y+7	; 0x07
     738:	0e 94 c5 09 	call	0x138a	; 0x138a <memcpy>
     73c:	8c 8d       	ldd	r24, Y+28	; 0x1c
     73e:	90 e0       	ldi	r25, 0x00	; 0
     740:	91 95       	neg	r25
     742:	81 95       	neg	r24
     744:	91 09       	sbc	r25, r1
     746:	2e 81       	ldd	r18, Y+6	; 0x06
     748:	3f 81       	ldd	r19, Y+7	; 0x07
     74a:	28 0f       	add	r18, r24
     74c:	39 1f       	adc	r19, r25
     74e:	3f 83       	std	Y+7, r19	; 0x07
     750:	2e 83       	std	Y+6, r18	; 0x06
     752:	48 81       	ld	r20, Y
     754:	59 81       	ldd	r21, Y+1	; 0x01
     756:	24 17       	cp	r18, r20
     758:	35 07       	cpc	r19, r21
     75a:	30 f4       	brcc	.+12     	; 0x768 <prvCopyDataToQueue+0x7a>
     75c:	2a 81       	ldd	r18, Y+2	; 0x02
     75e:	3b 81       	ldd	r19, Y+3	; 0x03
     760:	82 0f       	add	r24, r18
     762:	93 1f       	adc	r25, r19
     764:	9f 83       	std	Y+7, r25	; 0x07
     766:	8e 83       	std	Y+6, r24	; 0x06
     768:	02 30       	cpi	r16, 0x02	; 2
     76a:	11 f4       	brne	.+4      	; 0x770 <prvCopyDataToQueue+0x82>
     76c:	11 11       	cpse	r17, r1
     76e:	11 50       	subi	r17, 0x01	; 1
     770:	1f 5f       	subi	r17, 0xFF	; 255
     772:	1a 8f       	std	Y+26, r17	; 0x1a
     774:	80 e0       	ldi	r24, 0x00	; 0
     776:	df 91       	pop	r29
     778:	cf 91       	pop	r28
     77a:	1f 91       	pop	r17
     77c:	0f 91       	pop	r16
     77e:	08 95       	ret

00000780 <prvCopyDataFromQueue>:
     780:	fc 01       	movw	r30, r24
     782:	44 8d       	ldd	r20, Z+28	; 0x1c
     784:	44 23       	and	r20, r20
     786:	a9 f0       	breq	.+42     	; 0x7b2 <prvCopyDataFromQueue+0x32>
     788:	50 e0       	ldi	r21, 0x00	; 0
     78a:	26 81       	ldd	r18, Z+6	; 0x06
     78c:	37 81       	ldd	r19, Z+7	; 0x07
     78e:	24 0f       	add	r18, r20
     790:	35 1f       	adc	r19, r21
     792:	37 83       	std	Z+7, r19	; 0x07
     794:	26 83       	std	Z+6, r18	; 0x06
     796:	82 81       	ldd	r24, Z+2	; 0x02
     798:	93 81       	ldd	r25, Z+3	; 0x03
     79a:	28 17       	cp	r18, r24
     79c:	39 07       	cpc	r19, r25
     79e:	20 f0       	brcs	.+8      	; 0x7a8 <prvCopyDataFromQueue+0x28>
     7a0:	80 81       	ld	r24, Z
     7a2:	91 81       	ldd	r25, Z+1	; 0x01
     7a4:	97 83       	std	Z+7, r25	; 0x07
     7a6:	86 83       	std	Z+6, r24	; 0x06
     7a8:	cb 01       	movw	r24, r22
     7aa:	66 81       	ldd	r22, Z+6	; 0x06
     7ac:	77 81       	ldd	r23, Z+7	; 0x07
     7ae:	0e 94 c5 09 	call	0x138a	; 0x138a <memcpy>
     7b2:	08 95       	ret

000007b4 <prvUnlockQueue>:
     7b4:	ef 92       	push	r14
     7b6:	ff 92       	push	r15
     7b8:	0f 93       	push	r16
     7ba:	1f 93       	push	r17
     7bc:	cf 93       	push	r28
     7be:	8c 01       	movw	r16, r24
     7c0:	0f b6       	in	r0, 0x3f	; 63
     7c2:	f8 94       	cli
     7c4:	0f 92       	push	r0
     7c6:	fc 01       	movw	r30, r24
     7c8:	c6 8d       	ldd	r28, Z+30	; 0x1e
     7ca:	1c 16       	cp	r1, r28
     7cc:	ac f4       	brge	.+42     	; 0x7f8 <prvUnlockQueue+0x44>
     7ce:	81 89       	ldd	r24, Z+17	; 0x11
     7d0:	81 11       	cpse	r24, r1
     7d2:	06 c0       	rjmp	.+12     	; 0x7e0 <prvUnlockQueue+0x2c>
     7d4:	11 c0       	rjmp	.+34     	; 0x7f8 <prvUnlockQueue+0x44>
     7d6:	f8 01       	movw	r30, r16
     7d8:	81 89       	ldd	r24, Z+17	; 0x11
     7da:	81 11       	cpse	r24, r1
     7dc:	05 c0       	rjmp	.+10     	; 0x7e8 <prvUnlockQueue+0x34>
     7de:	0c c0       	rjmp	.+24     	; 0x7f8 <prvUnlockQueue+0x44>
     7e0:	78 01       	movw	r14, r16
     7e2:	f1 e1       	ldi	r31, 0x11	; 17
     7e4:	ef 0e       	add	r14, r31
     7e6:	f1 1c       	adc	r15, r1
     7e8:	c7 01       	movw	r24, r14
     7ea:	0e 94 3c 09 	call	0x1278	; 0x1278 <xTaskRemoveFromEventList>
     7ee:	81 11       	cpse	r24, r1
     7f0:	0e 94 c1 09 	call	0x1382	; 0x1382 <vTaskMissedYield>
     7f4:	c1 50       	subi	r28, 0x01	; 1
     7f6:	79 f7       	brne	.-34     	; 0x7d6 <prvUnlockQueue+0x22>
     7f8:	8f ef       	ldi	r24, 0xFF	; 255
     7fa:	f8 01       	movw	r30, r16
     7fc:	86 8f       	std	Z+30, r24	; 0x1e
     7fe:	0f 90       	pop	r0
     800:	0f be       	out	0x3f, r0	; 63
     802:	0f b6       	in	r0, 0x3f	; 63
     804:	f8 94       	cli
     806:	0f 92       	push	r0
     808:	c5 8d       	ldd	r28, Z+29	; 0x1d
     80a:	1c 16       	cp	r1, r28
     80c:	ac f4       	brge	.+42     	; 0x838 <prvUnlockQueue+0x84>
     80e:	80 85       	ldd	r24, Z+8	; 0x08
     810:	81 11       	cpse	r24, r1
     812:	06 c0       	rjmp	.+12     	; 0x820 <prvUnlockQueue+0x6c>
     814:	11 c0       	rjmp	.+34     	; 0x838 <prvUnlockQueue+0x84>
     816:	f8 01       	movw	r30, r16
     818:	80 85       	ldd	r24, Z+8	; 0x08
     81a:	81 11       	cpse	r24, r1
     81c:	05 c0       	rjmp	.+10     	; 0x828 <prvUnlockQueue+0x74>
     81e:	0c c0       	rjmp	.+24     	; 0x838 <prvUnlockQueue+0x84>
     820:	78 01       	movw	r14, r16
     822:	f8 e0       	ldi	r31, 0x08	; 8
     824:	ef 0e       	add	r14, r31
     826:	f1 1c       	adc	r15, r1
     828:	c7 01       	movw	r24, r14
     82a:	0e 94 3c 09 	call	0x1278	; 0x1278 <xTaskRemoveFromEventList>
     82e:	81 11       	cpse	r24, r1
     830:	0e 94 c1 09 	call	0x1382	; 0x1382 <vTaskMissedYield>
     834:	c1 50       	subi	r28, 0x01	; 1
     836:	79 f7       	brne	.-34     	; 0x816 <prvUnlockQueue+0x62>
     838:	8f ef       	ldi	r24, 0xFF	; 255
     83a:	f8 01       	movw	r30, r16
     83c:	85 8f       	std	Z+29, r24	; 0x1d
     83e:	0f 90       	pop	r0
     840:	0f be       	out	0x3f, r0	; 63
     842:	cf 91       	pop	r28
     844:	1f 91       	pop	r17
     846:	0f 91       	pop	r16
     848:	ff 90       	pop	r15
     84a:	ef 90       	pop	r14
     84c:	08 95       	ret

0000084e <xQueueGenericReset>:
     84e:	cf 93       	push	r28
     850:	df 93       	push	r29
     852:	ec 01       	movw	r28, r24
     854:	0f b6       	in	r0, 0x3f	; 63
     856:	f8 94       	cli
     858:	0f 92       	push	r0
     85a:	48 81       	ld	r20, Y
     85c:	59 81       	ldd	r21, Y+1	; 0x01
     85e:	2c 8d       	ldd	r18, Y+28	; 0x1c
     860:	30 e0       	ldi	r19, 0x00	; 0
     862:	7b 8d       	ldd	r23, Y+27	; 0x1b
     864:	72 9f       	mul	r23, r18
     866:	c0 01       	movw	r24, r0
     868:	73 9f       	mul	r23, r19
     86a:	90 0d       	add	r25, r0
     86c:	11 24       	eor	r1, r1
     86e:	fa 01       	movw	r30, r20
     870:	e8 0f       	add	r30, r24
     872:	f9 1f       	adc	r31, r25
     874:	fb 83       	std	Y+3, r31	; 0x03
     876:	ea 83       	std	Y+2, r30	; 0x02
     878:	1a 8e       	std	Y+26, r1	; 0x1a
     87a:	5d 83       	std	Y+5, r21	; 0x05
     87c:	4c 83       	std	Y+4, r20	; 0x04
     87e:	82 1b       	sub	r24, r18
     880:	93 0b       	sbc	r25, r19
     882:	84 0f       	add	r24, r20
     884:	95 1f       	adc	r25, r21
     886:	9f 83       	std	Y+7, r25	; 0x07
     888:	8e 83       	std	Y+6, r24	; 0x06
     88a:	8f ef       	ldi	r24, 0xFF	; 255
     88c:	8d 8f       	std	Y+29, r24	; 0x1d
     88e:	8e 8f       	std	Y+30, r24	; 0x1e
     890:	61 11       	cpse	r22, r1
     892:	0c c0       	rjmp	.+24     	; 0x8ac <__stack+0x4d>
     894:	88 85       	ldd	r24, Y+8	; 0x08
     896:	88 23       	and	r24, r24
     898:	89 f0       	breq	.+34     	; 0x8bc <__stack+0x5d>
     89a:	ce 01       	movw	r24, r28
     89c:	08 96       	adiw	r24, 0x08	; 8
     89e:	0e 94 3c 09 	call	0x1278	; 0x1278 <xTaskRemoveFromEventList>
     8a2:	88 23       	and	r24, r24
     8a4:	59 f0       	breq	.+22     	; 0x8bc <__stack+0x5d>
     8a6:	0e 94 bf 02 	call	0x57e	; 0x57e <vPortYield>
     8aa:	08 c0       	rjmp	.+16     	; 0x8bc <__stack+0x5d>
     8ac:	ce 01       	movw	r24, r28
     8ae:	08 96       	adiw	r24, 0x08	; 8
     8b0:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     8b4:	ce 01       	movw	r24, r28
     8b6:	41 96       	adiw	r24, 0x11	; 17
     8b8:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     8bc:	0f 90       	pop	r0
     8be:	0f be       	out	0x3f, r0	; 63
     8c0:	81 e0       	ldi	r24, 0x01	; 1
     8c2:	df 91       	pop	r29
     8c4:	cf 91       	pop	r28
     8c6:	08 95       	ret

000008c8 <xQueueGenericCreate>:
     8c8:	0f 93       	push	r16
     8ca:	1f 93       	push	r17
     8cc:	cf 93       	push	r28
     8ce:	df 93       	push	r29
     8d0:	08 2f       	mov	r16, r24
     8d2:	16 2f       	mov	r17, r22
     8d4:	66 23       	and	r22, r22
     8d6:	c1 f0       	breq	.+48     	; 0x908 <xQueueGenericCreate+0x40>
     8d8:	86 9f       	mul	r24, r22
     8da:	c0 01       	movw	r24, r0
     8dc:	11 24       	eor	r1, r1
     8de:	4f 96       	adiw	r24, 0x1f	; 31
     8e0:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     8e4:	ec 01       	movw	r28, r24
     8e6:	00 97       	sbiw	r24, 0x00	; 0
     8e8:	41 f4       	brne	.+16     	; 0x8fa <xQueueGenericCreate+0x32>
     8ea:	15 c0       	rjmp	.+42     	; 0x916 <xQueueGenericCreate+0x4e>
     8ec:	0b 8f       	std	Y+27, r16	; 0x1b
     8ee:	1c 8f       	std	Y+28, r17	; 0x1c
     8f0:	61 e0       	ldi	r22, 0x01	; 1
     8f2:	ce 01       	movw	r24, r28
     8f4:	0e 94 27 04 	call	0x84e	; 0x84e <xQueueGenericReset>
     8f8:	0e c0       	rjmp	.+28     	; 0x916 <xQueueGenericCreate+0x4e>
     8fa:	4f 96       	adiw	r24, 0x1f	; 31
     8fc:	99 83       	std	Y+1, r25	; 0x01
     8fe:	88 83       	st	Y, r24
     900:	f5 cf       	rjmp	.-22     	; 0x8ec <xQueueGenericCreate+0x24>
     902:	d9 83       	std	Y+1, r29	; 0x01
     904:	c8 83       	st	Y, r28
     906:	f2 cf       	rjmp	.-28     	; 0x8ec <xQueueGenericCreate+0x24>
     908:	8f e1       	ldi	r24, 0x1F	; 31
     90a:	90 e0       	ldi	r25, 0x00	; 0
     90c:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     910:	ec 01       	movw	r28, r24
     912:	89 2b       	or	r24, r25
     914:	b1 f7       	brne	.-20     	; 0x902 <xQueueGenericCreate+0x3a>
     916:	ce 01       	movw	r24, r28
     918:	df 91       	pop	r29
     91a:	cf 91       	pop	r28
     91c:	1f 91       	pop	r17
     91e:	0f 91       	pop	r16
     920:	08 95       	ret

00000922 <xQueueGenericSend>:
     922:	9f 92       	push	r9
     924:	af 92       	push	r10
     926:	bf 92       	push	r11
     928:	cf 92       	push	r12
     92a:	df 92       	push	r13
     92c:	ef 92       	push	r14
     92e:	ff 92       	push	r15
     930:	0f 93       	push	r16
     932:	1f 93       	push	r17
     934:	cf 93       	push	r28
     936:	df 93       	push	r29
     938:	00 d0       	rcall	.+0      	; 0x93a <xQueueGenericSend+0x18>
     93a:	00 d0       	rcall	.+0      	; 0x93c <xQueueGenericSend+0x1a>
     93c:	1f 92       	push	r1
     93e:	cd b7       	in	r28, 0x3d	; 61
     940:	de b7       	in	r29, 0x3e	; 62
     942:	8c 01       	movw	r16, r24
     944:	6b 01       	movw	r12, r22
     946:	5d 83       	std	Y+5, r21	; 0x05
     948:	4c 83       	std	Y+4, r20	; 0x04
     94a:	a2 2e       	mov	r10, r18
     94c:	b1 2c       	mov	r11, r1
     94e:	99 24       	eor	r9, r9
     950:	93 94       	inc	r9
     952:	7c 01       	movw	r14, r24
     954:	88 e0       	ldi	r24, 0x08	; 8
     956:	e8 0e       	add	r14, r24
     958:	f1 1c       	adc	r15, r1
     95a:	0f b6       	in	r0, 0x3f	; 63
     95c:	f8 94       	cli
     95e:	0f 92       	push	r0
     960:	f8 01       	movw	r30, r16
     962:	92 8d       	ldd	r25, Z+26	; 0x1a
     964:	83 8d       	ldd	r24, Z+27	; 0x1b
     966:	98 17       	cp	r25, r24
     968:	18 f0       	brcs	.+6      	; 0x970 <xQueueGenericSend+0x4e>
     96a:	f2 e0       	ldi	r31, 0x02	; 2
     96c:	af 12       	cpse	r10, r31
     96e:	19 c0       	rjmp	.+50     	; 0x9a2 <xQueueGenericSend+0x80>
     970:	4a 2d       	mov	r20, r10
     972:	b6 01       	movw	r22, r12
     974:	c8 01       	movw	r24, r16
     976:	0e 94 77 03 	call	0x6ee	; 0x6ee <prvCopyDataToQueue>
     97a:	f8 01       	movw	r30, r16
     97c:	91 89       	ldd	r25, Z+17	; 0x11
     97e:	99 23       	and	r25, r25
     980:	49 f0       	breq	.+18     	; 0x994 <xQueueGenericSend+0x72>
     982:	c8 01       	movw	r24, r16
     984:	41 96       	adiw	r24, 0x11	; 17
     986:	0e 94 3c 09 	call	0x1278	; 0x1278 <xTaskRemoveFromEventList>
     98a:	88 23       	and	r24, r24
     98c:	31 f0       	breq	.+12     	; 0x99a <xQueueGenericSend+0x78>
     98e:	0e 94 bf 02 	call	0x57e	; 0x57e <vPortYield>
     992:	03 c0       	rjmp	.+6      	; 0x99a <xQueueGenericSend+0x78>
     994:	81 11       	cpse	r24, r1
     996:	0e 94 bf 02 	call	0x57e	; 0x57e <vPortYield>
     99a:	0f 90       	pop	r0
     99c:	0f be       	out	0x3f, r0	; 63
     99e:	81 e0       	ldi	r24, 0x01	; 1
     9a0:	50 c0       	rjmp	.+160    	; 0xa42 <xQueueGenericSend+0x120>
     9a2:	8c 81       	ldd	r24, Y+4	; 0x04
     9a4:	9d 81       	ldd	r25, Y+5	; 0x05
     9a6:	89 2b       	or	r24, r25
     9a8:	21 f4       	brne	.+8      	; 0x9b2 <xQueueGenericSend+0x90>
     9aa:	0f 90       	pop	r0
     9ac:	0f be       	out	0x3f, r0	; 63
     9ae:	80 e0       	ldi	r24, 0x00	; 0
     9b0:	48 c0       	rjmp	.+144    	; 0xa42 <xQueueGenericSend+0x120>
     9b2:	b1 10       	cpse	r11, r1
     9b4:	05 c0       	rjmp	.+10     	; 0x9c0 <xQueueGenericSend+0x9e>
     9b6:	ce 01       	movw	r24, r28
     9b8:	01 96       	adiw	r24, 0x01	; 1
     9ba:	0e 94 84 09 	call	0x1308	; 0x1308 <vTaskSetTimeOutState>
     9be:	b9 2c       	mov	r11, r9
     9c0:	0f 90       	pop	r0
     9c2:	0f be       	out	0x3f, r0	; 63
     9c4:	0e 94 70 07 	call	0xee0	; 0xee0 <vTaskSuspendAll>
     9c8:	0f b6       	in	r0, 0x3f	; 63
     9ca:	f8 94       	cli
     9cc:	0f 92       	push	r0
     9ce:	f8 01       	movw	r30, r16
     9d0:	85 8d       	ldd	r24, Z+29	; 0x1d
     9d2:	8f 3f       	cpi	r24, 0xFF	; 255
     9d4:	09 f4       	brne	.+2      	; 0x9d8 <xQueueGenericSend+0xb6>
     9d6:	15 8e       	std	Z+29, r1	; 0x1d
     9d8:	f8 01       	movw	r30, r16
     9da:	86 8d       	ldd	r24, Z+30	; 0x1e
     9dc:	8f 3f       	cpi	r24, 0xFF	; 255
     9de:	09 f4       	brne	.+2      	; 0x9e2 <xQueueGenericSend+0xc0>
     9e0:	16 8e       	std	Z+30, r1	; 0x1e
     9e2:	0f 90       	pop	r0
     9e4:	0f be       	out	0x3f, r0	; 63
     9e6:	be 01       	movw	r22, r28
     9e8:	6c 5f       	subi	r22, 0xFC	; 252
     9ea:	7f 4f       	sbci	r23, 0xFF	; 255
     9ec:	ce 01       	movw	r24, r28
     9ee:	01 96       	adiw	r24, 0x01	; 1
     9f0:	0e 94 8f 09 	call	0x131e	; 0x131e <xTaskCheckForTimeOut>
     9f4:	81 11       	cpse	r24, r1
     9f6:	1f c0       	rjmp	.+62     	; 0xa36 <xQueueGenericSend+0x114>
     9f8:	0f b6       	in	r0, 0x3f	; 63
     9fa:	f8 94       	cli
     9fc:	0f 92       	push	r0
     9fe:	f8 01       	movw	r30, r16
     a00:	92 8d       	ldd	r25, Z+26	; 0x1a
     a02:	0f 90       	pop	r0
     a04:	0f be       	out	0x3f, r0	; 63
     a06:	83 8d       	ldd	r24, Z+27	; 0x1b
     a08:	98 13       	cpse	r25, r24
     a0a:	0f c0       	rjmp	.+30     	; 0xa2a <xQueueGenericSend+0x108>
     a0c:	6c 81       	ldd	r22, Y+4	; 0x04
     a0e:	7d 81       	ldd	r23, Y+5	; 0x05
     a10:	c7 01       	movw	r24, r14
     a12:	0e 94 2a 09 	call	0x1254	; 0x1254 <vTaskPlaceOnEventList>
     a16:	c8 01       	movw	r24, r16
     a18:	0e 94 da 03 	call	0x7b4	; 0x7b4 <prvUnlockQueue>
     a1c:	0e 94 31 08 	call	0x1062	; 0x1062 <xTaskResumeAll>
     a20:	81 11       	cpse	r24, r1
     a22:	9b cf       	rjmp	.-202    	; 0x95a <xQueueGenericSend+0x38>
     a24:	0e 94 bf 02 	call	0x57e	; 0x57e <vPortYield>
     a28:	98 cf       	rjmp	.-208    	; 0x95a <xQueueGenericSend+0x38>
     a2a:	c8 01       	movw	r24, r16
     a2c:	0e 94 da 03 	call	0x7b4	; 0x7b4 <prvUnlockQueue>
     a30:	0e 94 31 08 	call	0x1062	; 0x1062 <xTaskResumeAll>
     a34:	92 cf       	rjmp	.-220    	; 0x95a <xQueueGenericSend+0x38>
     a36:	c8 01       	movw	r24, r16
     a38:	0e 94 da 03 	call	0x7b4	; 0x7b4 <prvUnlockQueue>
     a3c:	0e 94 31 08 	call	0x1062	; 0x1062 <xTaskResumeAll>
     a40:	80 e0       	ldi	r24, 0x00	; 0
     a42:	0f 90       	pop	r0
     a44:	0f 90       	pop	r0
     a46:	0f 90       	pop	r0
     a48:	0f 90       	pop	r0
     a4a:	0f 90       	pop	r0
     a4c:	df 91       	pop	r29
     a4e:	cf 91       	pop	r28
     a50:	1f 91       	pop	r17
     a52:	0f 91       	pop	r16
     a54:	ff 90       	pop	r15
     a56:	ef 90       	pop	r14
     a58:	df 90       	pop	r13
     a5a:	cf 90       	pop	r12
     a5c:	bf 90       	pop	r11
     a5e:	af 90       	pop	r10
     a60:	9f 90       	pop	r9
     a62:	08 95       	ret

00000a64 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     a64:	8f 92       	push	r8
     a66:	9f 92       	push	r9
     a68:	af 92       	push	r10
     a6a:	bf 92       	push	r11
     a6c:	cf 92       	push	r12
     a6e:	df 92       	push	r13
     a70:	ef 92       	push	r14
     a72:	ff 92       	push	r15
     a74:	0f 93       	push	r16
     a76:	1f 93       	push	r17
     a78:	cf 93       	push	r28
     a7a:	df 93       	push	r29
     a7c:	00 d0       	rcall	.+0      	; 0xa7e <xQueueGenericReceive+0x1a>
     a7e:	00 d0       	rcall	.+0      	; 0xa80 <xQueueGenericReceive+0x1c>
     a80:	1f 92       	push	r1
     a82:	cd b7       	in	r28, 0x3d	; 61
     a84:	de b7       	in	r29, 0x3e	; 62
     a86:	8c 01       	movw	r16, r24
     a88:	5b 01       	movw	r10, r22
     a8a:	5d 83       	std	Y+5, r21	; 0x05
     a8c:	4c 83       	std	Y+4, r20	; 0x04
     a8e:	82 2e       	mov	r8, r18
BaseType_t xEntryTimeSet = pdFALSE;
     a90:	e1 2c       	mov	r14, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     a92:	99 24       	eor	r9, r9
     a94:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     a96:	6c 01       	movw	r12, r24
     a98:	81 e1       	ldi	r24, 0x11	; 17
     a9a:	c8 0e       	add	r12, r24
     a9c:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     a9e:	0f b6       	in	r0, 0x3f	; 63
     aa0:	f8 94       	cli
     aa2:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     aa4:	f8 01       	movw	r30, r16
     aa6:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     aa8:	ff 20       	and	r15, r15
     aaa:	41 f1       	breq	.+80     	; 0xafc <xQueueGenericReceive+0x98>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     aac:	c6 80       	ldd	r12, Z+6	; 0x06
     aae:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     ab0:	b5 01       	movw	r22, r10
     ab2:	c8 01       	movw	r24, r16
     ab4:	0e 94 c0 03 	call	0x780	; 0x780 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     ab8:	81 10       	cpse	r8, r1
     aba:	0f c0       	rjmp	.+30     	; 0xada <xQueueGenericReceive+0x76>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
     abc:	fa 94       	dec	r15
     abe:	f8 01       	movw	r30, r16
     ac0:	f2 8e       	std	Z+26, r15	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     ac2:	80 85       	ldd	r24, Z+8	; 0x08
     ac4:	88 23       	and	r24, r24
     ac6:	b1 f0       	breq	.+44     	; 0xaf4 <xQueueGenericReceive+0x90>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     ac8:	c8 01       	movw	r24, r16
     aca:	08 96       	adiw	r24, 0x08	; 8
     acc:	0e 94 3c 09 	call	0x1278	; 0x1278 <xTaskRemoveFromEventList>
     ad0:	88 23       	and	r24, r24
     ad2:	81 f0       	breq	.+32     	; 0xaf4 <xQueueGenericReceive+0x90>
						{
							queueYIELD_IF_USING_PREEMPTION();
     ad4:	0e 94 bf 02 	call	0x57e	; 0x57e <vPortYield>
     ad8:	0d c0       	rjmp	.+26     	; 0xaf4 <xQueueGenericReceive+0x90>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     ada:	f8 01       	movw	r30, r16
     adc:	d7 82       	std	Z+7, r13	; 0x07
     ade:	c6 82       	std	Z+6, r12	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     ae0:	81 89       	ldd	r24, Z+17	; 0x11
     ae2:	88 23       	and	r24, r24
     ae4:	39 f0       	breq	.+14     	; 0xaf4 <xQueueGenericReceive+0x90>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     ae6:	c8 01       	movw	r24, r16
     ae8:	41 96       	adiw	r24, 0x11	; 17
     aea:	0e 94 3c 09 	call	0x1278	; 0x1278 <xTaskRemoveFromEventList>
     aee:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     af0:	0e 94 bf 02 	call	0x57e	; 0x57e <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     af4:	0f 90       	pop	r0
     af6:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     af8:	81 e0       	ldi	r24, 0x01	; 1
     afa:	57 c0       	rjmp	.+174    	; 0xbaa <xQueueGenericReceive+0x146>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     afc:	8c 81       	ldd	r24, Y+4	; 0x04
     afe:	9d 81       	ldd	r25, Y+5	; 0x05
     b00:	89 2b       	or	r24, r25
     b02:	21 f4       	brne	.+8      	; 0xb0c <xQueueGenericReceive+0xa8>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     b04:	0f 90       	pop	r0
     b06:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     b08:	80 e0       	ldi	r24, 0x00	; 0
     b0a:	4f c0       	rjmp	.+158    	; 0xbaa <xQueueGenericReceive+0x146>
				}
				else if( xEntryTimeSet == pdFALSE )
     b0c:	e1 10       	cpse	r14, r1
     b0e:	05 c0       	rjmp	.+10     	; 0xb1a <xQueueGenericReceive+0xb6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     b10:	ce 01       	movw	r24, r28
     b12:	01 96       	adiw	r24, 0x01	; 1
     b14:	0e 94 84 09 	call	0x1308	; 0x1308 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     b18:	e9 2c       	mov	r14, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     b1a:	0f 90       	pop	r0
     b1c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     b1e:	0e 94 70 07 	call	0xee0	; 0xee0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     b22:	0f b6       	in	r0, 0x3f	; 63
     b24:	f8 94       	cli
     b26:	0f 92       	push	r0
     b28:	f8 01       	movw	r30, r16
     b2a:	85 8d       	ldd	r24, Z+29	; 0x1d
     b2c:	8f 3f       	cpi	r24, 0xFF	; 255
     b2e:	09 f4       	brne	.+2      	; 0xb32 <xQueueGenericReceive+0xce>
     b30:	15 8e       	std	Z+29, r1	; 0x1d
     b32:	f8 01       	movw	r30, r16
     b34:	86 8d       	ldd	r24, Z+30	; 0x1e
     b36:	8f 3f       	cpi	r24, 0xFF	; 255
     b38:	09 f4       	brne	.+2      	; 0xb3c <xQueueGenericReceive+0xd8>
     b3a:	16 8e       	std	Z+30, r1	; 0x1e
     b3c:	0f 90       	pop	r0
     b3e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     b40:	be 01       	movw	r22, r28
     b42:	6c 5f       	subi	r22, 0xFC	; 252
     b44:	7f 4f       	sbci	r23, 0xFF	; 255
     b46:	ce 01       	movw	r24, r28
     b48:	01 96       	adiw	r24, 0x01	; 1
     b4a:	0e 94 8f 09 	call	0x131e	; 0x131e <xTaskCheckForTimeOut>
     b4e:	81 11       	cpse	r24, r1
     b50:	1e c0       	rjmp	.+60     	; 0xb8e <xQueueGenericReceive+0x12a>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     b52:	0f b6       	in	r0, 0x3f	; 63
     b54:	f8 94       	cli
     b56:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     b58:	f8 01       	movw	r30, r16
     b5a:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     b5c:	0f 90       	pop	r0
     b5e:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     b60:	81 11       	cpse	r24, r1
     b62:	0f c0       	rjmp	.+30     	; 0xb82 <xQueueGenericReceive+0x11e>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     b64:	6c 81       	ldd	r22, Y+4	; 0x04
     b66:	7d 81       	ldd	r23, Y+5	; 0x05
     b68:	c6 01       	movw	r24, r12
     b6a:	0e 94 2a 09 	call	0x1254	; 0x1254 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     b6e:	c8 01       	movw	r24, r16
     b70:	0e 94 da 03 	call	0x7b4	; 0x7b4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     b74:	0e 94 31 08 	call	0x1062	; 0x1062 <xTaskResumeAll>
     b78:	81 11       	cpse	r24, r1
     b7a:	91 cf       	rjmp	.-222    	; 0xa9e <xQueueGenericReceive+0x3a>
				{
					portYIELD_WITHIN_API();
     b7c:	0e 94 bf 02 	call	0x57e	; 0x57e <vPortYield>
     b80:	8e cf       	rjmp	.-228    	; 0xa9e <xQueueGenericReceive+0x3a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     b82:	c8 01       	movw	r24, r16
     b84:	0e 94 da 03 	call	0x7b4	; 0x7b4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     b88:	0e 94 31 08 	call	0x1062	; 0x1062 <xTaskResumeAll>
     b8c:	88 cf       	rjmp	.-240    	; 0xa9e <xQueueGenericReceive+0x3a>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     b8e:	c8 01       	movw	r24, r16
     b90:	0e 94 da 03 	call	0x7b4	; 0x7b4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     b94:	0e 94 31 08 	call	0x1062	; 0x1062 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     b98:	0f b6       	in	r0, 0x3f	; 63
     b9a:	f8 94       	cli
     b9c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     b9e:	f8 01       	movw	r30, r16
     ba0:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     ba2:	0f 90       	pop	r0
     ba4:	0f be       	out	0x3f, r0	; 63
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     ba6:	81 11       	cpse	r24, r1
     ba8:	7a cf       	rjmp	.-268    	; 0xa9e <xQueueGenericReceive+0x3a>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
     baa:	0f 90       	pop	r0
     bac:	0f 90       	pop	r0
     bae:	0f 90       	pop	r0
     bb0:	0f 90       	pop	r0
     bb2:	0f 90       	pop	r0
     bb4:	df 91       	pop	r29
     bb6:	cf 91       	pop	r28
     bb8:	1f 91       	pop	r17
     bba:	0f 91       	pop	r16
     bbc:	ff 90       	pop	r15
     bbe:	ef 90       	pop	r14
     bc0:	df 90       	pop	r13
     bc2:	cf 90       	pop	r12
     bc4:	bf 90       	pop	r11
     bc6:	af 90       	pop	r10
     bc8:	9f 90       	pop	r9
     bca:	8f 90       	pop	r8
     bcc:	08 95       	ret

00000bce <prvIdleTask>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     bce:	ff cf       	rjmp	.-2      	; 0xbce <prvIdleTask>

00000bd0 <prvResetNextTaskUnblockTime>:
     bd0:	e0 91 e2 02 	lds	r30, 0x02E2	; 0x8002e2 <pxDelayedTaskList>
     bd4:	f0 91 e3 02 	lds	r31, 0x02E3	; 0x8002e3 <pxDelayedTaskList+0x1>
     bd8:	80 81       	ld	r24, Z
     bda:	81 11       	cpse	r24, r1
     bdc:	07 c0       	rjmp	.+14     	; 0xbec <prvResetNextTaskUnblockTime+0x1c>
     bde:	8f ef       	ldi	r24, 0xFF	; 255
     be0:	9f ef       	ldi	r25, 0xFF	; 255
     be2:	90 93 cd 02 	sts	0x02CD, r25	; 0x8002cd <xNextTaskUnblockTime+0x1>
     be6:	80 93 cc 02 	sts	0x02CC, r24	; 0x8002cc <xNextTaskUnblockTime>
     bea:	08 95       	ret
     bec:	e0 91 e2 02 	lds	r30, 0x02E2	; 0x8002e2 <pxDelayedTaskList>
     bf0:	f0 91 e3 02 	lds	r31, 0x02E3	; 0x8002e3 <pxDelayedTaskList+0x1>
     bf4:	05 80       	ldd	r0, Z+5	; 0x05
     bf6:	f6 81       	ldd	r31, Z+6	; 0x06
     bf8:	e0 2d       	mov	r30, r0
     bfa:	06 80       	ldd	r0, Z+6	; 0x06
     bfc:	f7 81       	ldd	r31, Z+7	; 0x07
     bfe:	e0 2d       	mov	r30, r0
     c00:	82 81       	ldd	r24, Z+2	; 0x02
     c02:	93 81       	ldd	r25, Z+3	; 0x03
     c04:	90 93 cd 02 	sts	0x02CD, r25	; 0x8002cd <xNextTaskUnblockTime+0x1>
     c08:	80 93 cc 02 	sts	0x02CC, r24	; 0x8002cc <xNextTaskUnblockTime>
     c0c:	08 95       	ret

00000c0e <prvAddCurrentTaskToDelayedList>:
     c0e:	0f 93       	push	r16
     c10:	1f 93       	push	r17
     c12:	cf 93       	push	r28
     c14:	df 93       	push	r29
     c16:	ec 01       	movw	r28, r24
     c18:	00 91 d4 02 	lds	r16, 0x02D4	; 0x8002d4 <xTickCount>
     c1c:	10 91 d5 02 	lds	r17, 0x02D5	; 0x8002d5 <xTickCount+0x1>
     c20:	80 91 08 03 	lds	r24, 0x0308	; 0x800308 <pxCurrentTCB>
     c24:	90 91 09 03 	lds	r25, 0x0309	; 0x800309 <pxCurrentTCB+0x1>
     c28:	02 96       	adiw	r24, 0x02	; 2
     c2a:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
     c2e:	c0 0f       	add	r28, r16
     c30:	d1 1f       	adc	r29, r17
     c32:	e0 91 08 03 	lds	r30, 0x0308	; 0x800308 <pxCurrentTCB>
     c36:	f0 91 09 03 	lds	r31, 0x0309	; 0x800309 <pxCurrentTCB+0x1>
     c3a:	d3 83       	std	Z+3, r29	; 0x03
     c3c:	c2 83       	std	Z+2, r28	; 0x02
     c3e:	c0 17       	cp	r28, r16
     c40:	d1 07       	cpc	r29, r17
     c42:	68 f4       	brcc	.+26     	; 0xc5e <prvAddCurrentTaskToDelayedList+0x50>
     c44:	60 91 08 03 	lds	r22, 0x0308	; 0x800308 <pxCurrentTCB>
     c48:	70 91 09 03 	lds	r23, 0x0309	; 0x800309 <pxCurrentTCB+0x1>
     c4c:	80 91 e0 02 	lds	r24, 0x02E0	; 0x8002e0 <pxOverflowDelayedTaskList>
     c50:	90 91 e1 02 	lds	r25, 0x02E1	; 0x8002e1 <pxOverflowDelayedTaskList+0x1>
     c54:	6e 5f       	subi	r22, 0xFE	; 254
     c56:	7f 4f       	sbci	r23, 0xFF	; 255
     c58:	0e 94 49 01 	call	0x292	; 0x292 <vListInsert>
     c5c:	17 c0       	rjmp	.+46     	; 0xc8c <prvAddCurrentTaskToDelayedList+0x7e>
     c5e:	60 91 08 03 	lds	r22, 0x0308	; 0x800308 <pxCurrentTCB>
     c62:	70 91 09 03 	lds	r23, 0x0309	; 0x800309 <pxCurrentTCB+0x1>
     c66:	80 91 e2 02 	lds	r24, 0x02E2	; 0x8002e2 <pxDelayedTaskList>
     c6a:	90 91 e3 02 	lds	r25, 0x02E3	; 0x8002e3 <pxDelayedTaskList+0x1>
     c6e:	6e 5f       	subi	r22, 0xFE	; 254
     c70:	7f 4f       	sbci	r23, 0xFF	; 255
     c72:	0e 94 49 01 	call	0x292	; 0x292 <vListInsert>
     c76:	80 91 cc 02 	lds	r24, 0x02CC	; 0x8002cc <xNextTaskUnblockTime>
     c7a:	90 91 cd 02 	lds	r25, 0x02CD	; 0x8002cd <xNextTaskUnblockTime+0x1>
     c7e:	c8 17       	cp	r28, r24
     c80:	d9 07       	cpc	r29, r25
     c82:	20 f4       	brcc	.+8      	; 0xc8c <prvAddCurrentTaskToDelayedList+0x7e>
     c84:	d0 93 cd 02 	sts	0x02CD, r29	; 0x8002cd <xNextTaskUnblockTime+0x1>
     c88:	c0 93 cc 02 	sts	0x02CC, r28	; 0x8002cc <xNextTaskUnblockTime>
     c8c:	df 91       	pop	r29
     c8e:	cf 91       	pop	r28
     c90:	1f 91       	pop	r17
     c92:	0f 91       	pop	r16
     c94:	08 95       	ret

00000c96 <xTaskCreate>:
     c96:	4f 92       	push	r4
     c98:	5f 92       	push	r5
     c9a:	6f 92       	push	r6
     c9c:	7f 92       	push	r7
     c9e:	8f 92       	push	r8
     ca0:	9f 92       	push	r9
     ca2:	af 92       	push	r10
     ca4:	bf 92       	push	r11
     ca6:	cf 92       	push	r12
     ca8:	df 92       	push	r13
     caa:	ef 92       	push	r14
     cac:	ff 92       	push	r15
     cae:	0f 93       	push	r16
     cb0:	cf 93       	push	r28
     cb2:	df 93       	push	r29
     cb4:	4c 01       	movw	r8, r24
     cb6:	6b 01       	movw	r12, r22
     cb8:	5a 01       	movw	r10, r20
     cba:	29 01       	movw	r4, r18
     cbc:	ca 01       	movw	r24, r20
     cbe:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     cc2:	3c 01       	movw	r6, r24
     cc4:	89 2b       	or	r24, r25
     cc6:	09 f4       	brne	.+2      	; 0xcca <xTaskCreate+0x34>
     cc8:	d0 c0       	rjmp	.+416    	; 0xe6a <xTaskCreate+0x1d4>
     cca:	86 e2       	ldi	r24, 0x26	; 38
     ccc:	90 e0       	ldi	r25, 0x00	; 0
     cce:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     cd2:	ec 01       	movw	r28, r24
     cd4:	89 2b       	or	r24, r25
     cd6:	71 f0       	breq	.+28     	; 0xcf4 <xTaskCreate+0x5e>
     cd8:	78 8e       	std	Y+24, r7	; 0x18
     cda:	6f 8a       	std	Y+23, r6	; 0x17
     cdc:	81 e0       	ldi	r24, 0x01	; 1
     cde:	a8 1a       	sub	r10, r24
     ce0:	b1 08       	sbc	r11, r1
     ce2:	a6 0c       	add	r10, r6
     ce4:	b7 1c       	adc	r11, r7
     ce6:	d6 01       	movw	r26, r12
     ce8:	8c 91       	ld	r24, X
     cea:	89 8f       	std	Y+25, r24	; 0x19
     cec:	8c 91       	ld	r24, X
     cee:	81 11       	cpse	r24, r1
     cf0:	05 c0       	rjmp	.+10     	; 0xcfc <xTaskCreate+0x66>
     cf2:	18 c0       	rjmp	.+48     	; 0xd24 <xTaskCreate+0x8e>
     cf4:	c3 01       	movw	r24, r6
     cf6:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <vPortFree>
     cfa:	b7 c0       	rjmp	.+366    	; 0xe6a <xTaskCreate+0x1d4>
     cfc:	ae 01       	movw	r20, r28
     cfe:	46 5e       	subi	r20, 0xE6	; 230
     d00:	5f 4f       	sbci	r21, 0xFF	; 255
     d02:	f6 01       	movw	r30, r12
     d04:	31 96       	adiw	r30, 0x01	; 1
     d06:	b8 e0       	ldi	r27, 0x08	; 8
     d08:	cb 0e       	add	r12, r27
     d0a:	d1 1c       	adc	r13, r1
     d0c:	cf 01       	movw	r24, r30
     d0e:	21 91       	ld	r18, Z+
     d10:	da 01       	movw	r26, r20
     d12:	2d 93       	st	X+, r18
     d14:	ad 01       	movw	r20, r26
     d16:	dc 01       	movw	r26, r24
     d18:	8c 91       	ld	r24, X
     d1a:	88 23       	and	r24, r24
     d1c:	19 f0       	breq	.+6      	; 0xd24 <xTaskCreate+0x8e>
     d1e:	ec 15       	cp	r30, r12
     d20:	fd 05       	cpc	r31, r13
     d22:	a1 f7       	brne	.-24     	; 0xd0c <xTaskCreate+0x76>
     d24:	18 a2       	std	Y+32, r1	; 0x20
     d26:	01 11       	cpse	r16, r1
     d28:	01 e0       	ldi	r16, 0x01	; 1
     d2a:	0e 8b       	std	Y+22, r16	; 0x16
     d2c:	6e 01       	movw	r12, r28
     d2e:	b2 e0       	ldi	r27, 0x02	; 2
     d30:	cb 0e       	add	r12, r27
     d32:	d1 1c       	adc	r13, r1
     d34:	c6 01       	movw	r24, r12
     d36:	0e 94 24 01 	call	0x248	; 0x248 <vListInitialiseItem>
     d3a:	ce 01       	movw	r24, r28
     d3c:	0c 96       	adiw	r24, 0x0c	; 12
     d3e:	0e 94 24 01 	call	0x248	; 0x248 <vListInitialiseItem>
     d42:	d9 87       	std	Y+9, r29	; 0x09
     d44:	c8 87       	std	Y+8, r28	; 0x08
     d46:	82 e0       	ldi	r24, 0x02	; 2
     d48:	90 e0       	ldi	r25, 0x00	; 0
     d4a:	80 1b       	sub	r24, r16
     d4c:	91 09       	sbc	r25, r1
     d4e:	9d 87       	std	Y+13, r25	; 0x0d
     d50:	8c 87       	std	Y+12, r24	; 0x0c
     d52:	db 8b       	std	Y+19, r29	; 0x13
     d54:	ca 8b       	std	Y+18, r28	; 0x12
     d56:	19 a2       	std	Y+33, r1	; 0x21
     d58:	1a a2       	std	Y+34, r1	; 0x22
     d5a:	1b a2       	std	Y+35, r1	; 0x23
     d5c:	1c a2       	std	Y+36, r1	; 0x24
     d5e:	1d a2       	std	Y+37, r1	; 0x25
     d60:	a2 01       	movw	r20, r4
     d62:	b4 01       	movw	r22, r8
     d64:	c5 01       	movw	r24, r10
     d66:	0e 94 1e 02 	call	0x43c	; 0x43c <pxPortInitialiseStack>
     d6a:	99 83       	std	Y+1, r25	; 0x01
     d6c:	88 83       	st	Y, r24
     d6e:	e1 14       	cp	r14, r1
     d70:	f1 04       	cpc	r15, r1
     d72:	19 f0       	breq	.+6      	; 0xd7a <xTaskCreate+0xe4>
     d74:	f7 01       	movw	r30, r14
     d76:	d1 83       	std	Z+1, r29	; 0x01
     d78:	c0 83       	st	Z, r28
     d7a:	0f b6       	in	r0, 0x3f	; 63
     d7c:	f8 94       	cli
     d7e:	0f 92       	push	r0
     d80:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <uxCurrentNumberOfTasks>
     d84:	8f 5f       	subi	r24, 0xFF	; 255
     d86:	80 93 d6 02 	sts	0x02D6, r24	; 0x8002d6 <uxCurrentNumberOfTasks>
     d8a:	80 91 08 03 	lds	r24, 0x0308	; 0x800308 <pxCurrentTCB>
     d8e:	90 91 09 03 	lds	r25, 0x0309	; 0x800309 <pxCurrentTCB+0x1>
     d92:	89 2b       	or	r24, r25
     d94:	49 f5       	brne	.+82     	; 0xde8 <xTaskCreate+0x152>
     d96:	d0 93 09 03 	sts	0x0309, r29	; 0x800309 <pxCurrentTCB+0x1>
     d9a:	c0 93 08 03 	sts	0x0308, r28	; 0x800308 <pxCurrentTCB>
     d9e:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <uxCurrentNumberOfTasks>
     da2:	81 30       	cpi	r24, 0x01	; 1
     da4:	89 f5       	brne	.+98     	; 0xe08 <xTaskCreate+0x172>
     da6:	86 ef       	ldi	r24, 0xF6	; 246
     da8:	92 e0       	ldi	r25, 0x02	; 2
     daa:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     dae:	8f ef       	ldi	r24, 0xFF	; 255
     db0:	92 e0       	ldi	r25, 0x02	; 2
     db2:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     db6:	8d ee       	ldi	r24, 0xED	; 237
     db8:	92 e0       	ldi	r25, 0x02	; 2
     dba:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     dbe:	84 ee       	ldi	r24, 0xE4	; 228
     dc0:	92 e0       	ldi	r25, 0x02	; 2
     dc2:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     dc6:	87 ed       	ldi	r24, 0xD7	; 215
     dc8:	92 e0       	ldi	r25, 0x02	; 2
     dca:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     dce:	8d ee       	ldi	r24, 0xED	; 237
     dd0:	92 e0       	ldi	r25, 0x02	; 2
     dd2:	90 93 e3 02 	sts	0x02E3, r25	; 0x8002e3 <pxDelayedTaskList+0x1>
     dd6:	80 93 e2 02 	sts	0x02E2, r24	; 0x8002e2 <pxDelayedTaskList>
     dda:	84 ee       	ldi	r24, 0xE4	; 228
     ddc:	92 e0       	ldi	r25, 0x02	; 2
     dde:	90 93 e1 02 	sts	0x02E1, r25	; 0x8002e1 <pxOverflowDelayedTaskList+0x1>
     de2:	80 93 e0 02 	sts	0x02E0, r24	; 0x8002e0 <pxOverflowDelayedTaskList>
     de6:	10 c0       	rjmp	.+32     	; 0xe08 <xTaskCreate+0x172>
     de8:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <xSchedulerRunning>
     dec:	81 11       	cpse	r24, r1
     dee:	0c c0       	rjmp	.+24     	; 0xe08 <xTaskCreate+0x172>
     df0:	e0 91 08 03 	lds	r30, 0x0308	; 0x800308 <pxCurrentTCB>
     df4:	f0 91 09 03 	lds	r31, 0x0309	; 0x800309 <pxCurrentTCB+0x1>
     df8:	96 89       	ldd	r25, Z+22	; 0x16
     dfa:	8e 89       	ldd	r24, Y+22	; 0x16
     dfc:	89 17       	cp	r24, r25
     dfe:	20 f0       	brcs	.+8      	; 0xe08 <xTaskCreate+0x172>
     e00:	d0 93 09 03 	sts	0x0309, r29	; 0x800309 <pxCurrentTCB+0x1>
     e04:	c0 93 08 03 	sts	0x0308, r28	; 0x800308 <pxCurrentTCB>
     e08:	80 91 ce 02 	lds	r24, 0x02CE	; 0x8002ce <uxTaskNumber>
     e0c:	8f 5f       	subi	r24, 0xFF	; 255
     e0e:	80 93 ce 02 	sts	0x02CE, r24	; 0x8002ce <uxTaskNumber>
     e12:	8e 89       	ldd	r24, Y+22	; 0x16
     e14:	90 91 d3 02 	lds	r25, 0x02D3	; 0x8002d3 <uxTopReadyPriority>
     e18:	98 17       	cp	r25, r24
     e1a:	10 f4       	brcc	.+4      	; 0xe20 <xTaskCreate+0x18a>
     e1c:	80 93 d3 02 	sts	0x02D3, r24	; 0x8002d3 <uxTopReadyPriority>
     e20:	90 e0       	ldi	r25, 0x00	; 0
     e22:	9c 01       	movw	r18, r24
     e24:	22 0f       	add	r18, r18
     e26:	33 1f       	adc	r19, r19
     e28:	22 0f       	add	r18, r18
     e2a:	33 1f       	adc	r19, r19
     e2c:	22 0f       	add	r18, r18
     e2e:	33 1f       	adc	r19, r19
     e30:	82 0f       	add	r24, r18
     e32:	93 1f       	adc	r25, r19
     e34:	b6 01       	movw	r22, r12
     e36:	8a 50       	subi	r24, 0x0A	; 10
     e38:	9d 4f       	sbci	r25, 0xFD	; 253
     e3a:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
     e3e:	0f 90       	pop	r0
     e40:	0f be       	out	0x3f, r0	; 63
     e42:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <xSchedulerRunning>
     e46:	88 23       	and	r24, r24
     e48:	61 f0       	breq	.+24     	; 0xe62 <xTaskCreate+0x1cc>
     e4a:	e0 91 08 03 	lds	r30, 0x0308	; 0x800308 <pxCurrentTCB>
     e4e:	f0 91 09 03 	lds	r31, 0x0309	; 0x800309 <pxCurrentTCB+0x1>
     e52:	96 89       	ldd	r25, Z+22	; 0x16
     e54:	8e 89       	ldd	r24, Y+22	; 0x16
     e56:	98 17       	cp	r25, r24
     e58:	30 f4       	brcc	.+12     	; 0xe66 <xTaskCreate+0x1d0>
     e5a:	0e 94 bf 02 	call	0x57e	; 0x57e <vPortYield>
     e5e:	81 e0       	ldi	r24, 0x01	; 1
     e60:	05 c0       	rjmp	.+10     	; 0xe6c <xTaskCreate+0x1d6>
     e62:	81 e0       	ldi	r24, 0x01	; 1
     e64:	03 c0       	rjmp	.+6      	; 0xe6c <xTaskCreate+0x1d6>
     e66:	81 e0       	ldi	r24, 0x01	; 1
     e68:	01 c0       	rjmp	.+2      	; 0xe6c <xTaskCreate+0x1d6>
     e6a:	8f ef       	ldi	r24, 0xFF	; 255
     e6c:	df 91       	pop	r29
     e6e:	cf 91       	pop	r28
     e70:	0f 91       	pop	r16
     e72:	ff 90       	pop	r15
     e74:	ef 90       	pop	r14
     e76:	df 90       	pop	r13
     e78:	cf 90       	pop	r12
     e7a:	bf 90       	pop	r11
     e7c:	af 90       	pop	r10
     e7e:	9f 90       	pop	r9
     e80:	8f 90       	pop	r8
     e82:	7f 90       	pop	r7
     e84:	6f 90       	pop	r6
     e86:	5f 90       	pop	r5
     e88:	4f 90       	pop	r4
     e8a:	08 95       	ret

00000e8c <vTaskStartScheduler>:
     e8c:	ef 92       	push	r14
     e8e:	ff 92       	push	r15
     e90:	0f 93       	push	r16
     e92:	0f 2e       	mov	r0, r31
     e94:	fa ec       	ldi	r31, 0xCA	; 202
     e96:	ef 2e       	mov	r14, r31
     e98:	f2 e0       	ldi	r31, 0x02	; 2
     e9a:	ff 2e       	mov	r15, r31
     e9c:	f0 2d       	mov	r31, r0
     e9e:	00 e0       	ldi	r16, 0x00	; 0
     ea0:	20 e0       	ldi	r18, 0x00	; 0
     ea2:	30 e0       	ldi	r19, 0x00	; 0
     ea4:	44 e6       	ldi	r20, 0x64	; 100
     ea6:	50 e0       	ldi	r21, 0x00	; 0
     ea8:	62 e6       	ldi	r22, 0x62	; 98
     eaa:	70 e0       	ldi	r23, 0x00	; 0
     eac:	87 ee       	ldi	r24, 0xE7	; 231
     eae:	95 e0       	ldi	r25, 0x05	; 5
     eb0:	0e 94 4b 06 	call	0xc96	; 0xc96 <xTaskCreate>
     eb4:	81 30       	cpi	r24, 0x01	; 1
     eb6:	81 f4       	brne	.+32     	; 0xed8 <vTaskStartScheduler+0x4c>
     eb8:	f8 94       	cli
     eba:	8f ef       	ldi	r24, 0xFF	; 255
     ebc:	9f ef       	ldi	r25, 0xFF	; 255
     ebe:	90 93 cd 02 	sts	0x02CD, r25	; 0x8002cd <xNextTaskUnblockTime+0x1>
     ec2:	80 93 cc 02 	sts	0x02CC, r24	; 0x8002cc <xNextTaskUnblockTime>
     ec6:	81 e0       	ldi	r24, 0x01	; 1
     ec8:	80 93 d2 02 	sts	0x02D2, r24	; 0x8002d2 <xSchedulerRunning>
     ecc:	10 92 d5 02 	sts	0x02D5, r1	; 0x8002d5 <xTickCount+0x1>
     ed0:	10 92 d4 02 	sts	0x02D4, r1	; 0x8002d4 <xTickCount>
     ed4:	0e 94 8a 02 	call	0x514	; 0x514 <xPortStartScheduler>
     ed8:	0f 91       	pop	r16
     eda:	ff 90       	pop	r15
     edc:	ef 90       	pop	r14
     ede:	08 95       	ret

00000ee0 <vTaskSuspendAll>:
     ee0:	80 91 c9 02 	lds	r24, 0x02C9	; 0x8002c9 <uxSchedulerSuspended>
     ee4:	8f 5f       	subi	r24, 0xFF	; 255
     ee6:	80 93 c9 02 	sts	0x02C9, r24	; 0x8002c9 <uxSchedulerSuspended>
     eea:	08 95       	ret

00000eec <xTaskIncrementTick>:
     eec:	cf 92       	push	r12
     eee:	df 92       	push	r13
     ef0:	ef 92       	push	r14
     ef2:	ff 92       	push	r15
     ef4:	0f 93       	push	r16
     ef6:	1f 93       	push	r17
     ef8:	cf 93       	push	r28
     efa:	df 93       	push	r29
     efc:	80 91 c9 02 	lds	r24, 0x02C9	; 0x8002c9 <uxSchedulerSuspended>
     f00:	81 11       	cpse	r24, r1
     f02:	99 c0       	rjmp	.+306    	; 0x1036 <xTaskIncrementTick+0x14a>
     f04:	e0 90 d4 02 	lds	r14, 0x02D4	; 0x8002d4 <xTickCount>
     f08:	f0 90 d5 02 	lds	r15, 0x02D5	; 0x8002d5 <xTickCount+0x1>
     f0c:	8f ef       	ldi	r24, 0xFF	; 255
     f0e:	e8 1a       	sub	r14, r24
     f10:	f8 0a       	sbc	r15, r24
     f12:	f0 92 d5 02 	sts	0x02D5, r15	; 0x8002d5 <xTickCount+0x1>
     f16:	e0 92 d4 02 	sts	0x02D4, r14	; 0x8002d4 <xTickCount>
     f1a:	e1 14       	cp	r14, r1
     f1c:	f1 04       	cpc	r15, r1
     f1e:	b9 f4       	brne	.+46     	; 0xf4e <xTaskIncrementTick+0x62>
     f20:	80 91 e2 02 	lds	r24, 0x02E2	; 0x8002e2 <pxDelayedTaskList>
     f24:	90 91 e3 02 	lds	r25, 0x02E3	; 0x8002e3 <pxDelayedTaskList+0x1>
     f28:	20 91 e0 02 	lds	r18, 0x02E0	; 0x8002e0 <pxOverflowDelayedTaskList>
     f2c:	30 91 e1 02 	lds	r19, 0x02E1	; 0x8002e1 <pxOverflowDelayedTaskList+0x1>
     f30:	30 93 e3 02 	sts	0x02E3, r19	; 0x8002e3 <pxDelayedTaskList+0x1>
     f34:	20 93 e2 02 	sts	0x02E2, r18	; 0x8002e2 <pxDelayedTaskList>
     f38:	90 93 e1 02 	sts	0x02E1, r25	; 0x8002e1 <pxOverflowDelayedTaskList+0x1>
     f3c:	80 93 e0 02 	sts	0x02E0, r24	; 0x8002e0 <pxOverflowDelayedTaskList>
     f40:	80 91 cf 02 	lds	r24, 0x02CF	; 0x8002cf <xNumOfOverflows>
     f44:	8f 5f       	subi	r24, 0xFF	; 255
     f46:	80 93 cf 02 	sts	0x02CF, r24	; 0x8002cf <xNumOfOverflows>
     f4a:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <prvResetNextTaskUnblockTime>
     f4e:	80 91 cc 02 	lds	r24, 0x02CC	; 0x8002cc <xNextTaskUnblockTime>
     f52:	90 91 cd 02 	lds	r25, 0x02CD	; 0x8002cd <xNextTaskUnblockTime+0x1>
     f56:	e8 16       	cp	r14, r24
     f58:	f9 06       	cpc	r15, r25
     f5a:	10 f4       	brcc	.+4      	; 0xf60 <xTaskIncrementTick+0x74>
     f5c:	d1 2c       	mov	r13, r1
     f5e:	53 c0       	rjmp	.+166    	; 0x1006 <xTaskIncrementTick+0x11a>
     f60:	d1 2c       	mov	r13, r1
     f62:	cc 24       	eor	r12, r12
     f64:	c3 94       	inc	r12
     f66:	e0 91 e2 02 	lds	r30, 0x02E2	; 0x8002e2 <pxDelayedTaskList>
     f6a:	f0 91 e3 02 	lds	r31, 0x02E3	; 0x8002e3 <pxDelayedTaskList+0x1>
     f6e:	80 81       	ld	r24, Z
     f70:	81 11       	cpse	r24, r1
     f72:	07 c0       	rjmp	.+14     	; 0xf82 <xTaskIncrementTick+0x96>
     f74:	8f ef       	ldi	r24, 0xFF	; 255
     f76:	9f ef       	ldi	r25, 0xFF	; 255
     f78:	90 93 cd 02 	sts	0x02CD, r25	; 0x8002cd <xNextTaskUnblockTime+0x1>
     f7c:	80 93 cc 02 	sts	0x02CC, r24	; 0x8002cc <xNextTaskUnblockTime>
     f80:	42 c0       	rjmp	.+132    	; 0x1006 <xTaskIncrementTick+0x11a>
     f82:	e0 91 e2 02 	lds	r30, 0x02E2	; 0x8002e2 <pxDelayedTaskList>
     f86:	f0 91 e3 02 	lds	r31, 0x02E3	; 0x8002e3 <pxDelayedTaskList+0x1>
     f8a:	05 80       	ldd	r0, Z+5	; 0x05
     f8c:	f6 81       	ldd	r31, Z+6	; 0x06
     f8e:	e0 2d       	mov	r30, r0
     f90:	c6 81       	ldd	r28, Z+6	; 0x06
     f92:	d7 81       	ldd	r29, Z+7	; 0x07
     f94:	8a 81       	ldd	r24, Y+2	; 0x02
     f96:	9b 81       	ldd	r25, Y+3	; 0x03
     f98:	e8 16       	cp	r14, r24
     f9a:	f9 06       	cpc	r15, r25
     f9c:	28 f4       	brcc	.+10     	; 0xfa8 <xTaskIncrementTick+0xbc>
     f9e:	90 93 cd 02 	sts	0x02CD, r25	; 0x8002cd <xNextTaskUnblockTime+0x1>
     fa2:	80 93 cc 02 	sts	0x02CC, r24	; 0x8002cc <xNextTaskUnblockTime>
     fa6:	2f c0       	rjmp	.+94     	; 0x1006 <xTaskIncrementTick+0x11a>
     fa8:	8e 01       	movw	r16, r28
     faa:	0e 5f       	subi	r16, 0xFE	; 254
     fac:	1f 4f       	sbci	r17, 0xFF	; 255
     fae:	c8 01       	movw	r24, r16
     fb0:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
     fb4:	8c 89       	ldd	r24, Y+20	; 0x14
     fb6:	9d 89       	ldd	r25, Y+21	; 0x15
     fb8:	89 2b       	or	r24, r25
     fba:	21 f0       	breq	.+8      	; 0xfc4 <xTaskIncrementTick+0xd8>
     fbc:	ce 01       	movw	r24, r28
     fbe:	0c 96       	adiw	r24, 0x0c	; 12
     fc0:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
     fc4:	8e 89       	ldd	r24, Y+22	; 0x16
     fc6:	90 91 d3 02 	lds	r25, 0x02D3	; 0x8002d3 <uxTopReadyPriority>
     fca:	98 17       	cp	r25, r24
     fcc:	10 f4       	brcc	.+4      	; 0xfd2 <xTaskIncrementTick+0xe6>
     fce:	80 93 d3 02 	sts	0x02D3, r24	; 0x8002d3 <uxTopReadyPriority>
     fd2:	90 e0       	ldi	r25, 0x00	; 0
     fd4:	9c 01       	movw	r18, r24
     fd6:	22 0f       	add	r18, r18
     fd8:	33 1f       	adc	r19, r19
     fda:	22 0f       	add	r18, r18
     fdc:	33 1f       	adc	r19, r19
     fde:	22 0f       	add	r18, r18
     fe0:	33 1f       	adc	r19, r19
     fe2:	82 0f       	add	r24, r18
     fe4:	93 1f       	adc	r25, r19
     fe6:	b8 01       	movw	r22, r16
     fe8:	8a 50       	subi	r24, 0x0A	; 10
     fea:	9d 4f       	sbci	r25, 0xFD	; 253
     fec:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
     ff0:	e0 91 08 03 	lds	r30, 0x0308	; 0x800308 <pxCurrentTCB>
     ff4:	f0 91 09 03 	lds	r31, 0x0309	; 0x800309 <pxCurrentTCB+0x1>
     ff8:	9e 89       	ldd	r25, Y+22	; 0x16
     ffa:	86 89       	ldd	r24, Z+22	; 0x16
     ffc:	98 17       	cp	r25, r24
     ffe:	08 f4       	brcc	.+2      	; 0x1002 <xTaskIncrementTick+0x116>
    1000:	b2 cf       	rjmp	.-156    	; 0xf66 <xTaskIncrementTick+0x7a>
    1002:	dc 2c       	mov	r13, r12
    1004:	b0 cf       	rjmp	.-160    	; 0xf66 <xTaskIncrementTick+0x7a>
    1006:	e0 91 08 03 	lds	r30, 0x0308	; 0x800308 <pxCurrentTCB>
    100a:	f0 91 09 03 	lds	r31, 0x0309	; 0x800309 <pxCurrentTCB+0x1>
    100e:	86 89       	ldd	r24, Z+22	; 0x16
    1010:	90 e0       	ldi	r25, 0x00	; 0
    1012:	fc 01       	movw	r30, r24
    1014:	ee 0f       	add	r30, r30
    1016:	ff 1f       	adc	r31, r31
    1018:	ee 0f       	add	r30, r30
    101a:	ff 1f       	adc	r31, r31
    101c:	ee 0f       	add	r30, r30
    101e:	ff 1f       	adc	r31, r31
    1020:	8e 0f       	add	r24, r30
    1022:	9f 1f       	adc	r25, r31
    1024:	fc 01       	movw	r30, r24
    1026:	ea 50       	subi	r30, 0x0A	; 10
    1028:	fd 4f       	sbci	r31, 0xFD	; 253
    102a:	80 81       	ld	r24, Z
    102c:	82 30       	cpi	r24, 0x02	; 2
    102e:	48 f0       	brcs	.+18     	; 0x1042 <xTaskIncrementTick+0x156>
    1030:	dd 24       	eor	r13, r13
    1032:	d3 94       	inc	r13
    1034:	06 c0       	rjmp	.+12     	; 0x1042 <xTaskIncrementTick+0x156>
    1036:	80 91 d1 02 	lds	r24, 0x02D1	; 0x8002d1 <uxPendedTicks>
    103a:	8f 5f       	subi	r24, 0xFF	; 255
    103c:	80 93 d1 02 	sts	0x02D1, r24	; 0x8002d1 <uxPendedTicks>
    1040:	d1 2c       	mov	r13, r1
    1042:	80 91 d0 02 	lds	r24, 0x02D0	; 0x8002d0 <xYieldPending>
    1046:	88 23       	and	r24, r24
    1048:	11 f0       	breq	.+4      	; 0x104e <xTaskIncrementTick+0x162>
    104a:	dd 24       	eor	r13, r13
    104c:	d3 94       	inc	r13
    104e:	8d 2d       	mov	r24, r13
    1050:	df 91       	pop	r29
    1052:	cf 91       	pop	r28
    1054:	1f 91       	pop	r17
    1056:	0f 91       	pop	r16
    1058:	ff 90       	pop	r15
    105a:	ef 90       	pop	r14
    105c:	df 90       	pop	r13
    105e:	cf 90       	pop	r12
    1060:	08 95       	ret

00001062 <xTaskResumeAll>:
    1062:	df 92       	push	r13
    1064:	ef 92       	push	r14
    1066:	ff 92       	push	r15
    1068:	0f 93       	push	r16
    106a:	1f 93       	push	r17
    106c:	cf 93       	push	r28
    106e:	df 93       	push	r29
    1070:	0f b6       	in	r0, 0x3f	; 63
    1072:	f8 94       	cli
    1074:	0f 92       	push	r0
    1076:	80 91 c9 02 	lds	r24, 0x02C9	; 0x8002c9 <uxSchedulerSuspended>
    107a:	81 50       	subi	r24, 0x01	; 1
    107c:	80 93 c9 02 	sts	0x02C9, r24	; 0x8002c9 <uxSchedulerSuspended>
    1080:	80 91 c9 02 	lds	r24, 0x02C9	; 0x8002c9 <uxSchedulerSuspended>
    1084:	81 11       	cpse	r24, r1
    1086:	5f c0       	rjmp	.+190    	; 0x1146 <xTaskResumeAll+0xe4>
    1088:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <uxCurrentNumberOfTasks>
    108c:	81 11       	cpse	r24, r1
    108e:	33 c0       	rjmp	.+102    	; 0x10f6 <xTaskResumeAll+0x94>
    1090:	5d c0       	rjmp	.+186    	; 0x114c <xTaskResumeAll+0xea>
    1092:	d7 01       	movw	r26, r14
    1094:	15 96       	adiw	r26, 0x05	; 5
    1096:	ed 91       	ld	r30, X+
    1098:	fc 91       	ld	r31, X
    109a:	16 97       	sbiw	r26, 0x06	; 6
    109c:	c6 81       	ldd	r28, Z+6	; 0x06
    109e:	d7 81       	ldd	r29, Z+7	; 0x07
    10a0:	ce 01       	movw	r24, r28
    10a2:	0c 96       	adiw	r24, 0x0c	; 12
    10a4:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
    10a8:	8e 01       	movw	r16, r28
    10aa:	0e 5f       	subi	r16, 0xFE	; 254
    10ac:	1f 4f       	sbci	r17, 0xFF	; 255
    10ae:	c8 01       	movw	r24, r16
    10b0:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
    10b4:	8e 89       	ldd	r24, Y+22	; 0x16
    10b6:	90 91 d3 02 	lds	r25, 0x02D3	; 0x8002d3 <uxTopReadyPriority>
    10ba:	98 17       	cp	r25, r24
    10bc:	10 f4       	brcc	.+4      	; 0x10c2 <xTaskResumeAll+0x60>
    10be:	80 93 d3 02 	sts	0x02D3, r24	; 0x8002d3 <uxTopReadyPriority>
    10c2:	90 e0       	ldi	r25, 0x00	; 0
    10c4:	9c 01       	movw	r18, r24
    10c6:	22 0f       	add	r18, r18
    10c8:	33 1f       	adc	r19, r19
    10ca:	22 0f       	add	r18, r18
    10cc:	33 1f       	adc	r19, r19
    10ce:	22 0f       	add	r18, r18
    10d0:	33 1f       	adc	r19, r19
    10d2:	82 0f       	add	r24, r18
    10d4:	93 1f       	adc	r25, r19
    10d6:	b8 01       	movw	r22, r16
    10d8:	8a 50       	subi	r24, 0x0A	; 10
    10da:	9d 4f       	sbci	r25, 0xFD	; 253
    10dc:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
    10e0:	e0 91 08 03 	lds	r30, 0x0308	; 0x800308 <pxCurrentTCB>
    10e4:	f0 91 09 03 	lds	r31, 0x0309	; 0x800309 <pxCurrentTCB+0x1>
    10e8:	9e 89       	ldd	r25, Y+22	; 0x16
    10ea:	86 89       	ldd	r24, Z+22	; 0x16
    10ec:	98 17       	cp	r25, r24
    10ee:	68 f0       	brcs	.+26     	; 0x110a <xTaskResumeAll+0xa8>
    10f0:	d0 92 d0 02 	sts	0x02D0, r13	; 0x8002d0 <xYieldPending>
    10f4:	0a c0       	rjmp	.+20     	; 0x110a <xTaskResumeAll+0xa8>
    10f6:	c0 e0       	ldi	r28, 0x00	; 0
    10f8:	d0 e0       	ldi	r29, 0x00	; 0
    10fa:	0f 2e       	mov	r0, r31
    10fc:	f7 ed       	ldi	r31, 0xD7	; 215
    10fe:	ef 2e       	mov	r14, r31
    1100:	f2 e0       	ldi	r31, 0x02	; 2
    1102:	ff 2e       	mov	r15, r31
    1104:	f0 2d       	mov	r31, r0
    1106:	dd 24       	eor	r13, r13
    1108:	d3 94       	inc	r13
    110a:	f7 01       	movw	r30, r14
    110c:	80 81       	ld	r24, Z
    110e:	81 11       	cpse	r24, r1
    1110:	c0 cf       	rjmp	.-128    	; 0x1092 <xTaskResumeAll+0x30>
    1112:	cd 2b       	or	r28, r29
    1114:	11 f0       	breq	.+4      	; 0x111a <xTaskResumeAll+0xb8>
    1116:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <prvResetNextTaskUnblockTime>
    111a:	c0 91 d1 02 	lds	r28, 0x02D1	; 0x8002d1 <uxPendedTicks>
    111e:	cc 23       	and	r28, r28
    1120:	51 f0       	breq	.+20     	; 0x1136 <xTaskResumeAll+0xd4>
    1122:	d1 e0       	ldi	r29, 0x01	; 1
    1124:	0e 94 76 07 	call	0xeec	; 0xeec <xTaskIncrementTick>
    1128:	81 11       	cpse	r24, r1
    112a:	d0 93 d0 02 	sts	0x02D0, r29	; 0x8002d0 <xYieldPending>
    112e:	c1 50       	subi	r28, 0x01	; 1
    1130:	c9 f7       	brne	.-14     	; 0x1124 <xTaskResumeAll+0xc2>
    1132:	10 92 d1 02 	sts	0x02D1, r1	; 0x8002d1 <uxPendedTicks>
    1136:	80 91 d0 02 	lds	r24, 0x02D0	; 0x8002d0 <xYieldPending>
    113a:	88 23       	and	r24, r24
    113c:	31 f0       	breq	.+12     	; 0x114a <xTaskResumeAll+0xe8>
    113e:	0e 94 bf 02 	call	0x57e	; 0x57e <vPortYield>
    1142:	81 e0       	ldi	r24, 0x01	; 1
    1144:	03 c0       	rjmp	.+6      	; 0x114c <xTaskResumeAll+0xea>
    1146:	80 e0       	ldi	r24, 0x00	; 0
    1148:	01 c0       	rjmp	.+2      	; 0x114c <xTaskResumeAll+0xea>
    114a:	80 e0       	ldi	r24, 0x00	; 0
    114c:	0f 90       	pop	r0
    114e:	0f be       	out	0x3f, r0	; 63
    1150:	df 91       	pop	r29
    1152:	cf 91       	pop	r28
    1154:	1f 91       	pop	r17
    1156:	0f 91       	pop	r16
    1158:	ff 90       	pop	r15
    115a:	ef 90       	pop	r14
    115c:	df 90       	pop	r13
    115e:	08 95       	ret

00001160 <vTaskDelay>:
    1160:	cf 93       	push	r28
    1162:	df 93       	push	r29
    1164:	ec 01       	movw	r28, r24
    1166:	89 2b       	or	r24, r25
    1168:	51 f0       	breq	.+20     	; 0x117e <vTaskDelay+0x1e>
    116a:	0e 94 70 07 	call	0xee0	; 0xee0 <vTaskSuspendAll>
    116e:	60 e0       	ldi	r22, 0x00	; 0
    1170:	ce 01       	movw	r24, r28
    1172:	0e 94 07 06 	call	0xc0e	; 0xc0e <prvAddCurrentTaskToDelayedList>
    1176:	0e 94 31 08 	call	0x1062	; 0x1062 <xTaskResumeAll>
    117a:	81 11       	cpse	r24, r1
    117c:	02 c0       	rjmp	.+4      	; 0x1182 <vTaskDelay+0x22>
    117e:	0e 94 bf 02 	call	0x57e	; 0x57e <vPortYield>
    1182:	df 91       	pop	r29
    1184:	cf 91       	pop	r28
    1186:	08 95       	ret

00001188 <vTaskSwitchContext>:
    1188:	80 91 c9 02 	lds	r24, 0x02C9	; 0x8002c9 <uxSchedulerSuspended>
    118c:	88 23       	and	r24, r24
    118e:	21 f0       	breq	.+8      	; 0x1198 <vTaskSwitchContext+0x10>
    1190:	81 e0       	ldi	r24, 0x01	; 1
    1192:	80 93 d0 02 	sts	0x02D0, r24	; 0x8002d0 <xYieldPending>
    1196:	08 95       	ret
    1198:	10 92 d0 02 	sts	0x02D0, r1	; 0x8002d0 <xYieldPending>
    119c:	20 91 d3 02 	lds	r18, 0x02D3	; 0x8002d3 <uxTopReadyPriority>
    11a0:	82 2f       	mov	r24, r18
    11a2:	90 e0       	ldi	r25, 0x00	; 0
    11a4:	fc 01       	movw	r30, r24
    11a6:	ee 0f       	add	r30, r30
    11a8:	ff 1f       	adc	r31, r31
    11aa:	ee 0f       	add	r30, r30
    11ac:	ff 1f       	adc	r31, r31
    11ae:	ee 0f       	add	r30, r30
    11b0:	ff 1f       	adc	r31, r31
    11b2:	e8 0f       	add	r30, r24
    11b4:	f9 1f       	adc	r31, r25
    11b6:	ea 50       	subi	r30, 0x0A	; 10
    11b8:	fd 4f       	sbci	r31, 0xFD	; 253
    11ba:	30 81       	ld	r19, Z
    11bc:	31 11       	cpse	r19, r1
    11be:	11 c0       	rjmp	.+34     	; 0x11e2 <vTaskSwitchContext+0x5a>
    11c0:	21 50       	subi	r18, 0x01	; 1
    11c2:	82 2f       	mov	r24, r18
    11c4:	90 e0       	ldi	r25, 0x00	; 0
    11c6:	fc 01       	movw	r30, r24
    11c8:	ee 0f       	add	r30, r30
    11ca:	ff 1f       	adc	r31, r31
    11cc:	ee 0f       	add	r30, r30
    11ce:	ff 1f       	adc	r31, r31
    11d0:	ee 0f       	add	r30, r30
    11d2:	ff 1f       	adc	r31, r31
    11d4:	e8 0f       	add	r30, r24
    11d6:	f9 1f       	adc	r31, r25
    11d8:	ea 50       	subi	r30, 0x0A	; 10
    11da:	fd 4f       	sbci	r31, 0xFD	; 253
    11dc:	30 81       	ld	r19, Z
    11de:	33 23       	and	r19, r19
    11e0:	79 f3       	breq	.-34     	; 0x11c0 <vTaskSwitchContext+0x38>
    11e2:	ac 01       	movw	r20, r24
    11e4:	44 0f       	add	r20, r20
    11e6:	55 1f       	adc	r21, r21
    11e8:	44 0f       	add	r20, r20
    11ea:	55 1f       	adc	r21, r21
    11ec:	44 0f       	add	r20, r20
    11ee:	55 1f       	adc	r21, r21
    11f0:	48 0f       	add	r20, r24
    11f2:	59 1f       	adc	r21, r25
    11f4:	da 01       	movw	r26, r20
    11f6:	aa 50       	subi	r26, 0x0A	; 10
    11f8:	bd 4f       	sbci	r27, 0xFD	; 253
    11fa:	11 96       	adiw	r26, 0x01	; 1
    11fc:	ed 91       	ld	r30, X+
    11fe:	fc 91       	ld	r31, X
    1200:	12 97       	sbiw	r26, 0x02	; 2
    1202:	02 80       	ldd	r0, Z+2	; 0x02
    1204:	f3 81       	ldd	r31, Z+3	; 0x03
    1206:	e0 2d       	mov	r30, r0
    1208:	12 96       	adiw	r26, 0x02	; 2
    120a:	fc 93       	st	X, r31
    120c:	ee 93       	st	-X, r30
    120e:	11 97       	sbiw	r26, 0x01	; 1
    1210:	47 50       	subi	r20, 0x07	; 7
    1212:	5d 4f       	sbci	r21, 0xFD	; 253
    1214:	e4 17       	cp	r30, r20
    1216:	f5 07       	cpc	r31, r21
    1218:	29 f4       	brne	.+10     	; 0x1224 <vTaskSwitchContext+0x9c>
    121a:	42 81       	ldd	r20, Z+2	; 0x02
    121c:	53 81       	ldd	r21, Z+3	; 0x03
    121e:	fd 01       	movw	r30, r26
    1220:	52 83       	std	Z+2, r21	; 0x02
    1222:	41 83       	std	Z+1, r20	; 0x01
    1224:	fc 01       	movw	r30, r24
    1226:	ee 0f       	add	r30, r30
    1228:	ff 1f       	adc	r31, r31
    122a:	ee 0f       	add	r30, r30
    122c:	ff 1f       	adc	r31, r31
    122e:	ee 0f       	add	r30, r30
    1230:	ff 1f       	adc	r31, r31
    1232:	8e 0f       	add	r24, r30
    1234:	9f 1f       	adc	r25, r31
    1236:	fc 01       	movw	r30, r24
    1238:	ea 50       	subi	r30, 0x0A	; 10
    123a:	fd 4f       	sbci	r31, 0xFD	; 253
    123c:	01 80       	ldd	r0, Z+1	; 0x01
    123e:	f2 81       	ldd	r31, Z+2	; 0x02
    1240:	e0 2d       	mov	r30, r0
    1242:	86 81       	ldd	r24, Z+6	; 0x06
    1244:	97 81       	ldd	r25, Z+7	; 0x07
    1246:	90 93 09 03 	sts	0x0309, r25	; 0x800309 <pxCurrentTCB+0x1>
    124a:	80 93 08 03 	sts	0x0308, r24	; 0x800308 <pxCurrentTCB>
    124e:	20 93 d3 02 	sts	0x02D3, r18	; 0x8002d3 <uxTopReadyPriority>
    1252:	08 95       	ret

00001254 <vTaskPlaceOnEventList>:
    1254:	cf 93       	push	r28
    1256:	df 93       	push	r29
    1258:	eb 01       	movw	r28, r22
    125a:	60 91 08 03 	lds	r22, 0x0308	; 0x800308 <pxCurrentTCB>
    125e:	70 91 09 03 	lds	r23, 0x0309	; 0x800309 <pxCurrentTCB+0x1>
    1262:	64 5f       	subi	r22, 0xF4	; 244
    1264:	7f 4f       	sbci	r23, 0xFF	; 255
    1266:	0e 94 49 01 	call	0x292	; 0x292 <vListInsert>
    126a:	61 e0       	ldi	r22, 0x01	; 1
    126c:	ce 01       	movw	r24, r28
    126e:	0e 94 07 06 	call	0xc0e	; 0xc0e <prvAddCurrentTaskToDelayedList>
    1272:	df 91       	pop	r29
    1274:	cf 91       	pop	r28
    1276:	08 95       	ret

00001278 <xTaskRemoveFromEventList>:
    1278:	0f 93       	push	r16
    127a:	1f 93       	push	r17
    127c:	cf 93       	push	r28
    127e:	df 93       	push	r29
    1280:	dc 01       	movw	r26, r24
    1282:	15 96       	adiw	r26, 0x05	; 5
    1284:	ed 91       	ld	r30, X+
    1286:	fc 91       	ld	r31, X
    1288:	16 97       	sbiw	r26, 0x06	; 6
    128a:	c6 81       	ldd	r28, Z+6	; 0x06
    128c:	d7 81       	ldd	r29, Z+7	; 0x07
    128e:	8e 01       	movw	r16, r28
    1290:	04 5f       	subi	r16, 0xF4	; 244
    1292:	1f 4f       	sbci	r17, 0xFF	; 255
    1294:	c8 01       	movw	r24, r16
    1296:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
    129a:	80 91 c9 02 	lds	r24, 0x02C9	; 0x8002c9 <uxSchedulerSuspended>
    129e:	81 11       	cpse	r24, r1
    12a0:	1c c0       	rjmp	.+56     	; 0x12da <xTaskRemoveFromEventList+0x62>
    12a2:	0a 50       	subi	r16, 0x0A	; 10
    12a4:	11 09       	sbc	r17, r1
    12a6:	c8 01       	movw	r24, r16
    12a8:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
    12ac:	8e 89       	ldd	r24, Y+22	; 0x16
    12ae:	90 91 d3 02 	lds	r25, 0x02D3	; 0x8002d3 <uxTopReadyPriority>
    12b2:	98 17       	cp	r25, r24
    12b4:	10 f4       	brcc	.+4      	; 0x12ba <xTaskRemoveFromEventList+0x42>
    12b6:	80 93 d3 02 	sts	0x02D3, r24	; 0x8002d3 <uxTopReadyPriority>
    12ba:	90 e0       	ldi	r25, 0x00	; 0
    12bc:	9c 01       	movw	r18, r24
    12be:	22 0f       	add	r18, r18
    12c0:	33 1f       	adc	r19, r19
    12c2:	22 0f       	add	r18, r18
    12c4:	33 1f       	adc	r19, r19
    12c6:	22 0f       	add	r18, r18
    12c8:	33 1f       	adc	r19, r19
    12ca:	82 0f       	add	r24, r18
    12cc:	93 1f       	adc	r25, r19
    12ce:	b8 01       	movw	r22, r16
    12d0:	8a 50       	subi	r24, 0x0A	; 10
    12d2:	9d 4f       	sbci	r25, 0xFD	; 253
    12d4:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
    12d8:	05 c0       	rjmp	.+10     	; 0x12e4 <xTaskRemoveFromEventList+0x6c>
    12da:	b8 01       	movw	r22, r16
    12dc:	87 ed       	ldi	r24, 0xD7	; 215
    12de:	92 e0       	ldi	r25, 0x02	; 2
    12e0:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
    12e4:	e0 91 08 03 	lds	r30, 0x0308	; 0x800308 <pxCurrentTCB>
    12e8:	f0 91 09 03 	lds	r31, 0x0309	; 0x800309 <pxCurrentTCB+0x1>
    12ec:	9e 89       	ldd	r25, Y+22	; 0x16
    12ee:	86 89       	ldd	r24, Z+22	; 0x16
    12f0:	89 17       	cp	r24, r25
    12f2:	20 f4       	brcc	.+8      	; 0x12fc <xTaskRemoveFromEventList+0x84>
    12f4:	81 e0       	ldi	r24, 0x01	; 1
    12f6:	80 93 d0 02 	sts	0x02D0, r24	; 0x8002d0 <xYieldPending>
    12fa:	01 c0       	rjmp	.+2      	; 0x12fe <xTaskRemoveFromEventList+0x86>
    12fc:	80 e0       	ldi	r24, 0x00	; 0
    12fe:	df 91       	pop	r29
    1300:	cf 91       	pop	r28
    1302:	1f 91       	pop	r17
    1304:	0f 91       	pop	r16
    1306:	08 95       	ret

00001308 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1308:	20 91 cf 02 	lds	r18, 0x02CF	; 0x8002cf <xNumOfOverflows>
    130c:	fc 01       	movw	r30, r24
    130e:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1310:	20 91 d4 02 	lds	r18, 0x02D4	; 0x8002d4 <xTickCount>
    1314:	30 91 d5 02 	lds	r19, 0x02D5	; 0x8002d5 <xTickCount+0x1>
    1318:	32 83       	std	Z+2, r19	; 0x02
    131a:	21 83       	std	Z+1, r18	; 0x01
    131c:	08 95       	ret

0000131e <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    131e:	cf 93       	push	r28
    1320:	df 93       	push	r29
    1322:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1324:	0f b6       	in	r0, 0x3f	; 63
    1326:	f8 94       	cli
    1328:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    132a:	20 91 d4 02 	lds	r18, 0x02D4	; 0x8002d4 <xTickCount>
    132e:	30 91 d5 02 	lds	r19, 0x02D5	; 0x8002d5 <xTickCount+0x1>
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1332:	80 91 cf 02 	lds	r24, 0x02CF	; 0x8002cf <xNumOfOverflows>
    1336:	90 81       	ld	r25, Z
    1338:	98 17       	cp	r25, r24
    133a:	29 f0       	breq	.+10     	; 0x1346 <xTaskCheckForTimeOut+0x28>
    133c:	81 81       	ldd	r24, Z+1	; 0x01
    133e:	92 81       	ldd	r25, Z+2	; 0x02
    1340:	28 17       	cp	r18, r24
    1342:	39 07       	cpc	r19, r25
    1344:	b0 f4       	brcc	.+44     	; 0x1372 <xTaskCheckForTimeOut+0x54>
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    1346:	a1 81       	ldd	r26, Z+1	; 0x01
    1348:	b2 81       	ldd	r27, Z+2	; 0x02
    134a:	eb 01       	movw	r28, r22
    134c:	48 81       	ld	r20, Y
    134e:	59 81       	ldd	r21, Y+1	; 0x01
    1350:	c9 01       	movw	r24, r18
    1352:	8a 1b       	sub	r24, r26
    1354:	9b 0b       	sbc	r25, r27
    1356:	84 17       	cp	r24, r20
    1358:	95 07       	cpc	r25, r21
    135a:	68 f4       	brcc	.+26     	; 0x1376 <xTaskCheckForTimeOut+0x58>
    135c:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    135e:	a2 1b       	sub	r26, r18
    1360:	b3 0b       	sbc	r27, r19
    1362:	4a 0f       	add	r20, r26
    1364:	5b 1f       	adc	r21, r27
    1366:	59 83       	std	Y+1, r21	; 0x01
    1368:	48 83       	st	Y, r20
			vTaskSetTimeOutState( pxTimeOut );
    136a:	0e 94 84 09 	call	0x1308	; 0x1308 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    136e:	80 e0       	ldi	r24, 0x00	; 0
    1370:	03 c0       	rjmp	.+6      	; 0x1378 <xTaskCheckForTimeOut+0x5a>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    1372:	81 e0       	ldi	r24, 0x01	; 1
    1374:	01 c0       	rjmp	.+2      	; 0x1378 <xTaskCheckForTimeOut+0x5a>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    1376:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1378:	0f 90       	pop	r0
    137a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    137c:	df 91       	pop	r29
    137e:	cf 91       	pop	r28
    1380:	08 95       	ret

00001382 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    1382:	81 e0       	ldi	r24, 0x01	; 1
    1384:	80 93 d0 02 	sts	0x02D0, r24	; 0x8002d0 <xYieldPending>
    1388:	08 95       	ret

0000138a <memcpy>:
    138a:	fb 01       	movw	r30, r22
    138c:	dc 01       	movw	r26, r24
    138e:	02 c0       	rjmp	.+4      	; 0x1394 <memcpy+0xa>
    1390:	01 90       	ld	r0, Z+
    1392:	0d 92       	st	X+, r0
    1394:	41 50       	subi	r20, 0x01	; 1
    1396:	50 40       	sbci	r21, 0x00	; 0
    1398:	d8 f7       	brcc	.-10     	; 0x1390 <memcpy+0x6>
    139a:	08 95       	ret

0000139c <_exit>:
    139c:	f8 94       	cli

0000139e <__stop_program>:
    139e:	ff cf       	rjmp	.-2      	; 0x139e <__stop_program>
