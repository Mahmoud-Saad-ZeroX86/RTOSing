
FREERTOS_V9.0.0_atmega32_Z_SecondShoot.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000013c0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000001a  00800060  000013c0  00001454  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002a4  0080007a  0080007a  0000146e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000146e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000014a0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000290  00000000  00000000  000014dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000036f5  00000000  00000000  0000176c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000faa  00000000  00000000  00004e61  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001c85  00000000  00000000  00005e0b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000007dc  00000000  00000000  00007a90  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000117d  00000000  00000000  0000826c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000344a  00000000  00000000  000093e9  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000002d8  00000000  00000000  0000c833  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 91 03 	jmp	0x722	; 0x722 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e0 ec       	ldi	r30, 0xC0	; 192
      68:	f3 e1       	ldi	r31, 0x13	; 19
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	aa 37       	cpi	r26, 0x7A	; 122
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	23 e0       	ldi	r18, 0x03	; 3
      78:	aa e7       	ldi	r26, 0x7A	; 122
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ae 31       	cpi	r26, 0x1E	; 30
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 dd 01 	call	0x3ba	; 0x3ba <main>
      8a:	0c 94 de 09 	jmp	0x13bc	; 0x13bc <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
      92:	0f 93       	push	r16
      94:	1f 93       	push	r17
      96:	cf 93       	push	r28
      98:	df 93       	push	r29
      9a:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
      9c:	0e 94 94 07 	call	0xf28	; 0xf28 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
      a0:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__data_end>
      a4:	81 11       	cpse	r24, r1
      a6:	1d c0       	rjmp	.+58     	; 0xe2 <pvPortMalloc+0x50>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
      a8:	ef e7       	ldi	r30, 0x7F	; 127
      aa:	f0 e0       	ldi	r31, 0x00	; 0
      ac:	84 e8       	ldi	r24, 0x84	; 132
      ae:	90 e0       	ldi	r25, 0x00	; 0
      b0:	91 83       	std	Z+1, r25	; 0x01
      b2:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
      b4:	13 82       	std	Z+3, r1	; 0x03
      b6:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
      b8:	eb e7       	ldi	r30, 0x7B	; 123
      ba:	f0 e0       	ldi	r31, 0x00	; 0
      bc:	87 e5       	ldi	r24, 0x57	; 87
      be:	92 e0       	ldi	r25, 0x02	; 2
      c0:	93 83       	std	Z+3, r25	; 0x03
      c2:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
      c4:	11 82       	std	Z+1, r1	; 0x01
      c6:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
      c8:	a3 e8       	ldi	r26, 0x83	; 131
      ca:	b0 e0       	ldi	r27, 0x00	; 0
      cc:	14 96       	adiw	r26, 0x04	; 4
      ce:	9c 93       	st	X, r25
      d0:	8e 93       	st	-X, r24
      d2:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
      d4:	12 96       	adiw	r26, 0x02	; 2
      d6:	fc 93       	st	X, r31
      d8:	ee 93       	st	-X, r30
      da:	11 97       	sbiw	r26, 0x01	; 1
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
      dc:	81 e0       	ldi	r24, 0x01	; 1
      de:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__data_end>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
      e2:	20 97       	sbiw	r28, 0x00	; 0
      e4:	09 f4       	brne	.+2      	; 0xe8 <pvPortMalloc+0x56>
      e6:	5f c0       	rjmp	.+190    	; 0x1a6 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
      e8:	9e 01       	movw	r18, r28
      ea:	2c 5f       	subi	r18, 0xFC	; 252
      ec:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
      ee:	23 96       	adiw	r28, 0x03	; 3
      f0:	c6 35       	cpi	r28, 0x56	; 86
      f2:	d2 40       	sbci	r29, 0x02	; 2
      f4:	08 f0       	brcs	.+2      	; 0xf8 <pvPortMalloc+0x66>
      f6:	5a c0       	rjmp	.+180    	; 0x1ac <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
      f8:	e0 91 7f 00 	lds	r30, 0x007F	; 0x80007f <xStart>
      fc:	f0 91 80 00 	lds	r31, 0x0080	; 0x800080 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     100:	af e7       	ldi	r26, 0x7F	; 127
     102:	b0 e0       	ldi	r27, 0x00	; 0
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     104:	02 c0       	rjmp	.+4      	; 0x10a <pvPortMalloc+0x78>
     106:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     108:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     10a:	82 81       	ldd	r24, Z+2	; 0x02
     10c:	93 81       	ldd	r25, Z+3	; 0x03
     10e:	82 17       	cp	r24, r18
     110:	93 07       	cpc	r25, r19
     112:	20 f4       	brcc	.+8      	; 0x11c <pvPortMalloc+0x8a>
     114:	80 81       	ld	r24, Z
     116:	91 81       	ldd	r25, Z+1	; 0x01
     118:	00 97       	sbiw	r24, 0x00	; 0
     11a:	a9 f7       	brne	.-22     	; 0x106 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     11c:	c0 e0       	ldi	r28, 0x00	; 0
     11e:	eb 37       	cpi	r30, 0x7B	; 123
     120:	fc 07       	cpc	r31, r28
     122:	09 f4       	brne	.+2      	; 0x126 <pvPortMalloc+0x94>
     124:	46 c0       	rjmp	.+140    	; 0x1b2 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     126:	cd 91       	ld	r28, X+
     128:	dc 91       	ld	r29, X
     12a:	11 97       	sbiw	r26, 0x01	; 1
     12c:	8e 01       	movw	r16, r28
     12e:	0c 5f       	subi	r16, 0xFC	; 252
     130:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     132:	80 81       	ld	r24, Z
     134:	91 81       	ldd	r25, Z+1	; 0x01
     136:	8d 93       	st	X+, r24
     138:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     13a:	82 81       	ldd	r24, Z+2	; 0x02
     13c:	93 81       	ldd	r25, Z+3	; 0x03
     13e:	82 1b       	sub	r24, r18
     140:	93 0b       	sbc	r25, r19
     142:	89 30       	cpi	r24, 0x09	; 9
     144:	91 05       	cpc	r25, r1
     146:	10 f1       	brcs	.+68     	; 0x18c <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     148:	bf 01       	movw	r22, r30
     14a:	62 0f       	add	r22, r18
     14c:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     14e:	db 01       	movw	r26, r22
     150:	13 96       	adiw	r26, 0x03	; 3
     152:	9c 93       	st	X, r25
     154:	8e 93       	st	-X, r24
     156:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     158:	33 83       	std	Z+3, r19	; 0x03
     15a:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     15c:	12 96       	adiw	r26, 0x02	; 2
     15e:	4d 91       	ld	r20, X+
     160:	5c 91       	ld	r21, X
     162:	13 97       	sbiw	r26, 0x03	; 3
     164:	8f e7       	ldi	r24, 0x7F	; 127
     166:	90 e0       	ldi	r25, 0x00	; 0
     168:	01 c0       	rjmp	.+2      	; 0x16c <pvPortMalloc+0xda>
     16a:	cd 01       	movw	r24, r26
     16c:	ec 01       	movw	r28, r24
     16e:	a8 81       	ld	r26, Y
     170:	b9 81       	ldd	r27, Y+1	; 0x01
     172:	12 96       	adiw	r26, 0x02	; 2
     174:	2d 91       	ld	r18, X+
     176:	3c 91       	ld	r19, X
     178:	13 97       	sbiw	r26, 0x03	; 3
     17a:	24 17       	cp	r18, r20
     17c:	35 07       	cpc	r19, r21
     17e:	a8 f3       	brcs	.-22     	; 0x16a <pvPortMalloc+0xd8>
     180:	eb 01       	movw	r28, r22
     182:	b9 83       	std	Y+1, r27	; 0x01
     184:	a8 83       	st	Y, r26
     186:	dc 01       	movw	r26, r24
     188:	6d 93       	st	X+, r22
     18a:	7c 93       	st	X, r23
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     18c:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
     190:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__data_start+0x1>
     194:	22 81       	ldd	r18, Z+2	; 0x02
     196:	33 81       	ldd	r19, Z+3	; 0x03
     198:	82 1b       	sub	r24, r18
     19a:	93 0b       	sbc	r25, r19
     19c:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
     1a0:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
     1a4:	08 c0       	rjmp	.+16     	; 0x1b6 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     1a6:	00 e0       	ldi	r16, 0x00	; 0
     1a8:	10 e0       	ldi	r17, 0x00	; 0
     1aa:	05 c0       	rjmp	.+10     	; 0x1b6 <pvPortMalloc+0x124>
     1ac:	00 e0       	ldi	r16, 0x00	; 0
     1ae:	10 e0       	ldi	r17, 0x00	; 0
     1b0:	02 c0       	rjmp	.+4      	; 0x1b6 <pvPortMalloc+0x124>
     1b2:	00 e0       	ldi	r16, 0x00	; 0
     1b4:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     1b6:	0e 94 55 08 	call	0x10aa	; 0x10aa <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     1ba:	c8 01       	movw	r24, r16
     1bc:	df 91       	pop	r29
     1be:	cf 91       	pop	r28
     1c0:	1f 91       	pop	r17
     1c2:	0f 91       	pop	r16
     1c4:	08 95       	ret

000001c6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     1c6:	0f 93       	push	r16
     1c8:	1f 93       	push	r17
     1ca:	cf 93       	push	r28
     1cc:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     1ce:	00 97       	sbiw	r24, 0x00	; 0
     1d0:	41 f1       	breq	.+80     	; 0x222 <vPortFree+0x5c>
     1d2:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     1d4:	8c 01       	movw	r16, r24
     1d6:	04 50       	subi	r16, 0x04	; 4
     1d8:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     1da:	0e 94 94 07 	call	0xf28	; 0xf28 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     1de:	f8 01       	movw	r30, r16
     1e0:	42 81       	ldd	r20, Z+2	; 0x02
     1e2:	53 81       	ldd	r21, Z+3	; 0x03
     1e4:	af e7       	ldi	r26, 0x7F	; 127
     1e6:	b0 e0       	ldi	r27, 0x00	; 0
     1e8:	01 c0       	rjmp	.+2      	; 0x1ec <vPortFree+0x26>
     1ea:	df 01       	movw	r26, r30
     1ec:	ed 91       	ld	r30, X+
     1ee:	fc 91       	ld	r31, X
     1f0:	11 97       	sbiw	r26, 0x01	; 1
     1f2:	22 81       	ldd	r18, Z+2	; 0x02
     1f4:	33 81       	ldd	r19, Z+3	; 0x03
     1f6:	24 17       	cp	r18, r20
     1f8:	35 07       	cpc	r19, r21
     1fa:	b8 f3       	brcs	.-18     	; 0x1ea <vPortFree+0x24>
     1fc:	24 97       	sbiw	r28, 0x04	; 4
     1fe:	f9 83       	std	Y+1, r31	; 0x01
     200:	e8 83       	st	Y, r30
     202:	0d 93       	st	X+, r16
     204:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     206:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <__data_start>
     20a:	30 91 61 00 	lds	r19, 0x0061	; 0x800061 <__data_start+0x1>
     20e:	8a 81       	ldd	r24, Y+2	; 0x02
     210:	9b 81       	ldd	r25, Y+3	; 0x03
     212:	82 0f       	add	r24, r18
     214:	93 1f       	adc	r25, r19
     216:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
     21a:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     21e:	0e 94 55 08 	call	0x10aa	; 0x10aa <xTaskResumeAll>
	}
}
     222:	df 91       	pop	r29
     224:	cf 91       	pop	r28
     226:	1f 91       	pop	r17
     228:	0f 91       	pop	r16
     22a:	08 95       	ret

0000022c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     22c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     22e:	03 96       	adiw	r24, 0x03	; 3
     230:	92 83       	std	Z+2, r25	; 0x02
     232:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     234:	2f ef       	ldi	r18, 0xFF	; 255
     236:	3f ef       	ldi	r19, 0xFF	; 255
     238:	34 83       	std	Z+4, r19	; 0x04
     23a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     23c:	96 83       	std	Z+6, r25	; 0x06
     23e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     240:	90 87       	std	Z+8, r25	; 0x08
     242:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     244:	10 82       	st	Z, r1
     246:	08 95       	ret

00000248 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     248:	fc 01       	movw	r30, r24
     24a:	11 86       	std	Z+9, r1	; 0x09
     24c:	10 86       	std	Z+8, r1	; 0x08
     24e:	08 95       	ret

00000250 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     250:	cf 93       	push	r28
     252:	df 93       	push	r29
     254:	9c 01       	movw	r18, r24
     256:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     258:	dc 01       	movw	r26, r24
     25a:	11 96       	adiw	r26, 0x01	; 1
     25c:	cd 91       	ld	r28, X+
     25e:	dc 91       	ld	r29, X
     260:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     262:	d3 83       	std	Z+3, r29	; 0x03
     264:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     266:	8c 81       	ldd	r24, Y+4	; 0x04
     268:	9d 81       	ldd	r25, Y+5	; 0x05
     26a:	95 83       	std	Z+5, r25	; 0x05
     26c:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     26e:	8c 81       	ldd	r24, Y+4	; 0x04
     270:	9d 81       	ldd	r25, Y+5	; 0x05
     272:	dc 01       	movw	r26, r24
     274:	13 96       	adiw	r26, 0x03	; 3
     276:	7c 93       	st	X, r23
     278:	6e 93       	st	-X, r22
     27a:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     27c:	7d 83       	std	Y+5, r23	; 0x05
     27e:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     280:	31 87       	std	Z+9, r19	; 0x09
     282:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     284:	f9 01       	movw	r30, r18
     286:	80 81       	ld	r24, Z
     288:	8f 5f       	subi	r24, 0xFF	; 255
     28a:	80 83       	st	Z, r24
}
     28c:	df 91       	pop	r29
     28e:	cf 91       	pop	r28
     290:	08 95       	ret

00000292 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     292:	cf 93       	push	r28
     294:	df 93       	push	r29
     296:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     298:	48 81       	ld	r20, Y
     29a:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     29c:	4f 3f       	cpi	r20, 0xFF	; 255
     29e:	2f ef       	ldi	r18, 0xFF	; 255
     2a0:	52 07       	cpc	r21, r18
     2a2:	21 f4       	brne	.+8      	; 0x2ac <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     2a4:	fc 01       	movw	r30, r24
     2a6:	a7 81       	ldd	r26, Z+7	; 0x07
     2a8:	b0 85       	ldd	r27, Z+8	; 0x08
     2aa:	0d c0       	rjmp	.+26     	; 0x2c6 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     2ac:	dc 01       	movw	r26, r24
     2ae:	13 96       	adiw	r26, 0x03	; 3
     2b0:	01 c0       	rjmp	.+2      	; 0x2b4 <vListInsert+0x22>
     2b2:	df 01       	movw	r26, r30
     2b4:	12 96       	adiw	r26, 0x02	; 2
     2b6:	ed 91       	ld	r30, X+
     2b8:	fc 91       	ld	r31, X
     2ba:	13 97       	sbiw	r26, 0x03	; 3
     2bc:	20 81       	ld	r18, Z
     2be:	31 81       	ldd	r19, Z+1	; 0x01
     2c0:	42 17       	cp	r20, r18
     2c2:	53 07       	cpc	r21, r19
     2c4:	b0 f7       	brcc	.-20     	; 0x2b2 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     2c6:	12 96       	adiw	r26, 0x02	; 2
     2c8:	ed 91       	ld	r30, X+
     2ca:	fc 91       	ld	r31, X
     2cc:	13 97       	sbiw	r26, 0x03	; 3
     2ce:	fb 83       	std	Y+3, r31	; 0x03
     2d0:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     2d2:	d5 83       	std	Z+5, r29	; 0x05
     2d4:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     2d6:	bd 83       	std	Y+5, r27	; 0x05
     2d8:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     2da:	13 96       	adiw	r26, 0x03	; 3
     2dc:	dc 93       	st	X, r29
     2de:	ce 93       	st	-X, r28
     2e0:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     2e2:	99 87       	std	Y+9, r25	; 0x09
     2e4:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     2e6:	fc 01       	movw	r30, r24
     2e8:	20 81       	ld	r18, Z
     2ea:	2f 5f       	subi	r18, 0xFF	; 255
     2ec:	20 83       	st	Z, r18
}
     2ee:	df 91       	pop	r29
     2f0:	cf 91       	pop	r28
     2f2:	08 95       	ret

000002f4 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     2f4:	cf 93       	push	r28
     2f6:	df 93       	push	r29
     2f8:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     2fa:	a0 85       	ldd	r26, Z+8	; 0x08
     2fc:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     2fe:	c2 81       	ldd	r28, Z+2	; 0x02
     300:	d3 81       	ldd	r29, Z+3	; 0x03
     302:	84 81       	ldd	r24, Z+4	; 0x04
     304:	95 81       	ldd	r25, Z+5	; 0x05
     306:	9d 83       	std	Y+5, r25	; 0x05
     308:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     30a:	c4 81       	ldd	r28, Z+4	; 0x04
     30c:	d5 81       	ldd	r29, Z+5	; 0x05
     30e:	82 81       	ldd	r24, Z+2	; 0x02
     310:	93 81       	ldd	r25, Z+3	; 0x03
     312:	9b 83       	std	Y+3, r25	; 0x03
     314:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     316:	11 96       	adiw	r26, 0x01	; 1
     318:	8d 91       	ld	r24, X+
     31a:	9c 91       	ld	r25, X
     31c:	12 97       	sbiw	r26, 0x02	; 2
     31e:	e8 17       	cp	r30, r24
     320:	f9 07       	cpc	r31, r25
     322:	31 f4       	brne	.+12     	; 0x330 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     324:	84 81       	ldd	r24, Z+4	; 0x04
     326:	95 81       	ldd	r25, Z+5	; 0x05
     328:	12 96       	adiw	r26, 0x02	; 2
     32a:	9c 93       	st	X, r25
     32c:	8e 93       	st	-X, r24
     32e:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     330:	11 86       	std	Z+9, r1	; 0x09
     332:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     334:	8c 91       	ld	r24, X
     336:	81 50       	subi	r24, 0x01	; 1
     338:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     33a:	df 91       	pop	r29
     33c:	cf 91       	pop	r28
     33e:	08 95       	ret

00000340 <TX_F>:
		PORTA=PORTB=PORTC=PORTD=0x55;
	}
	
}
void TX_F(void * pv)
{
     340:	8c 01       	movw	r16, r24
	
	while(1)
	{
		PORTC ^=(1<<1);
     342:	c2 e0       	ldi	r28, 0x02	; 2
		portBASE_TYPE stat= xQueueSendToBack(queue_1_handle,pv,10);
		if (stat==pdFAIL)
		{
			PORTA=0xff;
     344:	df ef       	ldi	r29, 0xFF	; 255
void TX_F(void * pv)
{
	
	while(1)
	{
		PORTC ^=(1<<1);
     346:	85 b3       	in	r24, 0x15	; 21
     348:	8c 27       	eor	r24, r28
     34a:	85 bb       	out	0x15, r24	; 21
		portBASE_TYPE stat= xQueueSendToBack(queue_1_handle,pv,10);
     34c:	20 e0       	ldi	r18, 0x00	; 0
     34e:	4a e0       	ldi	r20, 0x0A	; 10
     350:	50 e0       	ldi	r21, 0x00	; 0
     352:	b8 01       	movw	r22, r16
     354:	80 91 1c 03 	lds	r24, 0x031C	; 0x80031c <queue_1_handle>
     358:	90 91 1d 03 	lds	r25, 0x031D	; 0x80031d <queue_1_handle+0x1>
     35c:	0e 94 ae 04 	call	0x95c	; 0x95c <xQueueGenericSend>
		if (stat==pdFAIL)
     360:	81 11       	cpse	r24, r1
     362:	01 c0       	rjmp	.+2      	; 0x366 <TX_F+0x26>
		{
			PORTA=0xff;
     364:	db bb       	out	0x1b, r29	; 27
		}
		taskYIELD();
     366:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <vPortYield>
		//vTaskDelay(100/portTICK_RATE_MS);
	}
     36a:	ed cf       	rjmp	.-38     	; 0x346 <TX_F+0x6>

0000036c <RX_F>:
}


void RX_F(void * pv)
{
     36c:	cf 93       	push	r28
     36e:	df 93       	push	r29
     370:	00 d0       	rcall	.+0      	; 0x372 <RX_F+0x6>
     372:	00 d0       	rcall	.+0      	; 0x374 <RX_F+0x8>
     374:	1f 92       	push	r1
     376:	cd b7       	in	r28, 0x3d	; 61
     378:	de b7       	in	r29, 0x3e	; 62
	xData_t rx_buff;
	while(1)
	{
		PORTC ^=(1<<2);
     37a:	14 e0       	ldi	r17, 0x04	; 4
     37c:	85 b3       	in	r24, 0x15	; 21
     37e:	81 27       	eor	r24, r17
     380:	85 bb       	out	0x15, r24	; 21
		xQueueReceive(queue_1_handle,&rx_buff,10);
     382:	20 e0       	ldi	r18, 0x00	; 0
     384:	4a e0       	ldi	r20, 0x0A	; 10
     386:	50 e0       	ldi	r21, 0x00	; 0
     388:	be 01       	movw	r22, r28
     38a:	6f 5f       	subi	r22, 0xFF	; 255
     38c:	7f 4f       	sbci	r23, 0xFF	; 255
     38e:	80 91 1c 03 	lds	r24, 0x031C	; 0x80031c <queue_1_handle>
     392:	90 91 1d 03 	lds	r25, 0x031D	; 0x80031d <queue_1_handle+0x1>
     396:	0e 94 4f 05 	call	0xa9e	; 0xa9e <xQueueGenericReceive>
		PORTB= rx_buff.val_a;
     39a:	89 81       	ldd	r24, Y+1	; 0x01
     39c:	88 bb       	out	0x18, r24	; 24
     39e:	8f ef       	ldi	r24, 0xFF	; 255
     3a0:	81 50       	subi	r24, 0x01	; 1
		for(portBASE_TYPE i=1;i>0;i++);
     3a2:	f1 f7       	brne	.-4      	; 0x3a0 <RX_F+0x34>
		//for(portBASE_TYPE i=1;i>0;i++);
		PORTB= rx_buff.val_b;
     3a4:	8a 81       	ldd	r24, Y+2	; 0x02
     3a6:	88 bb       	out	0x18, r24	; 24
     3a8:	8f ef       	ldi	r24, 0xFF	; 255
     3aa:	81 50       	subi	r24, 0x01	; 1
		for(portBASE_TYPE i=1;i>0;i++);
     3ac:	f1 f7       	brne	.-4      	; 0x3aa <RX_F+0x3e>
		//for(portBASE_TYPE i=1;i>0;i++);
		PORTB= rx_buff.val_c;
     3ae:	8b 81       	ldd	r24, Y+3	; 0x03
     3b0:	88 bb       	out	0x18, r24	; 24
     3b2:	8f ef       	ldi	r24, 0xFF	; 255
     3b4:	81 50       	subi	r24, 0x01	; 1
		for(portBASE_TYPE i=1;i>0;i++);
     3b6:	f1 f7       	brne	.-4      	; 0x3b4 <RX_F+0x48>
     3b8:	e1 cf       	rjmp	.-62     	; 0x37c <RX_F+0x10>

000003ba <main>:
	portBASE_TYPE val_b;
	portBASE_TYPE val_c;
	portBASE_TYPE *ptr_name;
}xData_t;
void main(void)
{
     3ba:	ef 92       	push	r14
     3bc:	ff 92       	push	r15
     3be:	0f 93       	push	r16
     3c0:	cf 93       	push	r28
     3c2:	df 93       	push	r29
     3c4:	cd b7       	in	r28, 0x3d	; 61
     3c6:	de b7       	in	r29, 0x3e	; 62
     3c8:	2a 97       	sbiw	r28, 0x0a	; 10
     3ca:	0f b6       	in	r0, 0x3f	; 63
     3cc:	f8 94       	cli
     3ce:	de bf       	out	0x3e, r29	; 62
     3d0:	0f be       	out	0x3f, r0	; 63
     3d2:	cd bf       	out	0x3d, r28	; 61
	xData_t data_arr[2]={{2,4,6,"MSA"},{3,5,7,"MMA"}};
     3d4:	8a e0       	ldi	r24, 0x0A	; 10
     3d6:	e2 e6       	ldi	r30, 0x62	; 98
     3d8:	f0 e0       	ldi	r31, 0x00	; 0
     3da:	de 01       	movw	r26, r28
     3dc:	11 96       	adiw	r26, 0x01	; 1
     3de:	01 90       	ld	r0, Z+
     3e0:	0d 92       	st	X+, r0
     3e2:	8a 95       	dec	r24
     3e4:	e1 f7       	brne	.-8      	; 0x3de <main+0x24>
	DDRA=0xff;		DDRB=0xff;		DDRC=0xff;		DDRD=0xff;
     3e6:	8f ef       	ldi	r24, 0xFF	; 255
     3e8:	8a bb       	out	0x1a, r24	; 26
     3ea:	87 bb       	out	0x17, r24	; 23
     3ec:	84 bb       	out	0x14, r24	; 20
     3ee:	81 bb       	out	0x11, r24	; 17
	char msa=0xff;
	queue_1_handle=xQueueCreate( 3,sizeof(xData_t));
     3f0:	40 e0       	ldi	r20, 0x00	; 0
     3f2:	65 e0       	ldi	r22, 0x05	; 5
     3f4:	83 e0       	ldi	r24, 0x03	; 3
     3f6:	0e 94 81 04 	call	0x902	; 0x902 <xQueueGenericCreate>
     3fa:	90 93 1d 03 	sts	0x031D, r25	; 0x80031d <queue_1_handle+0x1>
     3fe:	80 93 1c 03 	sts	0x031C, r24	; 0x80031c <queue_1_handle>
	if (queue_1_handle != NULL)
     402:	89 2b       	or	r24, r25
     404:	39 f1       	breq	.+78     	; 0x454 <__LOCK_REGION_LENGTH__+0x54>
	{
	
	xTaskCreate(TX_F,NULL,configMINIMAL_STACK_SIZE,(void *)&data_arr[0],2,NULL);
     406:	e1 2c       	mov	r14, r1
     408:	f1 2c       	mov	r15, r1
     40a:	02 e0       	ldi	r16, 0x02	; 2
     40c:	9e 01       	movw	r18, r28
     40e:	2f 5f       	subi	r18, 0xFF	; 255
     410:	3f 4f       	sbci	r19, 0xFF	; 255
     412:	45 e5       	ldi	r20, 0x55	; 85
     414:	50 e0       	ldi	r21, 0x00	; 0
     416:	60 e0       	ldi	r22, 0x00	; 0
     418:	70 e0       	ldi	r23, 0x00	; 0
     41a:	80 ea       	ldi	r24, 0xA0	; 160
     41c:	91 e0       	ldi	r25, 0x01	; 1
     41e:	0e 94 6f 06 	call	0xcde	; 0xcde <xTaskCreate>
	xTaskCreate(TX_F,NULL,configMINIMAL_STACK_SIZE,(void *)&data_arr[1],2,NULL);
     422:	9e 01       	movw	r18, r28
     424:	2a 5f       	subi	r18, 0xFA	; 250
     426:	3f 4f       	sbci	r19, 0xFF	; 255
     428:	45 e5       	ldi	r20, 0x55	; 85
     42a:	50 e0       	ldi	r21, 0x00	; 0
     42c:	60 e0       	ldi	r22, 0x00	; 0
     42e:	70 e0       	ldi	r23, 0x00	; 0
     430:	80 ea       	ldi	r24, 0xA0	; 160
     432:	91 e0       	ldi	r25, 0x01	; 1
     434:	0e 94 6f 06 	call	0xcde	; 0xcde <xTaskCreate>
	xTaskCreate(RX_F,NULL,configMINIMAL_STACK_SIZE,NULL,1,NULL);
     438:	01 e0       	ldi	r16, 0x01	; 1
     43a:	20 e0       	ldi	r18, 0x00	; 0
     43c:	30 e0       	ldi	r19, 0x00	; 0
     43e:	45 e5       	ldi	r20, 0x55	; 85
     440:	50 e0       	ldi	r21, 0x00	; 0
     442:	60 e0       	ldi	r22, 0x00	; 0
     444:	70 e0       	ldi	r23, 0x00	; 0
     446:	86 eb       	ldi	r24, 0xB6	; 182
     448:	91 e0       	ldi	r25, 0x01	; 1
     44a:	0e 94 6f 06 	call	0xcde	; 0xcde <xTaskCreate>
	
	vTaskStartScheduler();
     44e:	0e 94 6a 07 	call	0xed4	; 0xed4 <vTaskStartScheduler>
     452:	05 c0       	rjmp	.+10     	; 0x45e <__LOCK_REGION_LENGTH__+0x5e>
	}
	else //couldn't create a queue
	{
		PORTA=PORTB=PORTC=PORTD=0x55;
     454:	85 e5       	ldi	r24, 0x55	; 85
     456:	82 bb       	out	0x12, r24	; 18
     458:	85 bb       	out	0x15, r24	; 21
     45a:	88 bb       	out	0x18, r24	; 24
     45c:	8b bb       	out	0x1b, r24	; 27
	}
	
}
     45e:	2a 96       	adiw	r28, 0x0a	; 10
     460:	0f b6       	in	r0, 0x3f	; 63
     462:	f8 94       	cli
     464:	de bf       	out	0x3e, r29	; 62
     466:	0f be       	out	0x3f, r0	; 63
     468:	cd bf       	out	0x3d, r28	; 61
     46a:	df 91       	pop	r29
     46c:	cf 91       	pop	r28
     46e:	0f 91       	pop	r16
     470:	ff 90       	pop	r15
     472:	ef 90       	pop	r14
     474:	08 95       	ret

00000476 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     476:	31 e1       	ldi	r19, 0x11	; 17
     478:	fc 01       	movw	r30, r24
     47a:	30 83       	st	Z, r19
     47c:	31 97       	sbiw	r30, 0x01	; 1
     47e:	22 e2       	ldi	r18, 0x22	; 34
     480:	20 83       	st	Z, r18
     482:	31 97       	sbiw	r30, 0x01	; 1
     484:	a3 e3       	ldi	r26, 0x33	; 51
     486:	a0 83       	st	Z, r26
     488:	31 97       	sbiw	r30, 0x01	; 1
     48a:	60 83       	st	Z, r22
     48c:	31 97       	sbiw	r30, 0x01	; 1
     48e:	70 83       	st	Z, r23
     490:	31 97       	sbiw	r30, 0x01	; 1
     492:	10 82       	st	Z, r1
     494:	31 97       	sbiw	r30, 0x01	; 1
     496:	60 e8       	ldi	r22, 0x80	; 128
     498:	60 83       	st	Z, r22
     49a:	31 97       	sbiw	r30, 0x01	; 1
     49c:	10 82       	st	Z, r1
     49e:	31 97       	sbiw	r30, 0x01	; 1
     4a0:	62 e0       	ldi	r22, 0x02	; 2
     4a2:	60 83       	st	Z, r22
     4a4:	31 97       	sbiw	r30, 0x01	; 1
     4a6:	63 e0       	ldi	r22, 0x03	; 3
     4a8:	60 83       	st	Z, r22
     4aa:	31 97       	sbiw	r30, 0x01	; 1
     4ac:	64 e0       	ldi	r22, 0x04	; 4
     4ae:	60 83       	st	Z, r22
     4b0:	31 97       	sbiw	r30, 0x01	; 1
     4b2:	65 e0       	ldi	r22, 0x05	; 5
     4b4:	60 83       	st	Z, r22
     4b6:	31 97       	sbiw	r30, 0x01	; 1
     4b8:	66 e0       	ldi	r22, 0x06	; 6
     4ba:	60 83       	st	Z, r22
     4bc:	31 97       	sbiw	r30, 0x01	; 1
     4be:	67 e0       	ldi	r22, 0x07	; 7
     4c0:	60 83       	st	Z, r22
     4c2:	31 97       	sbiw	r30, 0x01	; 1
     4c4:	68 e0       	ldi	r22, 0x08	; 8
     4c6:	60 83       	st	Z, r22
     4c8:	31 97       	sbiw	r30, 0x01	; 1
     4ca:	69 e0       	ldi	r22, 0x09	; 9
     4cc:	60 83       	st	Z, r22
     4ce:	31 97       	sbiw	r30, 0x01	; 1
     4d0:	60 e1       	ldi	r22, 0x10	; 16
     4d2:	60 83       	st	Z, r22
     4d4:	31 97       	sbiw	r30, 0x01	; 1
     4d6:	30 83       	st	Z, r19
     4d8:	31 97       	sbiw	r30, 0x01	; 1
     4da:	32 e1       	ldi	r19, 0x12	; 18
     4dc:	30 83       	st	Z, r19
     4de:	31 97       	sbiw	r30, 0x01	; 1
     4e0:	33 e1       	ldi	r19, 0x13	; 19
     4e2:	30 83       	st	Z, r19
     4e4:	31 97       	sbiw	r30, 0x01	; 1
     4e6:	34 e1       	ldi	r19, 0x14	; 20
     4e8:	30 83       	st	Z, r19
     4ea:	31 97       	sbiw	r30, 0x01	; 1
     4ec:	35 e1       	ldi	r19, 0x15	; 21
     4ee:	30 83       	st	Z, r19
     4f0:	31 97       	sbiw	r30, 0x01	; 1
     4f2:	36 e1       	ldi	r19, 0x16	; 22
     4f4:	30 83       	st	Z, r19
     4f6:	31 97       	sbiw	r30, 0x01	; 1
     4f8:	37 e1       	ldi	r19, 0x17	; 23
     4fa:	30 83       	st	Z, r19
     4fc:	31 97       	sbiw	r30, 0x01	; 1
     4fe:	38 e1       	ldi	r19, 0x18	; 24
     500:	30 83       	st	Z, r19
     502:	31 97       	sbiw	r30, 0x01	; 1
     504:	39 e1       	ldi	r19, 0x19	; 25
     506:	30 83       	st	Z, r19
     508:	31 97       	sbiw	r30, 0x01	; 1
     50a:	30 e2       	ldi	r19, 0x20	; 32
     50c:	30 83       	st	Z, r19
     50e:	31 97       	sbiw	r30, 0x01	; 1
     510:	31 e2       	ldi	r19, 0x21	; 33
     512:	30 83       	st	Z, r19
     514:	31 97       	sbiw	r30, 0x01	; 1
     516:	20 83       	st	Z, r18
     518:	31 97       	sbiw	r30, 0x01	; 1
     51a:	23 e2       	ldi	r18, 0x23	; 35
     51c:	20 83       	st	Z, r18
     51e:	31 97       	sbiw	r30, 0x01	; 1
     520:	40 83       	st	Z, r20
     522:	31 97       	sbiw	r30, 0x01	; 1
     524:	50 83       	st	Z, r21
     526:	31 97       	sbiw	r30, 0x01	; 1
     528:	26 e2       	ldi	r18, 0x26	; 38
     52a:	20 83       	st	Z, r18
     52c:	31 97       	sbiw	r30, 0x01	; 1
     52e:	27 e2       	ldi	r18, 0x27	; 39
     530:	20 83       	st	Z, r18
     532:	31 97       	sbiw	r30, 0x01	; 1
     534:	28 e2       	ldi	r18, 0x28	; 40
     536:	20 83       	st	Z, r18
     538:	31 97       	sbiw	r30, 0x01	; 1
     53a:	29 e2       	ldi	r18, 0x29	; 41
     53c:	20 83       	st	Z, r18
     53e:	31 97       	sbiw	r30, 0x01	; 1
     540:	20 e3       	ldi	r18, 0x30	; 48
     542:	20 83       	st	Z, r18
     544:	31 97       	sbiw	r30, 0x01	; 1
     546:	21 e3       	ldi	r18, 0x31	; 49
     548:	20 83       	st	Z, r18
     54a:	86 97       	sbiw	r24, 0x26	; 38
     54c:	08 95       	ret

0000054e <xPortStartScheduler>:
     54e:	1b bc       	out	0x2b, r1	; 43
     550:	8c e7       	ldi	r24, 0x7C	; 124
     552:	8a bd       	out	0x2a, r24	; 42
     554:	8b e0       	ldi	r24, 0x0B	; 11
     556:	8e bd       	out	0x2e, r24	; 46
     558:	89 b7       	in	r24, 0x39	; 57
     55a:	80 61       	ori	r24, 0x10	; 16
     55c:	89 bf       	out	0x39, r24	; 57
     55e:	a0 91 1a 03 	lds	r26, 0x031A	; 0x80031a <pxCurrentTCB>
     562:	b0 91 1b 03 	lds	r27, 0x031B	; 0x80031b <pxCurrentTCB+0x1>
     566:	cd 91       	ld	r28, X+
     568:	cd bf       	out	0x3d, r28	; 61
     56a:	dd 91       	ld	r29, X+
     56c:	de bf       	out	0x3e, r29	; 62
     56e:	ff 91       	pop	r31
     570:	ef 91       	pop	r30
     572:	df 91       	pop	r29
     574:	cf 91       	pop	r28
     576:	bf 91       	pop	r27
     578:	af 91       	pop	r26
     57a:	9f 91       	pop	r25
     57c:	8f 91       	pop	r24
     57e:	7f 91       	pop	r23
     580:	6f 91       	pop	r22
     582:	5f 91       	pop	r21
     584:	4f 91       	pop	r20
     586:	3f 91       	pop	r19
     588:	2f 91       	pop	r18
     58a:	1f 91       	pop	r17
     58c:	0f 91       	pop	r16
     58e:	ff 90       	pop	r15
     590:	ef 90       	pop	r14
     592:	df 90       	pop	r13
     594:	cf 90       	pop	r12
     596:	bf 90       	pop	r11
     598:	af 90       	pop	r10
     59a:	9f 90       	pop	r9
     59c:	8f 90       	pop	r8
     59e:	7f 90       	pop	r7
     5a0:	6f 90       	pop	r6
     5a2:	5f 90       	pop	r5
     5a4:	4f 90       	pop	r4
     5a6:	3f 90       	pop	r3
     5a8:	2f 90       	pop	r2
     5aa:	1f 90       	pop	r1
     5ac:	0f 90       	pop	r0
     5ae:	0f be       	out	0x3f, r0	; 63
     5b0:	0f 90       	pop	r0
     5b2:	08 95       	ret
     5b4:	81 e0       	ldi	r24, 0x01	; 1
     5b6:	08 95       	ret

000005b8 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     5b8:	0f 92       	push	r0
     5ba:	0f b6       	in	r0, 0x3f	; 63
     5bc:	f8 94       	cli
     5be:	0f 92       	push	r0
     5c0:	1f 92       	push	r1
     5c2:	11 24       	eor	r1, r1
     5c4:	2f 92       	push	r2
     5c6:	3f 92       	push	r3
     5c8:	4f 92       	push	r4
     5ca:	5f 92       	push	r5
     5cc:	6f 92       	push	r6
     5ce:	7f 92       	push	r7
     5d0:	8f 92       	push	r8
     5d2:	9f 92       	push	r9
     5d4:	af 92       	push	r10
     5d6:	bf 92       	push	r11
     5d8:	cf 92       	push	r12
     5da:	df 92       	push	r13
     5dc:	ef 92       	push	r14
     5de:	ff 92       	push	r15
     5e0:	0f 93       	push	r16
     5e2:	1f 93       	push	r17
     5e4:	2f 93       	push	r18
     5e6:	3f 93       	push	r19
     5e8:	4f 93       	push	r20
     5ea:	5f 93       	push	r21
     5ec:	6f 93       	push	r22
     5ee:	7f 93       	push	r23
     5f0:	8f 93       	push	r24
     5f2:	9f 93       	push	r25
     5f4:	af 93       	push	r26
     5f6:	bf 93       	push	r27
     5f8:	cf 93       	push	r28
     5fa:	df 93       	push	r29
     5fc:	ef 93       	push	r30
     5fe:	ff 93       	push	r31
     600:	a0 91 1a 03 	lds	r26, 0x031A	; 0x80031a <pxCurrentTCB>
     604:	b0 91 1b 03 	lds	r27, 0x031B	; 0x80031b <pxCurrentTCB+0x1>
     608:	0d b6       	in	r0, 0x3d	; 61
     60a:	0d 92       	st	X+, r0
     60c:	0e b6       	in	r0, 0x3e	; 62
     60e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     610:	0e 94 d4 08 	call	0x11a8	; 0x11a8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     614:	a0 91 1a 03 	lds	r26, 0x031A	; 0x80031a <pxCurrentTCB>
     618:	b0 91 1b 03 	lds	r27, 0x031B	; 0x80031b <pxCurrentTCB+0x1>
     61c:	cd 91       	ld	r28, X+
     61e:	cd bf       	out	0x3d, r28	; 61
     620:	dd 91       	ld	r29, X+
     622:	de bf       	out	0x3e, r29	; 62
     624:	ff 91       	pop	r31
     626:	ef 91       	pop	r30
     628:	df 91       	pop	r29
     62a:	cf 91       	pop	r28
     62c:	bf 91       	pop	r27
     62e:	af 91       	pop	r26
     630:	9f 91       	pop	r25
     632:	8f 91       	pop	r24
     634:	7f 91       	pop	r23
     636:	6f 91       	pop	r22
     638:	5f 91       	pop	r21
     63a:	4f 91       	pop	r20
     63c:	3f 91       	pop	r19
     63e:	2f 91       	pop	r18
     640:	1f 91       	pop	r17
     642:	0f 91       	pop	r16
     644:	ff 90       	pop	r15
     646:	ef 90       	pop	r14
     648:	df 90       	pop	r13
     64a:	cf 90       	pop	r12
     64c:	bf 90       	pop	r11
     64e:	af 90       	pop	r10
     650:	9f 90       	pop	r9
     652:	8f 90       	pop	r8
     654:	7f 90       	pop	r7
     656:	6f 90       	pop	r6
     658:	5f 90       	pop	r5
     65a:	4f 90       	pop	r4
     65c:	3f 90       	pop	r3
     65e:	2f 90       	pop	r2
     660:	1f 90       	pop	r1
     662:	0f 90       	pop	r0
     664:	0f be       	out	0x3f, r0	; 63
     666:	0f 90       	pop	r0

	asm volatile ( "ret" );
     668:	08 95       	ret

0000066a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     66a:	0f 92       	push	r0
     66c:	0f b6       	in	r0, 0x3f	; 63
     66e:	f8 94       	cli
     670:	0f 92       	push	r0
     672:	1f 92       	push	r1
     674:	11 24       	eor	r1, r1
     676:	2f 92       	push	r2
     678:	3f 92       	push	r3
     67a:	4f 92       	push	r4
     67c:	5f 92       	push	r5
     67e:	6f 92       	push	r6
     680:	7f 92       	push	r7
     682:	8f 92       	push	r8
     684:	9f 92       	push	r9
     686:	af 92       	push	r10
     688:	bf 92       	push	r11
     68a:	cf 92       	push	r12
     68c:	df 92       	push	r13
     68e:	ef 92       	push	r14
     690:	ff 92       	push	r15
     692:	0f 93       	push	r16
     694:	1f 93       	push	r17
     696:	2f 93       	push	r18
     698:	3f 93       	push	r19
     69a:	4f 93       	push	r20
     69c:	5f 93       	push	r21
     69e:	6f 93       	push	r22
     6a0:	7f 93       	push	r23
     6a2:	8f 93       	push	r24
     6a4:	9f 93       	push	r25
     6a6:	af 93       	push	r26
     6a8:	bf 93       	push	r27
     6aa:	cf 93       	push	r28
     6ac:	df 93       	push	r29
     6ae:	ef 93       	push	r30
     6b0:	ff 93       	push	r31
     6b2:	a0 91 1a 03 	lds	r26, 0x031A	; 0x80031a <pxCurrentTCB>
     6b6:	b0 91 1b 03 	lds	r27, 0x031B	; 0x80031b <pxCurrentTCB+0x1>
     6ba:	0d b6       	in	r0, 0x3d	; 61
     6bc:	0d 92       	st	X+, r0
     6be:	0e b6       	in	r0, 0x3e	; 62
     6c0:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     6c2:	0e 94 9a 07 	call	0xf34	; 0xf34 <xTaskIncrementTick>
     6c6:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     6c8:	0e 94 d4 08 	call	0x11a8	; 0x11a8 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     6cc:	a0 91 1a 03 	lds	r26, 0x031A	; 0x80031a <pxCurrentTCB>
     6d0:	b0 91 1b 03 	lds	r27, 0x031B	; 0x80031b <pxCurrentTCB+0x1>
     6d4:	cd 91       	ld	r28, X+
     6d6:	cd bf       	out	0x3d, r28	; 61
     6d8:	dd 91       	ld	r29, X+
     6da:	de bf       	out	0x3e, r29	; 62
     6dc:	ff 91       	pop	r31
     6de:	ef 91       	pop	r30
     6e0:	df 91       	pop	r29
     6e2:	cf 91       	pop	r28
     6e4:	bf 91       	pop	r27
     6e6:	af 91       	pop	r26
     6e8:	9f 91       	pop	r25
     6ea:	8f 91       	pop	r24
     6ec:	7f 91       	pop	r23
     6ee:	6f 91       	pop	r22
     6f0:	5f 91       	pop	r21
     6f2:	4f 91       	pop	r20
     6f4:	3f 91       	pop	r19
     6f6:	2f 91       	pop	r18
     6f8:	1f 91       	pop	r17
     6fa:	0f 91       	pop	r16
     6fc:	ff 90       	pop	r15
     6fe:	ef 90       	pop	r14
     700:	df 90       	pop	r13
     702:	cf 90       	pop	r12
     704:	bf 90       	pop	r11
     706:	af 90       	pop	r10
     708:	9f 90       	pop	r9
     70a:	8f 90       	pop	r8
     70c:	7f 90       	pop	r7
     70e:	6f 90       	pop	r6
     710:	5f 90       	pop	r5
     712:	4f 90       	pop	r4
     714:	3f 90       	pop	r3
     716:	2f 90       	pop	r2
     718:	1f 90       	pop	r1
     71a:	0f 90       	pop	r0
     71c:	0f be       	out	0x3f, r0	; 63
     71e:	0f 90       	pop	r0

	asm volatile ( "ret" );
     720:	08 95       	ret

00000722 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     722:	0e 94 35 03 	call	0x66a	; 0x66a <vPortYieldFromTick>
		asm volatile ( "reti" );
     726:	18 95       	reti

00000728 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     728:	0f 93       	push	r16
     72a:	1f 93       	push	r17
     72c:	cf 93       	push	r28
     72e:	df 93       	push	r29
     730:	ec 01       	movw	r28, r24
     732:	04 2f       	mov	r16, r20
     734:	1a 8d       	ldd	r17, Y+26	; 0x1a
     736:	4c 8d       	ldd	r20, Y+28	; 0x1c
     738:	44 23       	and	r20, r20
     73a:	b9 f1       	breq	.+110    	; 0x7aa <prvCopyDataToQueue+0x82>
     73c:	01 11       	cpse	r16, r1
     73e:	16 c0       	rjmp	.+44     	; 0x76c <prvCopyDataToQueue+0x44>
     740:	50 e0       	ldi	r21, 0x00	; 0
     742:	8c 81       	ldd	r24, Y+4	; 0x04
     744:	9d 81       	ldd	r25, Y+5	; 0x05
     746:	0e 94 d5 09 	call	0x13aa	; 0x13aa <memcpy>
     74a:	2c 8d       	ldd	r18, Y+28	; 0x1c
     74c:	8c 81       	ldd	r24, Y+4	; 0x04
     74e:	9d 81       	ldd	r25, Y+5	; 0x05
     750:	82 0f       	add	r24, r18
     752:	91 1d       	adc	r25, r1
     754:	9d 83       	std	Y+5, r25	; 0x05
     756:	8c 83       	std	Y+4, r24	; 0x04
     758:	2a 81       	ldd	r18, Y+2	; 0x02
     75a:	3b 81       	ldd	r19, Y+3	; 0x03
     75c:	82 17       	cp	r24, r18
     75e:	93 07       	cpc	r25, r19
     760:	20 f1       	brcs	.+72     	; 0x7aa <prvCopyDataToQueue+0x82>
     762:	88 81       	ld	r24, Y
     764:	99 81       	ldd	r25, Y+1	; 0x01
     766:	9d 83       	std	Y+5, r25	; 0x05
     768:	8c 83       	std	Y+4, r24	; 0x04
     76a:	1f c0       	rjmp	.+62     	; 0x7aa <prvCopyDataToQueue+0x82>
     76c:	50 e0       	ldi	r21, 0x00	; 0
     76e:	8e 81       	ldd	r24, Y+6	; 0x06
     770:	9f 81       	ldd	r25, Y+7	; 0x07
     772:	0e 94 d5 09 	call	0x13aa	; 0x13aa <memcpy>
     776:	8c 8d       	ldd	r24, Y+28	; 0x1c
     778:	90 e0       	ldi	r25, 0x00	; 0
     77a:	91 95       	neg	r25
     77c:	81 95       	neg	r24
     77e:	91 09       	sbc	r25, r1
     780:	2e 81       	ldd	r18, Y+6	; 0x06
     782:	3f 81       	ldd	r19, Y+7	; 0x07
     784:	28 0f       	add	r18, r24
     786:	39 1f       	adc	r19, r25
     788:	3f 83       	std	Y+7, r19	; 0x07
     78a:	2e 83       	std	Y+6, r18	; 0x06
     78c:	48 81       	ld	r20, Y
     78e:	59 81       	ldd	r21, Y+1	; 0x01
     790:	24 17       	cp	r18, r20
     792:	35 07       	cpc	r19, r21
     794:	30 f4       	brcc	.+12     	; 0x7a2 <prvCopyDataToQueue+0x7a>
     796:	2a 81       	ldd	r18, Y+2	; 0x02
     798:	3b 81       	ldd	r19, Y+3	; 0x03
     79a:	82 0f       	add	r24, r18
     79c:	93 1f       	adc	r25, r19
     79e:	9f 83       	std	Y+7, r25	; 0x07
     7a0:	8e 83       	std	Y+6, r24	; 0x06
     7a2:	02 30       	cpi	r16, 0x02	; 2
     7a4:	11 f4       	brne	.+4      	; 0x7aa <prvCopyDataToQueue+0x82>
     7a6:	11 11       	cpse	r17, r1
     7a8:	11 50       	subi	r17, 0x01	; 1
     7aa:	1f 5f       	subi	r17, 0xFF	; 255
     7ac:	1a 8f       	std	Y+26, r17	; 0x1a
     7ae:	80 e0       	ldi	r24, 0x00	; 0
     7b0:	df 91       	pop	r29
     7b2:	cf 91       	pop	r28
     7b4:	1f 91       	pop	r17
     7b6:	0f 91       	pop	r16
     7b8:	08 95       	ret

000007ba <prvCopyDataFromQueue>:
     7ba:	fc 01       	movw	r30, r24
     7bc:	44 8d       	ldd	r20, Z+28	; 0x1c
     7be:	44 23       	and	r20, r20
     7c0:	a9 f0       	breq	.+42     	; 0x7ec <prvCopyDataFromQueue+0x32>
     7c2:	50 e0       	ldi	r21, 0x00	; 0
     7c4:	26 81       	ldd	r18, Z+6	; 0x06
     7c6:	37 81       	ldd	r19, Z+7	; 0x07
     7c8:	24 0f       	add	r18, r20
     7ca:	35 1f       	adc	r19, r21
     7cc:	37 83       	std	Z+7, r19	; 0x07
     7ce:	26 83       	std	Z+6, r18	; 0x06
     7d0:	82 81       	ldd	r24, Z+2	; 0x02
     7d2:	93 81       	ldd	r25, Z+3	; 0x03
     7d4:	28 17       	cp	r18, r24
     7d6:	39 07       	cpc	r19, r25
     7d8:	20 f0       	brcs	.+8      	; 0x7e2 <prvCopyDataFromQueue+0x28>
     7da:	80 81       	ld	r24, Z
     7dc:	91 81       	ldd	r25, Z+1	; 0x01
     7de:	97 83       	std	Z+7, r25	; 0x07
     7e0:	86 83       	std	Z+6, r24	; 0x06
     7e2:	cb 01       	movw	r24, r22
     7e4:	66 81       	ldd	r22, Z+6	; 0x06
     7e6:	77 81       	ldd	r23, Z+7	; 0x07
     7e8:	0e 94 d5 09 	call	0x13aa	; 0x13aa <memcpy>
     7ec:	08 95       	ret

000007ee <prvUnlockQueue>:
     7ee:	ef 92       	push	r14
     7f0:	ff 92       	push	r15
     7f2:	0f 93       	push	r16
     7f4:	1f 93       	push	r17
     7f6:	cf 93       	push	r28
     7f8:	8c 01       	movw	r16, r24
     7fa:	0f b6       	in	r0, 0x3f	; 63
     7fc:	f8 94       	cli
     7fe:	0f 92       	push	r0
     800:	fc 01       	movw	r30, r24
     802:	c6 8d       	ldd	r28, Z+30	; 0x1e
     804:	1c 16       	cp	r1, r28
     806:	ac f4       	brge	.+42     	; 0x832 <prvUnlockQueue+0x44>
     808:	81 89       	ldd	r24, Z+17	; 0x11
     80a:	81 11       	cpse	r24, r1
     80c:	06 c0       	rjmp	.+12     	; 0x81a <prvUnlockQueue+0x2c>
     80e:	11 c0       	rjmp	.+34     	; 0x832 <prvUnlockQueue+0x44>
     810:	f8 01       	movw	r30, r16
     812:	81 89       	ldd	r24, Z+17	; 0x11
     814:	81 11       	cpse	r24, r1
     816:	05 c0       	rjmp	.+10     	; 0x822 <prvUnlockQueue+0x34>
     818:	0c c0       	rjmp	.+24     	; 0x832 <prvUnlockQueue+0x44>
     81a:	78 01       	movw	r14, r16
     81c:	f1 e1       	ldi	r31, 0x11	; 17
     81e:	ef 0e       	add	r14, r31
     820:	f1 1c       	adc	r15, r1
     822:	c7 01       	movw	r24, r14
     824:	0e 94 4c 09 	call	0x1298	; 0x1298 <xTaskRemoveFromEventList>
     828:	81 11       	cpse	r24, r1
     82a:	0e 94 d1 09 	call	0x13a2	; 0x13a2 <vTaskMissedYield>
     82e:	c1 50       	subi	r28, 0x01	; 1
     830:	79 f7       	brne	.-34     	; 0x810 <prvUnlockQueue+0x22>
     832:	8f ef       	ldi	r24, 0xFF	; 255
     834:	f8 01       	movw	r30, r16
     836:	86 8f       	std	Z+30, r24	; 0x1e
     838:	0f 90       	pop	r0
     83a:	0f be       	out	0x3f, r0	; 63
     83c:	0f b6       	in	r0, 0x3f	; 63
     83e:	f8 94       	cli
     840:	0f 92       	push	r0
     842:	c5 8d       	ldd	r28, Z+29	; 0x1d
     844:	1c 16       	cp	r1, r28
     846:	ac f4       	brge	.+42     	; 0x872 <__stack+0x13>
     848:	80 85       	ldd	r24, Z+8	; 0x08
     84a:	81 11       	cpse	r24, r1
     84c:	06 c0       	rjmp	.+12     	; 0x85a <prvUnlockQueue+0x6c>
     84e:	11 c0       	rjmp	.+34     	; 0x872 <__stack+0x13>
     850:	f8 01       	movw	r30, r16
     852:	80 85       	ldd	r24, Z+8	; 0x08
     854:	81 11       	cpse	r24, r1
     856:	05 c0       	rjmp	.+10     	; 0x862 <__stack+0x3>
     858:	0c c0       	rjmp	.+24     	; 0x872 <__stack+0x13>
     85a:	78 01       	movw	r14, r16
     85c:	f8 e0       	ldi	r31, 0x08	; 8
     85e:	ef 0e       	add	r14, r31
     860:	f1 1c       	adc	r15, r1
     862:	c7 01       	movw	r24, r14
     864:	0e 94 4c 09 	call	0x1298	; 0x1298 <xTaskRemoveFromEventList>
     868:	81 11       	cpse	r24, r1
     86a:	0e 94 d1 09 	call	0x13a2	; 0x13a2 <vTaskMissedYield>
     86e:	c1 50       	subi	r28, 0x01	; 1
     870:	79 f7       	brne	.-34     	; 0x850 <prvUnlockQueue+0x62>
     872:	8f ef       	ldi	r24, 0xFF	; 255
     874:	f8 01       	movw	r30, r16
     876:	85 8f       	std	Z+29, r24	; 0x1d
     878:	0f 90       	pop	r0
     87a:	0f be       	out	0x3f, r0	; 63
     87c:	cf 91       	pop	r28
     87e:	1f 91       	pop	r17
     880:	0f 91       	pop	r16
     882:	ff 90       	pop	r15
     884:	ef 90       	pop	r14
     886:	08 95       	ret

00000888 <xQueueGenericReset>:
     888:	cf 93       	push	r28
     88a:	df 93       	push	r29
     88c:	ec 01       	movw	r28, r24
     88e:	0f b6       	in	r0, 0x3f	; 63
     890:	f8 94       	cli
     892:	0f 92       	push	r0
     894:	48 81       	ld	r20, Y
     896:	59 81       	ldd	r21, Y+1	; 0x01
     898:	2c 8d       	ldd	r18, Y+28	; 0x1c
     89a:	30 e0       	ldi	r19, 0x00	; 0
     89c:	7b 8d       	ldd	r23, Y+27	; 0x1b
     89e:	72 9f       	mul	r23, r18
     8a0:	c0 01       	movw	r24, r0
     8a2:	73 9f       	mul	r23, r19
     8a4:	90 0d       	add	r25, r0
     8a6:	11 24       	eor	r1, r1
     8a8:	fa 01       	movw	r30, r20
     8aa:	e8 0f       	add	r30, r24
     8ac:	f9 1f       	adc	r31, r25
     8ae:	fb 83       	std	Y+3, r31	; 0x03
     8b0:	ea 83       	std	Y+2, r30	; 0x02
     8b2:	1a 8e       	std	Y+26, r1	; 0x1a
     8b4:	5d 83       	std	Y+5, r21	; 0x05
     8b6:	4c 83       	std	Y+4, r20	; 0x04
     8b8:	82 1b       	sub	r24, r18
     8ba:	93 0b       	sbc	r25, r19
     8bc:	84 0f       	add	r24, r20
     8be:	95 1f       	adc	r25, r21
     8c0:	9f 83       	std	Y+7, r25	; 0x07
     8c2:	8e 83       	std	Y+6, r24	; 0x06
     8c4:	8f ef       	ldi	r24, 0xFF	; 255
     8c6:	8d 8f       	std	Y+29, r24	; 0x1d
     8c8:	8e 8f       	std	Y+30, r24	; 0x1e
     8ca:	61 11       	cpse	r22, r1
     8cc:	0c c0       	rjmp	.+24     	; 0x8e6 <xQueueGenericReset+0x5e>
     8ce:	88 85       	ldd	r24, Y+8	; 0x08
     8d0:	88 23       	and	r24, r24
     8d2:	89 f0       	breq	.+34     	; 0x8f6 <xQueueGenericReset+0x6e>
     8d4:	ce 01       	movw	r24, r28
     8d6:	08 96       	adiw	r24, 0x08	; 8
     8d8:	0e 94 4c 09 	call	0x1298	; 0x1298 <xTaskRemoveFromEventList>
     8dc:	88 23       	and	r24, r24
     8de:	59 f0       	breq	.+22     	; 0x8f6 <xQueueGenericReset+0x6e>
     8e0:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <vPortYield>
     8e4:	08 c0       	rjmp	.+16     	; 0x8f6 <xQueueGenericReset+0x6e>
     8e6:	ce 01       	movw	r24, r28
     8e8:	08 96       	adiw	r24, 0x08	; 8
     8ea:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     8ee:	ce 01       	movw	r24, r28
     8f0:	41 96       	adiw	r24, 0x11	; 17
     8f2:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     8f6:	0f 90       	pop	r0
     8f8:	0f be       	out	0x3f, r0	; 63
     8fa:	81 e0       	ldi	r24, 0x01	; 1
     8fc:	df 91       	pop	r29
     8fe:	cf 91       	pop	r28
     900:	08 95       	ret

00000902 <xQueueGenericCreate>:
     902:	0f 93       	push	r16
     904:	1f 93       	push	r17
     906:	cf 93       	push	r28
     908:	df 93       	push	r29
     90a:	08 2f       	mov	r16, r24
     90c:	16 2f       	mov	r17, r22
     90e:	66 23       	and	r22, r22
     910:	c1 f0       	breq	.+48     	; 0x942 <xQueueGenericCreate+0x40>
     912:	86 9f       	mul	r24, r22
     914:	c0 01       	movw	r24, r0
     916:	11 24       	eor	r1, r1
     918:	4f 96       	adiw	r24, 0x1f	; 31
     91a:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     91e:	ec 01       	movw	r28, r24
     920:	00 97       	sbiw	r24, 0x00	; 0
     922:	41 f4       	brne	.+16     	; 0x934 <xQueueGenericCreate+0x32>
     924:	15 c0       	rjmp	.+42     	; 0x950 <xQueueGenericCreate+0x4e>
     926:	0b 8f       	std	Y+27, r16	; 0x1b
     928:	1c 8f       	std	Y+28, r17	; 0x1c
     92a:	61 e0       	ldi	r22, 0x01	; 1
     92c:	ce 01       	movw	r24, r28
     92e:	0e 94 44 04 	call	0x888	; 0x888 <xQueueGenericReset>
     932:	0e c0       	rjmp	.+28     	; 0x950 <xQueueGenericCreate+0x4e>
     934:	4f 96       	adiw	r24, 0x1f	; 31
     936:	99 83       	std	Y+1, r25	; 0x01
     938:	88 83       	st	Y, r24
     93a:	f5 cf       	rjmp	.-22     	; 0x926 <xQueueGenericCreate+0x24>
     93c:	d9 83       	std	Y+1, r29	; 0x01
     93e:	c8 83       	st	Y, r28
     940:	f2 cf       	rjmp	.-28     	; 0x926 <xQueueGenericCreate+0x24>
     942:	8f e1       	ldi	r24, 0x1F	; 31
     944:	90 e0       	ldi	r25, 0x00	; 0
     946:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     94a:	ec 01       	movw	r28, r24
     94c:	89 2b       	or	r24, r25
     94e:	b1 f7       	brne	.-20     	; 0x93c <xQueueGenericCreate+0x3a>
     950:	ce 01       	movw	r24, r28
     952:	df 91       	pop	r29
     954:	cf 91       	pop	r28
     956:	1f 91       	pop	r17
     958:	0f 91       	pop	r16
     95a:	08 95       	ret

0000095c <xQueueGenericSend>:
     95c:	9f 92       	push	r9
     95e:	af 92       	push	r10
     960:	bf 92       	push	r11
     962:	cf 92       	push	r12
     964:	df 92       	push	r13
     966:	ef 92       	push	r14
     968:	ff 92       	push	r15
     96a:	0f 93       	push	r16
     96c:	1f 93       	push	r17
     96e:	cf 93       	push	r28
     970:	df 93       	push	r29
     972:	00 d0       	rcall	.+0      	; 0x974 <xQueueGenericSend+0x18>
     974:	00 d0       	rcall	.+0      	; 0x976 <xQueueGenericSend+0x1a>
     976:	1f 92       	push	r1
     978:	cd b7       	in	r28, 0x3d	; 61
     97a:	de b7       	in	r29, 0x3e	; 62
     97c:	8c 01       	movw	r16, r24
     97e:	6b 01       	movw	r12, r22
     980:	5d 83       	std	Y+5, r21	; 0x05
     982:	4c 83       	std	Y+4, r20	; 0x04
     984:	a2 2e       	mov	r10, r18
     986:	b1 2c       	mov	r11, r1
     988:	99 24       	eor	r9, r9
     98a:	93 94       	inc	r9
     98c:	7c 01       	movw	r14, r24
     98e:	88 e0       	ldi	r24, 0x08	; 8
     990:	e8 0e       	add	r14, r24
     992:	f1 1c       	adc	r15, r1
     994:	0f b6       	in	r0, 0x3f	; 63
     996:	f8 94       	cli
     998:	0f 92       	push	r0
     99a:	f8 01       	movw	r30, r16
     99c:	92 8d       	ldd	r25, Z+26	; 0x1a
     99e:	83 8d       	ldd	r24, Z+27	; 0x1b
     9a0:	98 17       	cp	r25, r24
     9a2:	18 f0       	brcs	.+6      	; 0x9aa <xQueueGenericSend+0x4e>
     9a4:	f2 e0       	ldi	r31, 0x02	; 2
     9a6:	af 12       	cpse	r10, r31
     9a8:	19 c0       	rjmp	.+50     	; 0x9dc <xQueueGenericSend+0x80>
     9aa:	4a 2d       	mov	r20, r10
     9ac:	b6 01       	movw	r22, r12
     9ae:	c8 01       	movw	r24, r16
     9b0:	0e 94 94 03 	call	0x728	; 0x728 <prvCopyDataToQueue>
     9b4:	f8 01       	movw	r30, r16
     9b6:	91 89       	ldd	r25, Z+17	; 0x11
     9b8:	99 23       	and	r25, r25
     9ba:	49 f0       	breq	.+18     	; 0x9ce <xQueueGenericSend+0x72>
     9bc:	c8 01       	movw	r24, r16
     9be:	41 96       	adiw	r24, 0x11	; 17
     9c0:	0e 94 4c 09 	call	0x1298	; 0x1298 <xTaskRemoveFromEventList>
     9c4:	88 23       	and	r24, r24
     9c6:	31 f0       	breq	.+12     	; 0x9d4 <xQueueGenericSend+0x78>
     9c8:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <vPortYield>
     9cc:	03 c0       	rjmp	.+6      	; 0x9d4 <xQueueGenericSend+0x78>
     9ce:	81 11       	cpse	r24, r1
     9d0:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <vPortYield>
     9d4:	0f 90       	pop	r0
     9d6:	0f be       	out	0x3f, r0	; 63
     9d8:	81 e0       	ldi	r24, 0x01	; 1
     9da:	50 c0       	rjmp	.+160    	; 0xa7c <xQueueGenericSend+0x120>
     9dc:	8c 81       	ldd	r24, Y+4	; 0x04
     9de:	9d 81       	ldd	r25, Y+5	; 0x05
     9e0:	89 2b       	or	r24, r25
     9e2:	21 f4       	brne	.+8      	; 0x9ec <xQueueGenericSend+0x90>
     9e4:	0f 90       	pop	r0
     9e6:	0f be       	out	0x3f, r0	; 63
     9e8:	80 e0       	ldi	r24, 0x00	; 0
     9ea:	48 c0       	rjmp	.+144    	; 0xa7c <xQueueGenericSend+0x120>
     9ec:	b1 10       	cpse	r11, r1
     9ee:	05 c0       	rjmp	.+10     	; 0x9fa <xQueueGenericSend+0x9e>
     9f0:	ce 01       	movw	r24, r28
     9f2:	01 96       	adiw	r24, 0x01	; 1
     9f4:	0e 94 94 09 	call	0x1328	; 0x1328 <vTaskSetTimeOutState>
     9f8:	b9 2c       	mov	r11, r9
     9fa:	0f 90       	pop	r0
     9fc:	0f be       	out	0x3f, r0	; 63
     9fe:	0e 94 94 07 	call	0xf28	; 0xf28 <vTaskSuspendAll>
     a02:	0f b6       	in	r0, 0x3f	; 63
     a04:	f8 94       	cli
     a06:	0f 92       	push	r0
     a08:	f8 01       	movw	r30, r16
     a0a:	85 8d       	ldd	r24, Z+29	; 0x1d
     a0c:	8f 3f       	cpi	r24, 0xFF	; 255
     a0e:	09 f4       	brne	.+2      	; 0xa12 <xQueueGenericSend+0xb6>
     a10:	15 8e       	std	Z+29, r1	; 0x1d
     a12:	f8 01       	movw	r30, r16
     a14:	86 8d       	ldd	r24, Z+30	; 0x1e
     a16:	8f 3f       	cpi	r24, 0xFF	; 255
     a18:	09 f4       	brne	.+2      	; 0xa1c <xQueueGenericSend+0xc0>
     a1a:	16 8e       	std	Z+30, r1	; 0x1e
     a1c:	0f 90       	pop	r0
     a1e:	0f be       	out	0x3f, r0	; 63
     a20:	be 01       	movw	r22, r28
     a22:	6c 5f       	subi	r22, 0xFC	; 252
     a24:	7f 4f       	sbci	r23, 0xFF	; 255
     a26:	ce 01       	movw	r24, r28
     a28:	01 96       	adiw	r24, 0x01	; 1
     a2a:	0e 94 9f 09 	call	0x133e	; 0x133e <xTaskCheckForTimeOut>
     a2e:	81 11       	cpse	r24, r1
     a30:	1f c0       	rjmp	.+62     	; 0xa70 <xQueueGenericSend+0x114>
     a32:	0f b6       	in	r0, 0x3f	; 63
     a34:	f8 94       	cli
     a36:	0f 92       	push	r0
     a38:	f8 01       	movw	r30, r16
     a3a:	92 8d       	ldd	r25, Z+26	; 0x1a
     a3c:	0f 90       	pop	r0
     a3e:	0f be       	out	0x3f, r0	; 63
     a40:	83 8d       	ldd	r24, Z+27	; 0x1b
     a42:	98 13       	cpse	r25, r24
     a44:	0f c0       	rjmp	.+30     	; 0xa64 <xQueueGenericSend+0x108>
     a46:	6c 81       	ldd	r22, Y+4	; 0x04
     a48:	7d 81       	ldd	r23, Y+5	; 0x05
     a4a:	c7 01       	movw	r24, r14
     a4c:	0e 94 3a 09 	call	0x1274	; 0x1274 <vTaskPlaceOnEventList>
     a50:	c8 01       	movw	r24, r16
     a52:	0e 94 f7 03 	call	0x7ee	; 0x7ee <prvUnlockQueue>
     a56:	0e 94 55 08 	call	0x10aa	; 0x10aa <xTaskResumeAll>
     a5a:	81 11       	cpse	r24, r1
     a5c:	9b cf       	rjmp	.-202    	; 0x994 <xQueueGenericSend+0x38>
     a5e:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <vPortYield>
     a62:	98 cf       	rjmp	.-208    	; 0x994 <xQueueGenericSend+0x38>
     a64:	c8 01       	movw	r24, r16
     a66:	0e 94 f7 03 	call	0x7ee	; 0x7ee <prvUnlockQueue>
     a6a:	0e 94 55 08 	call	0x10aa	; 0x10aa <xTaskResumeAll>
     a6e:	92 cf       	rjmp	.-220    	; 0x994 <xQueueGenericSend+0x38>
     a70:	c8 01       	movw	r24, r16
     a72:	0e 94 f7 03 	call	0x7ee	; 0x7ee <prvUnlockQueue>
     a76:	0e 94 55 08 	call	0x10aa	; 0x10aa <xTaskResumeAll>
     a7a:	80 e0       	ldi	r24, 0x00	; 0
     a7c:	0f 90       	pop	r0
     a7e:	0f 90       	pop	r0
     a80:	0f 90       	pop	r0
     a82:	0f 90       	pop	r0
     a84:	0f 90       	pop	r0
     a86:	df 91       	pop	r29
     a88:	cf 91       	pop	r28
     a8a:	1f 91       	pop	r17
     a8c:	0f 91       	pop	r16
     a8e:	ff 90       	pop	r15
     a90:	ef 90       	pop	r14
     a92:	df 90       	pop	r13
     a94:	cf 90       	pop	r12
     a96:	bf 90       	pop	r11
     a98:	af 90       	pop	r10
     a9a:	9f 90       	pop	r9
     a9c:	08 95       	ret

00000a9e <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     a9e:	8f 92       	push	r8
     aa0:	9f 92       	push	r9
     aa2:	af 92       	push	r10
     aa4:	bf 92       	push	r11
     aa6:	cf 92       	push	r12
     aa8:	df 92       	push	r13
     aaa:	ef 92       	push	r14
     aac:	ff 92       	push	r15
     aae:	0f 93       	push	r16
     ab0:	1f 93       	push	r17
     ab2:	cf 93       	push	r28
     ab4:	df 93       	push	r29
     ab6:	00 d0       	rcall	.+0      	; 0xab8 <xQueueGenericReceive+0x1a>
     ab8:	00 d0       	rcall	.+0      	; 0xaba <xQueueGenericReceive+0x1c>
     aba:	1f 92       	push	r1
     abc:	cd b7       	in	r28, 0x3d	; 61
     abe:	de b7       	in	r29, 0x3e	; 62
     ac0:	8c 01       	movw	r16, r24
     ac2:	5b 01       	movw	r10, r22
     ac4:	5d 83       	std	Y+5, r21	; 0x05
     ac6:	4c 83       	std	Y+4, r20	; 0x04
     ac8:	82 2e       	mov	r8, r18
BaseType_t xEntryTimeSet = pdFALSE;
     aca:	e1 2c       	mov	r14, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     acc:	99 24       	eor	r9, r9
     ace:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     ad0:	6c 01       	movw	r12, r24
     ad2:	81 e1       	ldi	r24, 0x11	; 17
     ad4:	c8 0e       	add	r12, r24
     ad6:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     ad8:	0f b6       	in	r0, 0x3f	; 63
     ada:	f8 94       	cli
     adc:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     ade:	f8 01       	movw	r30, r16
     ae0:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     ae2:	ff 20       	and	r15, r15
     ae4:	41 f1       	breq	.+80     	; 0xb36 <xQueueGenericReceive+0x98>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     ae6:	c6 80       	ldd	r12, Z+6	; 0x06
     ae8:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     aea:	b5 01       	movw	r22, r10
     aec:	c8 01       	movw	r24, r16
     aee:	0e 94 dd 03 	call	0x7ba	; 0x7ba <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     af2:	81 10       	cpse	r8, r1
     af4:	0f c0       	rjmp	.+30     	; 0xb14 <xQueueGenericReceive+0x76>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
     af6:	fa 94       	dec	r15
     af8:	f8 01       	movw	r30, r16
     afa:	f2 8e       	std	Z+26, r15	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     afc:	80 85       	ldd	r24, Z+8	; 0x08
     afe:	88 23       	and	r24, r24
     b00:	b1 f0       	breq	.+44     	; 0xb2e <xQueueGenericReceive+0x90>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     b02:	c8 01       	movw	r24, r16
     b04:	08 96       	adiw	r24, 0x08	; 8
     b06:	0e 94 4c 09 	call	0x1298	; 0x1298 <xTaskRemoveFromEventList>
     b0a:	88 23       	and	r24, r24
     b0c:	81 f0       	breq	.+32     	; 0xb2e <xQueueGenericReceive+0x90>
						{
							queueYIELD_IF_USING_PREEMPTION();
     b0e:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <vPortYield>
     b12:	0d c0       	rjmp	.+26     	; 0xb2e <xQueueGenericReceive+0x90>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     b14:	f8 01       	movw	r30, r16
     b16:	d7 82       	std	Z+7, r13	; 0x07
     b18:	c6 82       	std	Z+6, r12	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     b1a:	81 89       	ldd	r24, Z+17	; 0x11
     b1c:	88 23       	and	r24, r24
     b1e:	39 f0       	breq	.+14     	; 0xb2e <xQueueGenericReceive+0x90>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     b20:	c8 01       	movw	r24, r16
     b22:	41 96       	adiw	r24, 0x11	; 17
     b24:	0e 94 4c 09 	call	0x1298	; 0x1298 <xTaskRemoveFromEventList>
     b28:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     b2a:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     b2e:	0f 90       	pop	r0
     b30:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     b32:	81 e0       	ldi	r24, 0x01	; 1
     b34:	57 c0       	rjmp	.+174    	; 0xbe4 <xQueueGenericReceive+0x146>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     b36:	8c 81       	ldd	r24, Y+4	; 0x04
     b38:	9d 81       	ldd	r25, Y+5	; 0x05
     b3a:	89 2b       	or	r24, r25
     b3c:	21 f4       	brne	.+8      	; 0xb46 <xQueueGenericReceive+0xa8>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     b3e:	0f 90       	pop	r0
     b40:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     b42:	80 e0       	ldi	r24, 0x00	; 0
     b44:	4f c0       	rjmp	.+158    	; 0xbe4 <xQueueGenericReceive+0x146>
				}
				else if( xEntryTimeSet == pdFALSE )
     b46:	e1 10       	cpse	r14, r1
     b48:	05 c0       	rjmp	.+10     	; 0xb54 <xQueueGenericReceive+0xb6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     b4a:	ce 01       	movw	r24, r28
     b4c:	01 96       	adiw	r24, 0x01	; 1
     b4e:	0e 94 94 09 	call	0x1328	; 0x1328 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     b52:	e9 2c       	mov	r14, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     b54:	0f 90       	pop	r0
     b56:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     b58:	0e 94 94 07 	call	0xf28	; 0xf28 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     b5c:	0f b6       	in	r0, 0x3f	; 63
     b5e:	f8 94       	cli
     b60:	0f 92       	push	r0
     b62:	f8 01       	movw	r30, r16
     b64:	85 8d       	ldd	r24, Z+29	; 0x1d
     b66:	8f 3f       	cpi	r24, 0xFF	; 255
     b68:	09 f4       	brne	.+2      	; 0xb6c <xQueueGenericReceive+0xce>
     b6a:	15 8e       	std	Z+29, r1	; 0x1d
     b6c:	f8 01       	movw	r30, r16
     b6e:	86 8d       	ldd	r24, Z+30	; 0x1e
     b70:	8f 3f       	cpi	r24, 0xFF	; 255
     b72:	09 f4       	brne	.+2      	; 0xb76 <xQueueGenericReceive+0xd8>
     b74:	16 8e       	std	Z+30, r1	; 0x1e
     b76:	0f 90       	pop	r0
     b78:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     b7a:	be 01       	movw	r22, r28
     b7c:	6c 5f       	subi	r22, 0xFC	; 252
     b7e:	7f 4f       	sbci	r23, 0xFF	; 255
     b80:	ce 01       	movw	r24, r28
     b82:	01 96       	adiw	r24, 0x01	; 1
     b84:	0e 94 9f 09 	call	0x133e	; 0x133e <xTaskCheckForTimeOut>
     b88:	81 11       	cpse	r24, r1
     b8a:	1e c0       	rjmp	.+60     	; 0xbc8 <xQueueGenericReceive+0x12a>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     b8c:	0f b6       	in	r0, 0x3f	; 63
     b8e:	f8 94       	cli
     b90:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     b92:	f8 01       	movw	r30, r16
     b94:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     b96:	0f 90       	pop	r0
     b98:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     b9a:	81 11       	cpse	r24, r1
     b9c:	0f c0       	rjmp	.+30     	; 0xbbc <xQueueGenericReceive+0x11e>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     b9e:	6c 81       	ldd	r22, Y+4	; 0x04
     ba0:	7d 81       	ldd	r23, Y+5	; 0x05
     ba2:	c6 01       	movw	r24, r12
     ba4:	0e 94 3a 09 	call	0x1274	; 0x1274 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     ba8:	c8 01       	movw	r24, r16
     baa:	0e 94 f7 03 	call	0x7ee	; 0x7ee <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     bae:	0e 94 55 08 	call	0x10aa	; 0x10aa <xTaskResumeAll>
     bb2:	81 11       	cpse	r24, r1
     bb4:	91 cf       	rjmp	.-222    	; 0xad8 <xQueueGenericReceive+0x3a>
				{
					portYIELD_WITHIN_API();
     bb6:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <vPortYield>
     bba:	8e cf       	rjmp	.-228    	; 0xad8 <xQueueGenericReceive+0x3a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     bbc:	c8 01       	movw	r24, r16
     bbe:	0e 94 f7 03 	call	0x7ee	; 0x7ee <prvUnlockQueue>
				( void ) xTaskResumeAll();
     bc2:	0e 94 55 08 	call	0x10aa	; 0x10aa <xTaskResumeAll>
     bc6:	88 cf       	rjmp	.-240    	; 0xad8 <xQueueGenericReceive+0x3a>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     bc8:	c8 01       	movw	r24, r16
     bca:	0e 94 f7 03 	call	0x7ee	; 0x7ee <prvUnlockQueue>
			( void ) xTaskResumeAll();
     bce:	0e 94 55 08 	call	0x10aa	; 0x10aa <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     bd2:	0f b6       	in	r0, 0x3f	; 63
     bd4:	f8 94       	cli
     bd6:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     bd8:	f8 01       	movw	r30, r16
     bda:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     bdc:	0f 90       	pop	r0
     bde:	0f be       	out	0x3f, r0	; 63
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     be0:	81 11       	cpse	r24, r1
     be2:	7a cf       	rjmp	.-268    	; 0xad8 <xQueueGenericReceive+0x3a>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
     be4:	0f 90       	pop	r0
     be6:	0f 90       	pop	r0
     be8:	0f 90       	pop	r0
     bea:	0f 90       	pop	r0
     bec:	0f 90       	pop	r0
     bee:	df 91       	pop	r29
     bf0:	cf 91       	pop	r28
     bf2:	1f 91       	pop	r17
     bf4:	0f 91       	pop	r16
     bf6:	ff 90       	pop	r15
     bf8:	ef 90       	pop	r14
     bfa:	df 90       	pop	r13
     bfc:	cf 90       	pop	r12
     bfe:	bf 90       	pop	r11
     c00:	af 90       	pop	r10
     c02:	9f 90       	pop	r9
     c04:	8f 90       	pop	r8
     c06:	08 95       	ret

00000c08 <prvResetNextTaskUnblockTime>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     c08:	e0 91 f4 02 	lds	r30, 0x02F4	; 0x8002f4 <pxDelayedTaskList>
     c0c:	f0 91 f5 02 	lds	r31, 0x02F5	; 0x8002f5 <pxDelayedTaskList+0x1>
     c10:	80 81       	ld	r24, Z
     c12:	81 11       	cpse	r24, r1
     c14:	07 c0       	rjmp	.+14     	; 0xc24 <prvResetNextTaskUnblockTime+0x1c>
     c16:	8f ef       	ldi	r24, 0xFF	; 255
     c18:	9f ef       	ldi	r25, 0xFF	; 255
     c1a:	90 93 df 02 	sts	0x02DF, r25	; 0x8002df <xNextTaskUnblockTime+0x1>
     c1e:	80 93 de 02 	sts	0x02DE, r24	; 0x8002de <xNextTaskUnblockTime>
     c22:	08 95       	ret
     c24:	e0 91 f4 02 	lds	r30, 0x02F4	; 0x8002f4 <pxDelayedTaskList>
     c28:	f0 91 f5 02 	lds	r31, 0x02F5	; 0x8002f5 <pxDelayedTaskList+0x1>
     c2c:	05 80       	ldd	r0, Z+5	; 0x05
     c2e:	f6 81       	ldd	r31, Z+6	; 0x06
     c30:	e0 2d       	mov	r30, r0
     c32:	06 80       	ldd	r0, Z+6	; 0x06
     c34:	f7 81       	ldd	r31, Z+7	; 0x07
     c36:	e0 2d       	mov	r30, r0
     c38:	82 81       	ldd	r24, Z+2	; 0x02
     c3a:	93 81       	ldd	r25, Z+3	; 0x03
     c3c:	90 93 df 02 	sts	0x02DF, r25	; 0x8002df <xNextTaskUnblockTime+0x1>
     c40:	80 93 de 02 	sts	0x02DE, r24	; 0x8002de <xNextTaskUnblockTime>
     c44:	08 95       	ret

00000c46 <prvIdleTask>:
     c46:	c8 e0       	ldi	r28, 0x08	; 8
     c48:	d3 e0       	ldi	r29, 0x03	; 3
     c4a:	88 81       	ld	r24, Y
     c4c:	82 30       	cpi	r24, 0x02	; 2
     c4e:	f0 f3       	brcs	.-4      	; 0xc4c <prvIdleTask+0x6>
     c50:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <vPortYield>
     c54:	fa cf       	rjmp	.-12     	; 0xc4a <prvIdleTask+0x4>

00000c56 <prvAddCurrentTaskToDelayedList>:
     c56:	0f 93       	push	r16
     c58:	1f 93       	push	r17
     c5a:	cf 93       	push	r28
     c5c:	df 93       	push	r29
     c5e:	ec 01       	movw	r28, r24
     c60:	00 91 e6 02 	lds	r16, 0x02E6	; 0x8002e6 <xTickCount>
     c64:	10 91 e7 02 	lds	r17, 0x02E7	; 0x8002e7 <xTickCount+0x1>
     c68:	80 91 1a 03 	lds	r24, 0x031A	; 0x80031a <pxCurrentTCB>
     c6c:	90 91 1b 03 	lds	r25, 0x031B	; 0x80031b <pxCurrentTCB+0x1>
     c70:	02 96       	adiw	r24, 0x02	; 2
     c72:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
     c76:	c0 0f       	add	r28, r16
     c78:	d1 1f       	adc	r29, r17
     c7a:	e0 91 1a 03 	lds	r30, 0x031A	; 0x80031a <pxCurrentTCB>
     c7e:	f0 91 1b 03 	lds	r31, 0x031B	; 0x80031b <pxCurrentTCB+0x1>
     c82:	d3 83       	std	Z+3, r29	; 0x03
     c84:	c2 83       	std	Z+2, r28	; 0x02
     c86:	c0 17       	cp	r28, r16
     c88:	d1 07       	cpc	r29, r17
     c8a:	68 f4       	brcc	.+26     	; 0xca6 <prvAddCurrentTaskToDelayedList+0x50>
     c8c:	60 91 1a 03 	lds	r22, 0x031A	; 0x80031a <pxCurrentTCB>
     c90:	70 91 1b 03 	lds	r23, 0x031B	; 0x80031b <pxCurrentTCB+0x1>
     c94:	80 91 f2 02 	lds	r24, 0x02F2	; 0x8002f2 <pxOverflowDelayedTaskList>
     c98:	90 91 f3 02 	lds	r25, 0x02F3	; 0x8002f3 <pxOverflowDelayedTaskList+0x1>
     c9c:	6e 5f       	subi	r22, 0xFE	; 254
     c9e:	7f 4f       	sbci	r23, 0xFF	; 255
     ca0:	0e 94 49 01 	call	0x292	; 0x292 <vListInsert>
     ca4:	17 c0       	rjmp	.+46     	; 0xcd4 <prvAddCurrentTaskToDelayedList+0x7e>
     ca6:	60 91 1a 03 	lds	r22, 0x031A	; 0x80031a <pxCurrentTCB>
     caa:	70 91 1b 03 	lds	r23, 0x031B	; 0x80031b <pxCurrentTCB+0x1>
     cae:	80 91 f4 02 	lds	r24, 0x02F4	; 0x8002f4 <pxDelayedTaskList>
     cb2:	90 91 f5 02 	lds	r25, 0x02F5	; 0x8002f5 <pxDelayedTaskList+0x1>
     cb6:	6e 5f       	subi	r22, 0xFE	; 254
     cb8:	7f 4f       	sbci	r23, 0xFF	; 255
     cba:	0e 94 49 01 	call	0x292	; 0x292 <vListInsert>
     cbe:	80 91 de 02 	lds	r24, 0x02DE	; 0x8002de <xNextTaskUnblockTime>
     cc2:	90 91 df 02 	lds	r25, 0x02DF	; 0x8002df <xNextTaskUnblockTime+0x1>
     cc6:	c8 17       	cp	r28, r24
     cc8:	d9 07       	cpc	r29, r25
     cca:	20 f4       	brcc	.+8      	; 0xcd4 <prvAddCurrentTaskToDelayedList+0x7e>
     ccc:	d0 93 df 02 	sts	0x02DF, r29	; 0x8002df <xNextTaskUnblockTime+0x1>
     cd0:	c0 93 de 02 	sts	0x02DE, r28	; 0x8002de <xNextTaskUnblockTime>
     cd4:	df 91       	pop	r29
     cd6:	cf 91       	pop	r28
     cd8:	1f 91       	pop	r17
     cda:	0f 91       	pop	r16
     cdc:	08 95       	ret

00000cde <xTaskCreate>:
     cde:	4f 92       	push	r4
     ce0:	5f 92       	push	r5
     ce2:	6f 92       	push	r6
     ce4:	7f 92       	push	r7
     ce6:	8f 92       	push	r8
     ce8:	9f 92       	push	r9
     cea:	af 92       	push	r10
     cec:	bf 92       	push	r11
     cee:	cf 92       	push	r12
     cf0:	df 92       	push	r13
     cf2:	ef 92       	push	r14
     cf4:	ff 92       	push	r15
     cf6:	0f 93       	push	r16
     cf8:	cf 93       	push	r28
     cfa:	df 93       	push	r29
     cfc:	4c 01       	movw	r8, r24
     cfe:	6b 01       	movw	r12, r22
     d00:	5a 01       	movw	r10, r20
     d02:	29 01       	movw	r4, r18
     d04:	ca 01       	movw	r24, r20
     d06:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     d0a:	3c 01       	movw	r6, r24
     d0c:	89 2b       	or	r24, r25
     d0e:	09 f4       	brne	.+2      	; 0xd12 <xTaskCreate+0x34>
     d10:	d0 c0       	rjmp	.+416    	; 0xeb2 <xTaskCreate+0x1d4>
     d12:	86 e2       	ldi	r24, 0x26	; 38
     d14:	90 e0       	ldi	r25, 0x00	; 0
     d16:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     d1a:	ec 01       	movw	r28, r24
     d1c:	89 2b       	or	r24, r25
     d1e:	71 f0       	breq	.+28     	; 0xd3c <xTaskCreate+0x5e>
     d20:	78 8e       	std	Y+24, r7	; 0x18
     d22:	6f 8a       	std	Y+23, r6	; 0x17
     d24:	81 e0       	ldi	r24, 0x01	; 1
     d26:	a8 1a       	sub	r10, r24
     d28:	b1 08       	sbc	r11, r1
     d2a:	a6 0c       	add	r10, r6
     d2c:	b7 1c       	adc	r11, r7
     d2e:	d6 01       	movw	r26, r12
     d30:	8c 91       	ld	r24, X
     d32:	89 8f       	std	Y+25, r24	; 0x19
     d34:	8c 91       	ld	r24, X
     d36:	81 11       	cpse	r24, r1
     d38:	05 c0       	rjmp	.+10     	; 0xd44 <xTaskCreate+0x66>
     d3a:	18 c0       	rjmp	.+48     	; 0xd6c <xTaskCreate+0x8e>
     d3c:	c3 01       	movw	r24, r6
     d3e:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <vPortFree>
     d42:	b7 c0       	rjmp	.+366    	; 0xeb2 <xTaskCreate+0x1d4>
     d44:	ae 01       	movw	r20, r28
     d46:	46 5e       	subi	r20, 0xE6	; 230
     d48:	5f 4f       	sbci	r21, 0xFF	; 255
     d4a:	f6 01       	movw	r30, r12
     d4c:	31 96       	adiw	r30, 0x01	; 1
     d4e:	b8 e0       	ldi	r27, 0x08	; 8
     d50:	cb 0e       	add	r12, r27
     d52:	d1 1c       	adc	r13, r1
     d54:	cf 01       	movw	r24, r30
     d56:	21 91       	ld	r18, Z+
     d58:	da 01       	movw	r26, r20
     d5a:	2d 93       	st	X+, r18
     d5c:	ad 01       	movw	r20, r26
     d5e:	dc 01       	movw	r26, r24
     d60:	8c 91       	ld	r24, X
     d62:	88 23       	and	r24, r24
     d64:	19 f0       	breq	.+6      	; 0xd6c <xTaskCreate+0x8e>
     d66:	ec 15       	cp	r30, r12
     d68:	fd 05       	cpc	r31, r13
     d6a:	a1 f7       	brne	.-24     	; 0xd54 <xTaskCreate+0x76>
     d6c:	18 a2       	std	Y+32, r1	; 0x20
     d6e:	01 11       	cpse	r16, r1
     d70:	01 e0       	ldi	r16, 0x01	; 1
     d72:	0e 8b       	std	Y+22, r16	; 0x16
     d74:	6e 01       	movw	r12, r28
     d76:	b2 e0       	ldi	r27, 0x02	; 2
     d78:	cb 0e       	add	r12, r27
     d7a:	d1 1c       	adc	r13, r1
     d7c:	c6 01       	movw	r24, r12
     d7e:	0e 94 24 01 	call	0x248	; 0x248 <vListInitialiseItem>
     d82:	ce 01       	movw	r24, r28
     d84:	0c 96       	adiw	r24, 0x0c	; 12
     d86:	0e 94 24 01 	call	0x248	; 0x248 <vListInitialiseItem>
     d8a:	d9 87       	std	Y+9, r29	; 0x09
     d8c:	c8 87       	std	Y+8, r28	; 0x08
     d8e:	82 e0       	ldi	r24, 0x02	; 2
     d90:	90 e0       	ldi	r25, 0x00	; 0
     d92:	80 1b       	sub	r24, r16
     d94:	91 09       	sbc	r25, r1
     d96:	9d 87       	std	Y+13, r25	; 0x0d
     d98:	8c 87       	std	Y+12, r24	; 0x0c
     d9a:	db 8b       	std	Y+19, r29	; 0x13
     d9c:	ca 8b       	std	Y+18, r28	; 0x12
     d9e:	19 a2       	std	Y+33, r1	; 0x21
     da0:	1a a2       	std	Y+34, r1	; 0x22
     da2:	1b a2       	std	Y+35, r1	; 0x23
     da4:	1c a2       	std	Y+36, r1	; 0x24
     da6:	1d a2       	std	Y+37, r1	; 0x25
     da8:	a2 01       	movw	r20, r4
     daa:	b4 01       	movw	r22, r8
     dac:	c5 01       	movw	r24, r10
     dae:	0e 94 3b 02 	call	0x476	; 0x476 <pxPortInitialiseStack>
     db2:	99 83       	std	Y+1, r25	; 0x01
     db4:	88 83       	st	Y, r24
     db6:	e1 14       	cp	r14, r1
     db8:	f1 04       	cpc	r15, r1
     dba:	19 f0       	breq	.+6      	; 0xdc2 <xTaskCreate+0xe4>
     dbc:	f7 01       	movw	r30, r14
     dbe:	d1 83       	std	Z+1, r29	; 0x01
     dc0:	c0 83       	st	Z, r28
     dc2:	0f b6       	in	r0, 0x3f	; 63
     dc4:	f8 94       	cli
     dc6:	0f 92       	push	r0
     dc8:	80 91 e8 02 	lds	r24, 0x02E8	; 0x8002e8 <uxCurrentNumberOfTasks>
     dcc:	8f 5f       	subi	r24, 0xFF	; 255
     dce:	80 93 e8 02 	sts	0x02E8, r24	; 0x8002e8 <uxCurrentNumberOfTasks>
     dd2:	80 91 1a 03 	lds	r24, 0x031A	; 0x80031a <pxCurrentTCB>
     dd6:	90 91 1b 03 	lds	r25, 0x031B	; 0x80031b <pxCurrentTCB+0x1>
     dda:	89 2b       	or	r24, r25
     ddc:	49 f5       	brne	.+82     	; 0xe30 <xTaskCreate+0x152>
     dde:	d0 93 1b 03 	sts	0x031B, r29	; 0x80031b <pxCurrentTCB+0x1>
     de2:	c0 93 1a 03 	sts	0x031A, r28	; 0x80031a <pxCurrentTCB>
     de6:	80 91 e8 02 	lds	r24, 0x02E8	; 0x8002e8 <uxCurrentNumberOfTasks>
     dea:	81 30       	cpi	r24, 0x01	; 1
     dec:	89 f5       	brne	.+98     	; 0xe50 <xTaskCreate+0x172>
     dee:	88 e0       	ldi	r24, 0x08	; 8
     df0:	93 e0       	ldi	r25, 0x03	; 3
     df2:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     df6:	81 e1       	ldi	r24, 0x11	; 17
     df8:	93 e0       	ldi	r25, 0x03	; 3
     dfa:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     dfe:	8f ef       	ldi	r24, 0xFF	; 255
     e00:	92 e0       	ldi	r25, 0x02	; 2
     e02:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     e06:	86 ef       	ldi	r24, 0xF6	; 246
     e08:	92 e0       	ldi	r25, 0x02	; 2
     e0a:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     e0e:	89 ee       	ldi	r24, 0xE9	; 233
     e10:	92 e0       	ldi	r25, 0x02	; 2
     e12:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     e16:	8f ef       	ldi	r24, 0xFF	; 255
     e18:	92 e0       	ldi	r25, 0x02	; 2
     e1a:	90 93 f5 02 	sts	0x02F5, r25	; 0x8002f5 <pxDelayedTaskList+0x1>
     e1e:	80 93 f4 02 	sts	0x02F4, r24	; 0x8002f4 <pxDelayedTaskList>
     e22:	86 ef       	ldi	r24, 0xF6	; 246
     e24:	92 e0       	ldi	r25, 0x02	; 2
     e26:	90 93 f3 02 	sts	0x02F3, r25	; 0x8002f3 <pxOverflowDelayedTaskList+0x1>
     e2a:	80 93 f2 02 	sts	0x02F2, r24	; 0x8002f2 <pxOverflowDelayedTaskList>
     e2e:	10 c0       	rjmp	.+32     	; 0xe50 <xTaskCreate+0x172>
     e30:	80 91 e4 02 	lds	r24, 0x02E4	; 0x8002e4 <xSchedulerRunning>
     e34:	81 11       	cpse	r24, r1
     e36:	0c c0       	rjmp	.+24     	; 0xe50 <xTaskCreate+0x172>
     e38:	e0 91 1a 03 	lds	r30, 0x031A	; 0x80031a <pxCurrentTCB>
     e3c:	f0 91 1b 03 	lds	r31, 0x031B	; 0x80031b <pxCurrentTCB+0x1>
     e40:	96 89       	ldd	r25, Z+22	; 0x16
     e42:	8e 89       	ldd	r24, Y+22	; 0x16
     e44:	89 17       	cp	r24, r25
     e46:	20 f0       	brcs	.+8      	; 0xe50 <xTaskCreate+0x172>
     e48:	d0 93 1b 03 	sts	0x031B, r29	; 0x80031b <pxCurrentTCB+0x1>
     e4c:	c0 93 1a 03 	sts	0x031A, r28	; 0x80031a <pxCurrentTCB>
     e50:	80 91 e0 02 	lds	r24, 0x02E0	; 0x8002e0 <uxTaskNumber>
     e54:	8f 5f       	subi	r24, 0xFF	; 255
     e56:	80 93 e0 02 	sts	0x02E0, r24	; 0x8002e0 <uxTaskNumber>
     e5a:	8e 89       	ldd	r24, Y+22	; 0x16
     e5c:	90 91 e5 02 	lds	r25, 0x02E5	; 0x8002e5 <uxTopReadyPriority>
     e60:	98 17       	cp	r25, r24
     e62:	10 f4       	brcc	.+4      	; 0xe68 <xTaskCreate+0x18a>
     e64:	80 93 e5 02 	sts	0x02E5, r24	; 0x8002e5 <uxTopReadyPriority>
     e68:	90 e0       	ldi	r25, 0x00	; 0
     e6a:	9c 01       	movw	r18, r24
     e6c:	22 0f       	add	r18, r18
     e6e:	33 1f       	adc	r19, r19
     e70:	22 0f       	add	r18, r18
     e72:	33 1f       	adc	r19, r19
     e74:	22 0f       	add	r18, r18
     e76:	33 1f       	adc	r19, r19
     e78:	82 0f       	add	r24, r18
     e7a:	93 1f       	adc	r25, r19
     e7c:	b6 01       	movw	r22, r12
     e7e:	88 5f       	subi	r24, 0xF8	; 248
     e80:	9c 4f       	sbci	r25, 0xFC	; 252
     e82:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
     e86:	0f 90       	pop	r0
     e88:	0f be       	out	0x3f, r0	; 63
     e8a:	80 91 e4 02 	lds	r24, 0x02E4	; 0x8002e4 <xSchedulerRunning>
     e8e:	88 23       	and	r24, r24
     e90:	61 f0       	breq	.+24     	; 0xeaa <xTaskCreate+0x1cc>
     e92:	e0 91 1a 03 	lds	r30, 0x031A	; 0x80031a <pxCurrentTCB>
     e96:	f0 91 1b 03 	lds	r31, 0x031B	; 0x80031b <pxCurrentTCB+0x1>
     e9a:	96 89       	ldd	r25, Z+22	; 0x16
     e9c:	8e 89       	ldd	r24, Y+22	; 0x16
     e9e:	98 17       	cp	r25, r24
     ea0:	30 f4       	brcc	.+12     	; 0xeae <xTaskCreate+0x1d0>
     ea2:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <vPortYield>
     ea6:	81 e0       	ldi	r24, 0x01	; 1
     ea8:	05 c0       	rjmp	.+10     	; 0xeb4 <xTaskCreate+0x1d6>
     eaa:	81 e0       	ldi	r24, 0x01	; 1
     eac:	03 c0       	rjmp	.+6      	; 0xeb4 <xTaskCreate+0x1d6>
     eae:	81 e0       	ldi	r24, 0x01	; 1
     eb0:	01 c0       	rjmp	.+2      	; 0xeb4 <xTaskCreate+0x1d6>
     eb2:	8f ef       	ldi	r24, 0xFF	; 255
     eb4:	df 91       	pop	r29
     eb6:	cf 91       	pop	r28
     eb8:	0f 91       	pop	r16
     eba:	ff 90       	pop	r15
     ebc:	ef 90       	pop	r14
     ebe:	df 90       	pop	r13
     ec0:	cf 90       	pop	r12
     ec2:	bf 90       	pop	r11
     ec4:	af 90       	pop	r10
     ec6:	9f 90       	pop	r9
     ec8:	8f 90       	pop	r8
     eca:	7f 90       	pop	r7
     ecc:	6f 90       	pop	r6
     ece:	5f 90       	pop	r5
     ed0:	4f 90       	pop	r4
     ed2:	08 95       	ret

00000ed4 <vTaskStartScheduler>:
     ed4:	ef 92       	push	r14
     ed6:	ff 92       	push	r15
     ed8:	0f 93       	push	r16
     eda:	0f 2e       	mov	r0, r31
     edc:	fc ed       	ldi	r31, 0xDC	; 220
     ede:	ef 2e       	mov	r14, r31
     ee0:	f2 e0       	ldi	r31, 0x02	; 2
     ee2:	ff 2e       	mov	r15, r31
     ee4:	f0 2d       	mov	r31, r0
     ee6:	00 e0       	ldi	r16, 0x00	; 0
     ee8:	20 e0       	ldi	r18, 0x00	; 0
     eea:	30 e0       	ldi	r19, 0x00	; 0
     eec:	45 e5       	ldi	r20, 0x55	; 85
     eee:	50 e0       	ldi	r21, 0x00	; 0
     ef0:	64 e7       	ldi	r22, 0x74	; 116
     ef2:	70 e0       	ldi	r23, 0x00	; 0
     ef4:	83 e2       	ldi	r24, 0x23	; 35
     ef6:	96 e0       	ldi	r25, 0x06	; 6
     ef8:	0e 94 6f 06 	call	0xcde	; 0xcde <xTaskCreate>
     efc:	81 30       	cpi	r24, 0x01	; 1
     efe:	81 f4       	brne	.+32     	; 0xf20 <vTaskStartScheduler+0x4c>
     f00:	f8 94       	cli
     f02:	8f ef       	ldi	r24, 0xFF	; 255
     f04:	9f ef       	ldi	r25, 0xFF	; 255
     f06:	90 93 df 02 	sts	0x02DF, r25	; 0x8002df <xNextTaskUnblockTime+0x1>
     f0a:	80 93 de 02 	sts	0x02DE, r24	; 0x8002de <xNextTaskUnblockTime>
     f0e:	81 e0       	ldi	r24, 0x01	; 1
     f10:	80 93 e4 02 	sts	0x02E4, r24	; 0x8002e4 <xSchedulerRunning>
     f14:	10 92 e7 02 	sts	0x02E7, r1	; 0x8002e7 <xTickCount+0x1>
     f18:	10 92 e6 02 	sts	0x02E6, r1	; 0x8002e6 <xTickCount>
     f1c:	0e 94 a7 02 	call	0x54e	; 0x54e <xPortStartScheduler>
     f20:	0f 91       	pop	r16
     f22:	ff 90       	pop	r15
     f24:	ef 90       	pop	r14
     f26:	08 95       	ret

00000f28 <vTaskSuspendAll>:
     f28:	80 91 db 02 	lds	r24, 0x02DB	; 0x8002db <uxSchedulerSuspended>
     f2c:	8f 5f       	subi	r24, 0xFF	; 255
     f2e:	80 93 db 02 	sts	0x02DB, r24	; 0x8002db <uxSchedulerSuspended>
     f32:	08 95       	ret

00000f34 <xTaskIncrementTick>:
     f34:	cf 92       	push	r12
     f36:	df 92       	push	r13
     f38:	ef 92       	push	r14
     f3a:	ff 92       	push	r15
     f3c:	0f 93       	push	r16
     f3e:	1f 93       	push	r17
     f40:	cf 93       	push	r28
     f42:	df 93       	push	r29
     f44:	80 91 db 02 	lds	r24, 0x02DB	; 0x8002db <uxSchedulerSuspended>
     f48:	81 11       	cpse	r24, r1
     f4a:	99 c0       	rjmp	.+306    	; 0x107e <xTaskIncrementTick+0x14a>
     f4c:	e0 90 e6 02 	lds	r14, 0x02E6	; 0x8002e6 <xTickCount>
     f50:	f0 90 e7 02 	lds	r15, 0x02E7	; 0x8002e7 <xTickCount+0x1>
     f54:	8f ef       	ldi	r24, 0xFF	; 255
     f56:	e8 1a       	sub	r14, r24
     f58:	f8 0a       	sbc	r15, r24
     f5a:	f0 92 e7 02 	sts	0x02E7, r15	; 0x8002e7 <xTickCount+0x1>
     f5e:	e0 92 e6 02 	sts	0x02E6, r14	; 0x8002e6 <xTickCount>
     f62:	e1 14       	cp	r14, r1
     f64:	f1 04       	cpc	r15, r1
     f66:	b9 f4       	brne	.+46     	; 0xf96 <xTaskIncrementTick+0x62>
     f68:	80 91 f4 02 	lds	r24, 0x02F4	; 0x8002f4 <pxDelayedTaskList>
     f6c:	90 91 f5 02 	lds	r25, 0x02F5	; 0x8002f5 <pxDelayedTaskList+0x1>
     f70:	20 91 f2 02 	lds	r18, 0x02F2	; 0x8002f2 <pxOverflowDelayedTaskList>
     f74:	30 91 f3 02 	lds	r19, 0x02F3	; 0x8002f3 <pxOverflowDelayedTaskList+0x1>
     f78:	30 93 f5 02 	sts	0x02F5, r19	; 0x8002f5 <pxDelayedTaskList+0x1>
     f7c:	20 93 f4 02 	sts	0x02F4, r18	; 0x8002f4 <pxDelayedTaskList>
     f80:	90 93 f3 02 	sts	0x02F3, r25	; 0x8002f3 <pxOverflowDelayedTaskList+0x1>
     f84:	80 93 f2 02 	sts	0x02F2, r24	; 0x8002f2 <pxOverflowDelayedTaskList>
     f88:	80 91 e1 02 	lds	r24, 0x02E1	; 0x8002e1 <xNumOfOverflows>
     f8c:	8f 5f       	subi	r24, 0xFF	; 255
     f8e:	80 93 e1 02 	sts	0x02E1, r24	; 0x8002e1 <xNumOfOverflows>
     f92:	0e 94 04 06 	call	0xc08	; 0xc08 <prvResetNextTaskUnblockTime>
     f96:	80 91 de 02 	lds	r24, 0x02DE	; 0x8002de <xNextTaskUnblockTime>
     f9a:	90 91 df 02 	lds	r25, 0x02DF	; 0x8002df <xNextTaskUnblockTime+0x1>
     f9e:	e8 16       	cp	r14, r24
     fa0:	f9 06       	cpc	r15, r25
     fa2:	10 f4       	brcc	.+4      	; 0xfa8 <xTaskIncrementTick+0x74>
     fa4:	d1 2c       	mov	r13, r1
     fa6:	53 c0       	rjmp	.+166    	; 0x104e <xTaskIncrementTick+0x11a>
     fa8:	d1 2c       	mov	r13, r1
     faa:	cc 24       	eor	r12, r12
     fac:	c3 94       	inc	r12
     fae:	e0 91 f4 02 	lds	r30, 0x02F4	; 0x8002f4 <pxDelayedTaskList>
     fb2:	f0 91 f5 02 	lds	r31, 0x02F5	; 0x8002f5 <pxDelayedTaskList+0x1>
     fb6:	80 81       	ld	r24, Z
     fb8:	81 11       	cpse	r24, r1
     fba:	07 c0       	rjmp	.+14     	; 0xfca <xTaskIncrementTick+0x96>
     fbc:	8f ef       	ldi	r24, 0xFF	; 255
     fbe:	9f ef       	ldi	r25, 0xFF	; 255
     fc0:	90 93 df 02 	sts	0x02DF, r25	; 0x8002df <xNextTaskUnblockTime+0x1>
     fc4:	80 93 de 02 	sts	0x02DE, r24	; 0x8002de <xNextTaskUnblockTime>
     fc8:	42 c0       	rjmp	.+132    	; 0x104e <xTaskIncrementTick+0x11a>
     fca:	e0 91 f4 02 	lds	r30, 0x02F4	; 0x8002f4 <pxDelayedTaskList>
     fce:	f0 91 f5 02 	lds	r31, 0x02F5	; 0x8002f5 <pxDelayedTaskList+0x1>
     fd2:	05 80       	ldd	r0, Z+5	; 0x05
     fd4:	f6 81       	ldd	r31, Z+6	; 0x06
     fd6:	e0 2d       	mov	r30, r0
     fd8:	c6 81       	ldd	r28, Z+6	; 0x06
     fda:	d7 81       	ldd	r29, Z+7	; 0x07
     fdc:	8a 81       	ldd	r24, Y+2	; 0x02
     fde:	9b 81       	ldd	r25, Y+3	; 0x03
     fe0:	e8 16       	cp	r14, r24
     fe2:	f9 06       	cpc	r15, r25
     fe4:	28 f4       	brcc	.+10     	; 0xff0 <xTaskIncrementTick+0xbc>
     fe6:	90 93 df 02 	sts	0x02DF, r25	; 0x8002df <xNextTaskUnblockTime+0x1>
     fea:	80 93 de 02 	sts	0x02DE, r24	; 0x8002de <xNextTaskUnblockTime>
     fee:	2f c0       	rjmp	.+94     	; 0x104e <xTaskIncrementTick+0x11a>
     ff0:	8e 01       	movw	r16, r28
     ff2:	0e 5f       	subi	r16, 0xFE	; 254
     ff4:	1f 4f       	sbci	r17, 0xFF	; 255
     ff6:	c8 01       	movw	r24, r16
     ff8:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
     ffc:	8c 89       	ldd	r24, Y+20	; 0x14
     ffe:	9d 89       	ldd	r25, Y+21	; 0x15
    1000:	89 2b       	or	r24, r25
    1002:	21 f0       	breq	.+8      	; 0x100c <xTaskIncrementTick+0xd8>
    1004:	ce 01       	movw	r24, r28
    1006:	0c 96       	adiw	r24, 0x0c	; 12
    1008:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
    100c:	8e 89       	ldd	r24, Y+22	; 0x16
    100e:	90 91 e5 02 	lds	r25, 0x02E5	; 0x8002e5 <uxTopReadyPriority>
    1012:	98 17       	cp	r25, r24
    1014:	10 f4       	brcc	.+4      	; 0x101a <xTaskIncrementTick+0xe6>
    1016:	80 93 e5 02 	sts	0x02E5, r24	; 0x8002e5 <uxTopReadyPriority>
    101a:	90 e0       	ldi	r25, 0x00	; 0
    101c:	9c 01       	movw	r18, r24
    101e:	22 0f       	add	r18, r18
    1020:	33 1f       	adc	r19, r19
    1022:	22 0f       	add	r18, r18
    1024:	33 1f       	adc	r19, r19
    1026:	22 0f       	add	r18, r18
    1028:	33 1f       	adc	r19, r19
    102a:	82 0f       	add	r24, r18
    102c:	93 1f       	adc	r25, r19
    102e:	b8 01       	movw	r22, r16
    1030:	88 5f       	subi	r24, 0xF8	; 248
    1032:	9c 4f       	sbci	r25, 0xFC	; 252
    1034:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
    1038:	e0 91 1a 03 	lds	r30, 0x031A	; 0x80031a <pxCurrentTCB>
    103c:	f0 91 1b 03 	lds	r31, 0x031B	; 0x80031b <pxCurrentTCB+0x1>
    1040:	9e 89       	ldd	r25, Y+22	; 0x16
    1042:	86 89       	ldd	r24, Z+22	; 0x16
    1044:	98 17       	cp	r25, r24
    1046:	08 f4       	brcc	.+2      	; 0x104a <xTaskIncrementTick+0x116>
    1048:	b2 cf       	rjmp	.-156    	; 0xfae <xTaskIncrementTick+0x7a>
    104a:	dc 2c       	mov	r13, r12
    104c:	b0 cf       	rjmp	.-160    	; 0xfae <xTaskIncrementTick+0x7a>
    104e:	e0 91 1a 03 	lds	r30, 0x031A	; 0x80031a <pxCurrentTCB>
    1052:	f0 91 1b 03 	lds	r31, 0x031B	; 0x80031b <pxCurrentTCB+0x1>
    1056:	86 89       	ldd	r24, Z+22	; 0x16
    1058:	90 e0       	ldi	r25, 0x00	; 0
    105a:	fc 01       	movw	r30, r24
    105c:	ee 0f       	add	r30, r30
    105e:	ff 1f       	adc	r31, r31
    1060:	ee 0f       	add	r30, r30
    1062:	ff 1f       	adc	r31, r31
    1064:	ee 0f       	add	r30, r30
    1066:	ff 1f       	adc	r31, r31
    1068:	8e 0f       	add	r24, r30
    106a:	9f 1f       	adc	r25, r31
    106c:	fc 01       	movw	r30, r24
    106e:	e8 5f       	subi	r30, 0xF8	; 248
    1070:	fc 4f       	sbci	r31, 0xFC	; 252
    1072:	80 81       	ld	r24, Z
    1074:	82 30       	cpi	r24, 0x02	; 2
    1076:	48 f0       	brcs	.+18     	; 0x108a <xTaskIncrementTick+0x156>
    1078:	dd 24       	eor	r13, r13
    107a:	d3 94       	inc	r13
    107c:	06 c0       	rjmp	.+12     	; 0x108a <xTaskIncrementTick+0x156>
    107e:	80 91 e3 02 	lds	r24, 0x02E3	; 0x8002e3 <uxPendedTicks>
    1082:	8f 5f       	subi	r24, 0xFF	; 255
    1084:	80 93 e3 02 	sts	0x02E3, r24	; 0x8002e3 <uxPendedTicks>
    1088:	d1 2c       	mov	r13, r1
    108a:	80 91 e2 02 	lds	r24, 0x02E2	; 0x8002e2 <xYieldPending>
    108e:	88 23       	and	r24, r24
    1090:	11 f0       	breq	.+4      	; 0x1096 <xTaskIncrementTick+0x162>
    1092:	dd 24       	eor	r13, r13
    1094:	d3 94       	inc	r13
    1096:	8d 2d       	mov	r24, r13
    1098:	df 91       	pop	r29
    109a:	cf 91       	pop	r28
    109c:	1f 91       	pop	r17
    109e:	0f 91       	pop	r16
    10a0:	ff 90       	pop	r15
    10a2:	ef 90       	pop	r14
    10a4:	df 90       	pop	r13
    10a6:	cf 90       	pop	r12
    10a8:	08 95       	ret

000010aa <xTaskResumeAll>:
    10aa:	df 92       	push	r13
    10ac:	ef 92       	push	r14
    10ae:	ff 92       	push	r15
    10b0:	0f 93       	push	r16
    10b2:	1f 93       	push	r17
    10b4:	cf 93       	push	r28
    10b6:	df 93       	push	r29
    10b8:	0f b6       	in	r0, 0x3f	; 63
    10ba:	f8 94       	cli
    10bc:	0f 92       	push	r0
    10be:	80 91 db 02 	lds	r24, 0x02DB	; 0x8002db <uxSchedulerSuspended>
    10c2:	81 50       	subi	r24, 0x01	; 1
    10c4:	80 93 db 02 	sts	0x02DB, r24	; 0x8002db <uxSchedulerSuspended>
    10c8:	80 91 db 02 	lds	r24, 0x02DB	; 0x8002db <uxSchedulerSuspended>
    10cc:	81 11       	cpse	r24, r1
    10ce:	5f c0       	rjmp	.+190    	; 0x118e <xTaskResumeAll+0xe4>
    10d0:	80 91 e8 02 	lds	r24, 0x02E8	; 0x8002e8 <uxCurrentNumberOfTasks>
    10d4:	81 11       	cpse	r24, r1
    10d6:	33 c0       	rjmp	.+102    	; 0x113e <xTaskResumeAll+0x94>
    10d8:	5d c0       	rjmp	.+186    	; 0x1194 <xTaskResumeAll+0xea>
    10da:	d7 01       	movw	r26, r14
    10dc:	15 96       	adiw	r26, 0x05	; 5
    10de:	ed 91       	ld	r30, X+
    10e0:	fc 91       	ld	r31, X
    10e2:	16 97       	sbiw	r26, 0x06	; 6
    10e4:	c6 81       	ldd	r28, Z+6	; 0x06
    10e6:	d7 81       	ldd	r29, Z+7	; 0x07
    10e8:	ce 01       	movw	r24, r28
    10ea:	0c 96       	adiw	r24, 0x0c	; 12
    10ec:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
    10f0:	8e 01       	movw	r16, r28
    10f2:	0e 5f       	subi	r16, 0xFE	; 254
    10f4:	1f 4f       	sbci	r17, 0xFF	; 255
    10f6:	c8 01       	movw	r24, r16
    10f8:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
    10fc:	8e 89       	ldd	r24, Y+22	; 0x16
    10fe:	90 91 e5 02 	lds	r25, 0x02E5	; 0x8002e5 <uxTopReadyPriority>
    1102:	98 17       	cp	r25, r24
    1104:	10 f4       	brcc	.+4      	; 0x110a <xTaskResumeAll+0x60>
    1106:	80 93 e5 02 	sts	0x02E5, r24	; 0x8002e5 <uxTopReadyPriority>
    110a:	90 e0       	ldi	r25, 0x00	; 0
    110c:	9c 01       	movw	r18, r24
    110e:	22 0f       	add	r18, r18
    1110:	33 1f       	adc	r19, r19
    1112:	22 0f       	add	r18, r18
    1114:	33 1f       	adc	r19, r19
    1116:	22 0f       	add	r18, r18
    1118:	33 1f       	adc	r19, r19
    111a:	82 0f       	add	r24, r18
    111c:	93 1f       	adc	r25, r19
    111e:	b8 01       	movw	r22, r16
    1120:	88 5f       	subi	r24, 0xF8	; 248
    1122:	9c 4f       	sbci	r25, 0xFC	; 252
    1124:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
    1128:	e0 91 1a 03 	lds	r30, 0x031A	; 0x80031a <pxCurrentTCB>
    112c:	f0 91 1b 03 	lds	r31, 0x031B	; 0x80031b <pxCurrentTCB+0x1>
    1130:	9e 89       	ldd	r25, Y+22	; 0x16
    1132:	86 89       	ldd	r24, Z+22	; 0x16
    1134:	98 17       	cp	r25, r24
    1136:	68 f0       	brcs	.+26     	; 0x1152 <xTaskResumeAll+0xa8>
    1138:	d0 92 e2 02 	sts	0x02E2, r13	; 0x8002e2 <xYieldPending>
    113c:	0a c0       	rjmp	.+20     	; 0x1152 <xTaskResumeAll+0xa8>
    113e:	c0 e0       	ldi	r28, 0x00	; 0
    1140:	d0 e0       	ldi	r29, 0x00	; 0
    1142:	0f 2e       	mov	r0, r31
    1144:	f9 ee       	ldi	r31, 0xE9	; 233
    1146:	ef 2e       	mov	r14, r31
    1148:	f2 e0       	ldi	r31, 0x02	; 2
    114a:	ff 2e       	mov	r15, r31
    114c:	f0 2d       	mov	r31, r0
    114e:	dd 24       	eor	r13, r13
    1150:	d3 94       	inc	r13
    1152:	f7 01       	movw	r30, r14
    1154:	80 81       	ld	r24, Z
    1156:	81 11       	cpse	r24, r1
    1158:	c0 cf       	rjmp	.-128    	; 0x10da <xTaskResumeAll+0x30>
    115a:	cd 2b       	or	r28, r29
    115c:	11 f0       	breq	.+4      	; 0x1162 <xTaskResumeAll+0xb8>
    115e:	0e 94 04 06 	call	0xc08	; 0xc08 <prvResetNextTaskUnblockTime>
    1162:	c0 91 e3 02 	lds	r28, 0x02E3	; 0x8002e3 <uxPendedTicks>
    1166:	cc 23       	and	r28, r28
    1168:	51 f0       	breq	.+20     	; 0x117e <xTaskResumeAll+0xd4>
    116a:	d1 e0       	ldi	r29, 0x01	; 1
    116c:	0e 94 9a 07 	call	0xf34	; 0xf34 <xTaskIncrementTick>
    1170:	81 11       	cpse	r24, r1
    1172:	d0 93 e2 02 	sts	0x02E2, r29	; 0x8002e2 <xYieldPending>
    1176:	c1 50       	subi	r28, 0x01	; 1
    1178:	c9 f7       	brne	.-14     	; 0x116c <xTaskResumeAll+0xc2>
    117a:	10 92 e3 02 	sts	0x02E3, r1	; 0x8002e3 <uxPendedTicks>
    117e:	80 91 e2 02 	lds	r24, 0x02E2	; 0x8002e2 <xYieldPending>
    1182:	88 23       	and	r24, r24
    1184:	31 f0       	breq	.+12     	; 0x1192 <xTaskResumeAll+0xe8>
    1186:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <vPortYield>
    118a:	81 e0       	ldi	r24, 0x01	; 1
    118c:	03 c0       	rjmp	.+6      	; 0x1194 <xTaskResumeAll+0xea>
    118e:	80 e0       	ldi	r24, 0x00	; 0
    1190:	01 c0       	rjmp	.+2      	; 0x1194 <xTaskResumeAll+0xea>
    1192:	80 e0       	ldi	r24, 0x00	; 0
    1194:	0f 90       	pop	r0
    1196:	0f be       	out	0x3f, r0	; 63
    1198:	df 91       	pop	r29
    119a:	cf 91       	pop	r28
    119c:	1f 91       	pop	r17
    119e:	0f 91       	pop	r16
    11a0:	ff 90       	pop	r15
    11a2:	ef 90       	pop	r14
    11a4:	df 90       	pop	r13
    11a6:	08 95       	ret

000011a8 <vTaskSwitchContext>:
    11a8:	80 91 db 02 	lds	r24, 0x02DB	; 0x8002db <uxSchedulerSuspended>
    11ac:	88 23       	and	r24, r24
    11ae:	21 f0       	breq	.+8      	; 0x11b8 <vTaskSwitchContext+0x10>
    11b0:	81 e0       	ldi	r24, 0x01	; 1
    11b2:	80 93 e2 02 	sts	0x02E2, r24	; 0x8002e2 <xYieldPending>
    11b6:	08 95       	ret
    11b8:	10 92 e2 02 	sts	0x02E2, r1	; 0x8002e2 <xYieldPending>
    11bc:	20 91 e5 02 	lds	r18, 0x02E5	; 0x8002e5 <uxTopReadyPriority>
    11c0:	82 2f       	mov	r24, r18
    11c2:	90 e0       	ldi	r25, 0x00	; 0
    11c4:	fc 01       	movw	r30, r24
    11c6:	ee 0f       	add	r30, r30
    11c8:	ff 1f       	adc	r31, r31
    11ca:	ee 0f       	add	r30, r30
    11cc:	ff 1f       	adc	r31, r31
    11ce:	ee 0f       	add	r30, r30
    11d0:	ff 1f       	adc	r31, r31
    11d2:	e8 0f       	add	r30, r24
    11d4:	f9 1f       	adc	r31, r25
    11d6:	e8 5f       	subi	r30, 0xF8	; 248
    11d8:	fc 4f       	sbci	r31, 0xFC	; 252
    11da:	30 81       	ld	r19, Z
    11dc:	31 11       	cpse	r19, r1
    11de:	11 c0       	rjmp	.+34     	; 0x1202 <vTaskSwitchContext+0x5a>
    11e0:	21 50       	subi	r18, 0x01	; 1
    11e2:	82 2f       	mov	r24, r18
    11e4:	90 e0       	ldi	r25, 0x00	; 0
    11e6:	fc 01       	movw	r30, r24
    11e8:	ee 0f       	add	r30, r30
    11ea:	ff 1f       	adc	r31, r31
    11ec:	ee 0f       	add	r30, r30
    11ee:	ff 1f       	adc	r31, r31
    11f0:	ee 0f       	add	r30, r30
    11f2:	ff 1f       	adc	r31, r31
    11f4:	e8 0f       	add	r30, r24
    11f6:	f9 1f       	adc	r31, r25
    11f8:	e8 5f       	subi	r30, 0xF8	; 248
    11fa:	fc 4f       	sbci	r31, 0xFC	; 252
    11fc:	30 81       	ld	r19, Z
    11fe:	33 23       	and	r19, r19
    1200:	79 f3       	breq	.-34     	; 0x11e0 <vTaskSwitchContext+0x38>
    1202:	ac 01       	movw	r20, r24
    1204:	44 0f       	add	r20, r20
    1206:	55 1f       	adc	r21, r21
    1208:	44 0f       	add	r20, r20
    120a:	55 1f       	adc	r21, r21
    120c:	44 0f       	add	r20, r20
    120e:	55 1f       	adc	r21, r21
    1210:	48 0f       	add	r20, r24
    1212:	59 1f       	adc	r21, r25
    1214:	da 01       	movw	r26, r20
    1216:	a8 5f       	subi	r26, 0xF8	; 248
    1218:	bc 4f       	sbci	r27, 0xFC	; 252
    121a:	11 96       	adiw	r26, 0x01	; 1
    121c:	ed 91       	ld	r30, X+
    121e:	fc 91       	ld	r31, X
    1220:	12 97       	sbiw	r26, 0x02	; 2
    1222:	02 80       	ldd	r0, Z+2	; 0x02
    1224:	f3 81       	ldd	r31, Z+3	; 0x03
    1226:	e0 2d       	mov	r30, r0
    1228:	12 96       	adiw	r26, 0x02	; 2
    122a:	fc 93       	st	X, r31
    122c:	ee 93       	st	-X, r30
    122e:	11 97       	sbiw	r26, 0x01	; 1
    1230:	45 5f       	subi	r20, 0xF5	; 245
    1232:	5c 4f       	sbci	r21, 0xFC	; 252
    1234:	e4 17       	cp	r30, r20
    1236:	f5 07       	cpc	r31, r21
    1238:	29 f4       	brne	.+10     	; 0x1244 <vTaskSwitchContext+0x9c>
    123a:	42 81       	ldd	r20, Z+2	; 0x02
    123c:	53 81       	ldd	r21, Z+3	; 0x03
    123e:	fd 01       	movw	r30, r26
    1240:	52 83       	std	Z+2, r21	; 0x02
    1242:	41 83       	std	Z+1, r20	; 0x01
    1244:	fc 01       	movw	r30, r24
    1246:	ee 0f       	add	r30, r30
    1248:	ff 1f       	adc	r31, r31
    124a:	ee 0f       	add	r30, r30
    124c:	ff 1f       	adc	r31, r31
    124e:	ee 0f       	add	r30, r30
    1250:	ff 1f       	adc	r31, r31
    1252:	8e 0f       	add	r24, r30
    1254:	9f 1f       	adc	r25, r31
    1256:	fc 01       	movw	r30, r24
    1258:	e8 5f       	subi	r30, 0xF8	; 248
    125a:	fc 4f       	sbci	r31, 0xFC	; 252
    125c:	01 80       	ldd	r0, Z+1	; 0x01
    125e:	f2 81       	ldd	r31, Z+2	; 0x02
    1260:	e0 2d       	mov	r30, r0
    1262:	86 81       	ldd	r24, Z+6	; 0x06
    1264:	97 81       	ldd	r25, Z+7	; 0x07
    1266:	90 93 1b 03 	sts	0x031B, r25	; 0x80031b <pxCurrentTCB+0x1>
    126a:	80 93 1a 03 	sts	0x031A, r24	; 0x80031a <pxCurrentTCB>
    126e:	20 93 e5 02 	sts	0x02E5, r18	; 0x8002e5 <uxTopReadyPriority>
    1272:	08 95       	ret

00001274 <vTaskPlaceOnEventList>:
    1274:	cf 93       	push	r28
    1276:	df 93       	push	r29
    1278:	eb 01       	movw	r28, r22
    127a:	60 91 1a 03 	lds	r22, 0x031A	; 0x80031a <pxCurrentTCB>
    127e:	70 91 1b 03 	lds	r23, 0x031B	; 0x80031b <pxCurrentTCB+0x1>
    1282:	64 5f       	subi	r22, 0xF4	; 244
    1284:	7f 4f       	sbci	r23, 0xFF	; 255
    1286:	0e 94 49 01 	call	0x292	; 0x292 <vListInsert>
    128a:	61 e0       	ldi	r22, 0x01	; 1
    128c:	ce 01       	movw	r24, r28
    128e:	0e 94 2b 06 	call	0xc56	; 0xc56 <prvAddCurrentTaskToDelayedList>
    1292:	df 91       	pop	r29
    1294:	cf 91       	pop	r28
    1296:	08 95       	ret

00001298 <xTaskRemoveFromEventList>:
    1298:	0f 93       	push	r16
    129a:	1f 93       	push	r17
    129c:	cf 93       	push	r28
    129e:	df 93       	push	r29
    12a0:	dc 01       	movw	r26, r24
    12a2:	15 96       	adiw	r26, 0x05	; 5
    12a4:	ed 91       	ld	r30, X+
    12a6:	fc 91       	ld	r31, X
    12a8:	16 97       	sbiw	r26, 0x06	; 6
    12aa:	c6 81       	ldd	r28, Z+6	; 0x06
    12ac:	d7 81       	ldd	r29, Z+7	; 0x07
    12ae:	8e 01       	movw	r16, r28
    12b0:	04 5f       	subi	r16, 0xF4	; 244
    12b2:	1f 4f       	sbci	r17, 0xFF	; 255
    12b4:	c8 01       	movw	r24, r16
    12b6:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
    12ba:	80 91 db 02 	lds	r24, 0x02DB	; 0x8002db <uxSchedulerSuspended>
    12be:	81 11       	cpse	r24, r1
    12c0:	1c c0       	rjmp	.+56     	; 0x12fa <xTaskRemoveFromEventList+0x62>
    12c2:	0a 50       	subi	r16, 0x0A	; 10
    12c4:	11 09       	sbc	r17, r1
    12c6:	c8 01       	movw	r24, r16
    12c8:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
    12cc:	8e 89       	ldd	r24, Y+22	; 0x16
    12ce:	90 91 e5 02 	lds	r25, 0x02E5	; 0x8002e5 <uxTopReadyPriority>
    12d2:	98 17       	cp	r25, r24
    12d4:	10 f4       	brcc	.+4      	; 0x12da <xTaskRemoveFromEventList+0x42>
    12d6:	80 93 e5 02 	sts	0x02E5, r24	; 0x8002e5 <uxTopReadyPriority>
    12da:	90 e0       	ldi	r25, 0x00	; 0
    12dc:	9c 01       	movw	r18, r24
    12de:	22 0f       	add	r18, r18
    12e0:	33 1f       	adc	r19, r19
    12e2:	22 0f       	add	r18, r18
    12e4:	33 1f       	adc	r19, r19
    12e6:	22 0f       	add	r18, r18
    12e8:	33 1f       	adc	r19, r19
    12ea:	82 0f       	add	r24, r18
    12ec:	93 1f       	adc	r25, r19
    12ee:	b8 01       	movw	r22, r16
    12f0:	88 5f       	subi	r24, 0xF8	; 248
    12f2:	9c 4f       	sbci	r25, 0xFC	; 252
    12f4:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
    12f8:	05 c0       	rjmp	.+10     	; 0x1304 <xTaskRemoveFromEventList+0x6c>
    12fa:	b8 01       	movw	r22, r16
    12fc:	89 ee       	ldi	r24, 0xE9	; 233
    12fe:	92 e0       	ldi	r25, 0x02	; 2
    1300:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
    1304:	e0 91 1a 03 	lds	r30, 0x031A	; 0x80031a <pxCurrentTCB>
    1308:	f0 91 1b 03 	lds	r31, 0x031B	; 0x80031b <pxCurrentTCB+0x1>
    130c:	9e 89       	ldd	r25, Y+22	; 0x16
    130e:	86 89       	ldd	r24, Z+22	; 0x16
    1310:	89 17       	cp	r24, r25
    1312:	20 f4       	brcc	.+8      	; 0x131c <xTaskRemoveFromEventList+0x84>
    1314:	81 e0       	ldi	r24, 0x01	; 1
    1316:	80 93 e2 02 	sts	0x02E2, r24	; 0x8002e2 <xYieldPending>
    131a:	01 c0       	rjmp	.+2      	; 0x131e <xTaskRemoveFromEventList+0x86>
    131c:	80 e0       	ldi	r24, 0x00	; 0
    131e:	df 91       	pop	r29
    1320:	cf 91       	pop	r28
    1322:	1f 91       	pop	r17
    1324:	0f 91       	pop	r16
    1326:	08 95       	ret

00001328 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1328:	20 91 e1 02 	lds	r18, 0x02E1	; 0x8002e1 <xNumOfOverflows>
    132c:	fc 01       	movw	r30, r24
    132e:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1330:	20 91 e6 02 	lds	r18, 0x02E6	; 0x8002e6 <xTickCount>
    1334:	30 91 e7 02 	lds	r19, 0x02E7	; 0x8002e7 <xTickCount+0x1>
    1338:	32 83       	std	Z+2, r19	; 0x02
    133a:	21 83       	std	Z+1, r18	; 0x01
    133c:	08 95       	ret

0000133e <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    133e:	cf 93       	push	r28
    1340:	df 93       	push	r29
    1342:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1344:	0f b6       	in	r0, 0x3f	; 63
    1346:	f8 94       	cli
    1348:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    134a:	20 91 e6 02 	lds	r18, 0x02E6	; 0x8002e6 <xTickCount>
    134e:	30 91 e7 02 	lds	r19, 0x02E7	; 0x8002e7 <xTickCount+0x1>
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1352:	80 91 e1 02 	lds	r24, 0x02E1	; 0x8002e1 <xNumOfOverflows>
    1356:	90 81       	ld	r25, Z
    1358:	98 17       	cp	r25, r24
    135a:	29 f0       	breq	.+10     	; 0x1366 <xTaskCheckForTimeOut+0x28>
    135c:	81 81       	ldd	r24, Z+1	; 0x01
    135e:	92 81       	ldd	r25, Z+2	; 0x02
    1360:	28 17       	cp	r18, r24
    1362:	39 07       	cpc	r19, r25
    1364:	b0 f4       	brcc	.+44     	; 0x1392 <xTaskCheckForTimeOut+0x54>
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    1366:	a1 81       	ldd	r26, Z+1	; 0x01
    1368:	b2 81       	ldd	r27, Z+2	; 0x02
    136a:	eb 01       	movw	r28, r22
    136c:	48 81       	ld	r20, Y
    136e:	59 81       	ldd	r21, Y+1	; 0x01
    1370:	c9 01       	movw	r24, r18
    1372:	8a 1b       	sub	r24, r26
    1374:	9b 0b       	sbc	r25, r27
    1376:	84 17       	cp	r24, r20
    1378:	95 07       	cpc	r25, r21
    137a:	68 f4       	brcc	.+26     	; 0x1396 <xTaskCheckForTimeOut+0x58>
    137c:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    137e:	a2 1b       	sub	r26, r18
    1380:	b3 0b       	sbc	r27, r19
    1382:	4a 0f       	add	r20, r26
    1384:	5b 1f       	adc	r21, r27
    1386:	59 83       	std	Y+1, r21	; 0x01
    1388:	48 83       	st	Y, r20
			vTaskSetTimeOutState( pxTimeOut );
    138a:	0e 94 94 09 	call	0x1328	; 0x1328 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    138e:	80 e0       	ldi	r24, 0x00	; 0
    1390:	03 c0       	rjmp	.+6      	; 0x1398 <xTaskCheckForTimeOut+0x5a>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    1392:	81 e0       	ldi	r24, 0x01	; 1
    1394:	01 c0       	rjmp	.+2      	; 0x1398 <xTaskCheckForTimeOut+0x5a>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    1396:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1398:	0f 90       	pop	r0
    139a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    139c:	df 91       	pop	r29
    139e:	cf 91       	pop	r28
    13a0:	08 95       	ret

000013a2 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    13a2:	81 e0       	ldi	r24, 0x01	; 1
    13a4:	80 93 e2 02 	sts	0x02E2, r24	; 0x8002e2 <xYieldPending>
    13a8:	08 95       	ret

000013aa <memcpy>:
    13aa:	fb 01       	movw	r30, r22
    13ac:	dc 01       	movw	r26, r24
    13ae:	02 c0       	rjmp	.+4      	; 0x13b4 <memcpy+0xa>
    13b0:	01 90       	ld	r0, Z+
    13b2:	0d 92       	st	X+, r0
    13b4:	41 50       	subi	r20, 0x01	; 1
    13b6:	50 40       	sbci	r21, 0x00	; 0
    13b8:	d8 f7       	brcc	.-10     	; 0x13b0 <memcpy+0x6>
    13ba:	08 95       	ret

000013bc <_exit>:
    13bc:	f8 94       	cli

000013be <__stop_program>:
    13be:	ff cf       	rjmp	.-2      	; 0x13be <__stop_program>
